## 数论
### 取整
取模 : $x \% y = x - \lfloor x / y \rfloor y$

分块 : 

### 裴蜀定理(贝祖)
$$gcd(a,b) | ax + by$$
将右侧同时除以$gcd(a,b)$还是整数,易证
该定理对于更多项数依然成立
[【模板】裴蜀定理](https://www.luogu.com.cn/problem/P4549)

#### gcd
##### 辗转相除
$$
gcd(x,y) = d,x = da,y = db\\
gcd(x,y) = gcd(y,x \% y)
$$
证明:
$$
b = x \% y = x - ky\\
\because b/d = a - kb \\
\therefore d | x \%y\\
即d|a,d|b \rightarrow d|a\% b,\\
同理d|a\% b,d|b \rightarrow d|a,\\
\therefore (a,b)和(a\%b,b)的因数集相同\\
\therefore gcd(a,b) = gcd(b,a\%b)
$$
##### 辗转相减
gcd(x,y) = gcd(y,x - y)
证明同上,即$(a,b)$和$(b,a - kb)$的因数集是相同的

##### 一些理解
无论是哪种求法,其实都是对于裴蜀定理的应用,

##### exgcd
解方程 $n = x a + y b$
有贝祖定理,显然$gcd(a,b) | n$时才有解
当$b = 0时,x = n / a , y = 0$,所以可以用gcd来求解
$$gcd(a,b) = gcd(b,a \%b) \\
n = x'a + y'b = xb + y(a\%b) \\
= xb + ay - \lfloor a / b \rfloor by\\
= ya + (x - \lfloor a/b \rfloor y)b\\
\therefore x ' = y , y ' = x - \lfloor a/b\rfloor y$$

经过递归,我们可以找到一组解,然后怎么找出其他解?
$$n = xa + yb = (x + k_1)a + (y + k_2)b ,k_1,k_2 \neq 0\\
k_1a = - k_2b \\
lcm(a,b) | k_1a,k_2b$$
即让 $x += k(b/gcd(a,b)),k\in \Z$都是可行解
```cpp
void exgcd(int a,int b,int &x,int &y,const int &n) {
    if(b == 0) {x = n / a; y = 0; return ;}
    int x1,y1;
    exgcd(b,a%b,x1,y1,n);
    x = y1; y = x1 - a / b * y1;
}
```
[【模板】二元一次不定方程 (exgcd)](https://www.luogu.com.cn/problem/P5656)

这样求出的解是绝对值最小的,但是我不会证明
[证明](https://www.cnblogs.com/ycx-akioi/p/kehaixingkehaixing.html)
### 逆元
$x x ^-1 = 1 \mod p$
#### exgcd
#### 费马定理
之前一直没有很好的证明费马小定理的方法,现在补坑:
$a^{p-1} = 1 (\mod p)$
证明:
a,2a,3a,4a,(p-1)a....余数互不相同且对应1,2,3....,p-1      定理1
不妨假设 xa = ya (%p)
xa-ya = kp,因为a不是p的倍数,所以x-y为p的倍数,但1~(p-1)肯定不到p,所以定理1成立
定理一左右两边每个数相乘,所得结果肯定相同
即 $1*2*3*..*(p-1)*a^{p-1} = 1*2*3*..*(p-1) (\mod p)$
综上, a^(p-1)=1 (%p)

推广以上证明过程,可得欧拉定理
a^phi[p]=1 (%p) 其中a,p互质

#### 线性求解
我们希望x的逆元能通过一个比x小的数来求得,
这样才可以保证递归下去有解,同时这个数与p和x都有关
所以我们用取模,即$p\%x < x$
$$p = kx + b\\
kx + b = 0\\
k + b * x^{-1} = 0\\
x^-1 = -k * b^{-1} = (p - k) * b^{-1}$$
$inv[1] = 1$
显然会递归越来越小

#### 阶乘
$$x! (x + 1)= (x+1)!\\
x!(x + 1) * (x + 1)!^{-1} = 1\\
\therefore x!^{-1} =  (x + 1) * (x + 1)!^{-1}$$

#### 任意数线性
类似阶乘的求法,知道了一堆数相乘的逆元求出其一部分的逆元较方便

运用前缀积,用$sum[i]$表示前i个数的前缀积
$sv[i]$表示$sum[i]$的逆元,求出$sv[n]$后可以推出$sv[n - 1]$
$inv[i] = sv[i] * sum[i - 1]$
```cpp
    sum[0] = 1;
    fq(i,1,n) sum[i] = 1ll * sum[i - 1] * a[i] % p;
    sv[n] = fastpow(sum[n] , p - 2);
    fr(i,n - 1,1) sv[i] = sv[i + 1] * a[i + 1] % p;
    fq(i,1,n) inv[i] = sv[i] * sum[i - 1] % p;
```

### 中国剩余定理 CRT 
$$\begin{cases}
x &\equiv a_1 \pmod {p_1} \\
x &\equiv a_2 \pmod {p_2} \\
  &\vdots \\
x &\equiv a_k \pmod {p_k} \\
\end{cases}$$
求得x的值

先考虑p互质的情况,
$p = \prod p_i$,x + p仍然是一个解
考虑构造一个解后$\% p$,

考虑x为一堆项加起来,每一项满足一个同余式,
$$t_i = {p \over p_i}\\
x = \sum a_i \times t_i \times t_i^{-1} ,在\% p_i意义下的逆元$$
由于$t_i$的存在,该项在其他同余式中贡献为0
这种构造方式在拉格朗日插值中也有应用

```cpp
    int p(1),x(0);
    fq(i,1,n) p *= f[i].p;
    fq(i,1,n) {
        __int128 t = p / f[i].p;
        __int128 inv,k;
        exgcd(t,f[i].p,inv,k,1);
        inv = (inv % f[i].p + f[i].p) % f[i].p;
        x = (x + inv * t % p * f[i].a) % p;
    }
```

#### exCRT
p不互质的情况~~~
$x + lcm(p_i)$仍然是一个解

考虑只有2个方程的情况
$$x \equiv a_1 \pmod {p_1} \\ x \equiv a_2 \pmod {p_2}\\
x = k_1p_1 + a_1 = k_2p_2 + a_2\\
k_1p_1 - k2p_2 = a_2 - a_1\\$$
即上述两方程变为
$$x\equiv k_1p_1 + a_1 \pmod{lcm(p1,p2)}$$  
多方程只要合并即可
```cpp
    fq(i,2,n) {
        __int128 k1,k2;
        exgcd(f[i - 1].p,f[i].p,k1,k2,f[i].a - f[i - 1].a);
        __int128 lm = __int128(f[i - 1].p) * f[i].p / __gcd(f[i - 1].p,f[i].p);
        // assert(k1 * f[i - 1].p + f[i - 1].a == -k2 * f[i].p + f[i].a);
        f[i].a = k1 * f[i - 1].p + f[i - 1].a; f[i].p = lm;
        f[i].a = (f[i].a % f[i].p + f[i].p) % f[i].p;
    }
    print(f[n].a);
```