## 最小生成树
由最小生成树的定义不难发现,其充要条件即为
对于图上一条边$(x,y)$,生成树上的路径x->y上的所有边权都小于其边权,
否则显然可以将其替换
由此产生了2种求法
### prim
将迪杰斯特拉的距离换成边权即可,加边前判断是否在2个联通块
不在就加边
### kruskal
将所有边按照边权排序,从小到大加边,加边前判断是否在2个连通块
## kruskal重构树
跑最小生成树时将并不连边,而是将边权作为节点的权值建立节点,
这样在新的生成树上仍保留了 **边的权值大小关系**
即深度越浅(越后加入)的点其所代表的边权值就越大
如可用于找出从x出发,边权值$\leq w$所构成的连通块

或者也可理解成,
让本来各元素间没有等级区分的并查集变成了有等级区分

**常常以找到权值 $\leq q$的连通块为标志**

eg : [Stamp Rally](https://vjudge.net/problem/AtCoder-agc002_d)
[Qpwoeirut and Vertices](https://www.luogu.com.cn/problem/CF1706E)

性质 :
- 边权集合都相同,边权互不相同时MST唯一
- 最小生成树上的路径最大值最小,
  因为如果有最大值更小的路径,肯定会形成环,然后把最大值更大的那个值替换掉

## 建图技巧
### 虚点
在遇到点集A要想B中两两连边,$n^2$肯定会超时,
所以可以建一个虚点t,A和B中每个点分别向t连边,
将时间复杂度降至$n$
eg : [团](https://www.luogu.com.cn/problem/P7100)

### 决策
有一类题目在最短路的同时会有一些限制导致边权发生变化,
这个时候可以给一些点建立虚点,
使得走过这些虚点是必然满足限制条件
eg : [robot](https://www.luogu.com.cn/problem/P7407)

## bfs
在类似合并子树时是dfs(便利下一棵子树时已经完整便利了上一棵子树)
与深度(距离)有关时bfs,
bfs的遍历过程带有深度约束 eg : [[YsOI2023] 广度优先遍历](https://www.luogu.com.cn/problem/P9534)
### 0/1bfs
更改了之前错误的认知
0/1bfs需要用双端队列来维护,将边权为0的放到前面,边权为1的放到后面
因为需要将所有的0处理完之后才能处理1
不要与1/2bfs混淆了
eg:[Nastya and Unexpected Guest](https://www.luogu.com.cn/problem/CF1340C)
### 1/2bfs
用单个队列维护即可
对于边权1让其出队两次,第一次出队时不处理,第二次再处理
>注意 :一定不要与0/1bfs混淆,0/1bfs不能这么写,
因为0/1背包中的0加2遍还是0,这样写就错了s
### Dijkstra
节点的遍历顺序(出队列的顺序),就是其离出发点的距离
当dp的更新顺序与距离(值的大小)有关时可以考虑dj/01bfs
## dp
### 图上
当走过的 边数/距离 在状态里时,
图上的dp一个经典优化,
每次拓展一条边就已经便利了所有的情况,不用便利所有的组合
如走5条边不用便利走2条边和3条边,只要便利走4条边与新加1条边就够了
eg:
[Nastya and Unexpected Guest](https://www.luogu.com.cn/problem/CF1340C)
[Autobus](https://www.luogu.com.cn/problem/P8312)

### 前缀和优化
打开思路,前缀和在dp数组中并不必须是连续的,
当需要将一个$O(n)/O(n^k)$*遍历*求得的东西转换为$O(1)$时,
就可以想到前缀和,
而前缀和可以根据需要决定在dp数组中的取得顺序,
eg:[Smaller Averages G](https://www.luogu.com.cn/problem/P10282)

## 单调性
在题目要求维护严格单调递增时,比较难时
一个经典转换:
将每个数都减去它的下标,即可转换为维护单调不降
eg:[Sonya and Problem Wihtout a Legend](https://codeforces.com/problemset/problem/713/C)

同样,让每个数加它的下标,即可把单调不降变为严格单增

## gcd
### 区间
#### 时间复杂度
区间gcd有一个经典结论:
在一个序列上,序列的长度越长,显然区间gcd越小
同时从一个点出发,其变化次数最多为log(V)次
因为gcd每次变化最大变为原来的一半
如当前区间gcd为24,加入一个数使其减小最大为12
#### 求得
显然gcd拥有结合律
所以可有用线段树和st表求得

eg:[Be Geeks!](https://www.luogu.com.cn/problem/P9607)

## 坐标系
在坐标系中,有一些经典结论,
若b在a,c之间,那么有
$dis(a \rightarrow c) = dis(a \rightarrow b ) + dis(b \rightarrow c)$
以及$ dis(a \rightarrow c) > dis(a \rightarrow b )和 dis(b \rightarrow c) $
这启示我们一些题目只要保留相邻的坐标,
即可在后续如dp/最短路/生成树等操作获得全部需要的信息
eg:[SVEMIR](https://www.luogu.com.cn/problem/P8074)

## 约分
对于需要输出分数时需要约分,这时先除再乘可以多算一点
$$
{p1\over q1 } + {p2 \over q2} = {p1*q2 \over q1 * q2} + {p2 * q1 \over q1 * q2}
$$
这个时候可以先让上下都除以$gcd(q1,q2)$再把两者加起来,再约分

## floyd
floyd是基于dp的算法,其状态含义为:
f[k][i][j]表示从i -> j 除i,j外只经过前k个点时的最短路
所以当转移点k时,即在所有点对的路径中尝试加入点k
```cpp
for (k = 1; k <= n; k++) {
  for (x = 1; x <= n; x++) {
    for (y = 1; y <= n; y++) {
      f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);
    }
  }
}
```
不难发现第一维k可以滚动数组滚掉
因为Floyd的状态设计来自路径,
凡是与 **路径** 有关的都要想到Floyd

## 树状数组后缀和
后缀 = 总和 - 前缀
## dp方程设计
在设计dp方程时,先确定最后的目标,
然后根据目标来确定需求,再根据需求来确定状态

状态考虑因素:
1.每次转移改变的状态较少的. eg: 最长上升子序列
2.递推时尽量使用如 1.$f[i][j] = .... $
而非如 2.$f[i + x][j + y] = ...f[i][j]$
因为许多优化都要 1 才能看出来
eg : [基站选址](https://www.luogu.com.cn/problem/P2605)
3.找出的限制尽量有满足了这个限制不会满足其他限制,即有无后效性
eg : [删数](https://www.luogu.com.cn/problem/P5324)
## 线段树
### 写法
线段树开4倍空间是因为最坏情况下将叶子节点补全到2的幂次个
最后在加上非叶子节点为4倍
la的定义: **该节点进行了什么操作没有下传**

注意: **线段树的叶子节点是不能进行down和up的**,
否则会导致RE,并且叶子节点值更新出错,
因此在 add 的最后一步不能加 la 然后 down,
要直接更新 val 和 la
因此当到了查询区间时就不能down了,
down也要修改为更新左右儿子的值
```cpp
void down(int x,int s,int t) {
    tr[L].val += tr[x].la * (M - s + 1);
    tr[R].val += tr[x].la * (t - M);
    tr[L].la += tr[x].la; tr[R].la += tr[x].la;
    tr[x].la = 0;
}
void add(int x,int l,int r,int s,int t,int val) {
    if(l <= s && t <= r) {
        tr[x].la += val;
        tr[x].val += val * (t - s + 1);
        return ;
    }
    down(x,s,t);
    if(l <= M) add(L,l,r,s,M,val);
    if(M + 1 <= r) add(R,l,r,M + 1,t,val);
    up(x);
}
int query(int x,int l,int r,int s,int t) {
    if(l <= s && t <= r) {
        return tr[x].val;
    }
    down(x,s,t);
    int ans(0);
    if(l <= M) ans += query(L,l,r,s,M);
    if(M + 1 <= r) ans += query(R,l,r,M + 1,t);
    return ans;
}
```

### 多个标记
**线段树上能打多个标记的前提是这些标记能够合并**
具体而言,我们可以把标记看作一个已经操作完尚未下传的序列,
而每次下传后想到与在儿子的标记序列后加入了新的标记,
然后我们需要合并这些标记才能保证时间复杂度
注意合并标记时,进行操作时要规定顺序

### 区间历史和
- 法一 : 我们可以多打两个标记,代表$sum += val$的次数和$add$标记对$sum$的贡献
- 法二 : 考虑区间加会对历史版本和如何变化,设一个时间$t$,
  如果没有区间加,版本和$h_i = t * a_i$,
  再记录一个$c_i$表示$h_i = t*a_i + c_i$,即由于区间加造成的变化,
  那么区间$+x$,$c_i = t * x$,也用区间加维护即可

## 启发式合并
对于两个数组以一定要求合并(一般是取较大值)时,
先找出较小的,只遍历较小的那个,在较大的基础上合并,
并返回较大的地址,以获取更低的复杂度
eg : [春节十二响](https://www.luogu.com.cn/problem/P5290)

**更一般的,将2个集合合并时,将siz小的集合暴力插入大的中**
即每次合并用$min(siz[a],siz[b])$的时间
### 时间复杂度
$nlog(n) $,
当一个数做贡献时,其所在集合大小至少变为2倍

## 倍增
想到倍增是难的,但如果知道了这道题是倍增,很多题都会变得显然

倍增常常以 **第一个/最小值达成某个条件** 为标志,
倍增可以看作是一种特殊的二分,所以许多与二分的标志相似.
理解 : 倍增可以看为已经预处理好信息 (check的值) 的二分,
因为不用check的时间,所以能够获得更优的时间复杂度
eg : [国旗计划](https://www.luogu.com.cn/problem/P4155)

倍增还有一种标志,即**凑出某个数/某个区间**
理解: 可以看成是一种二进制拆分
eg : st表
### 树状数组上倍增

## 括号配对
### 判断
以 （ 为 +1, ） 为 -1 ,
从一个 **（** 开始,第一次前缀和为0时意味着找到了他的配对括号
注 : 不是从头开始,防止出现类似  ）（
eg : [钥匙](https://www.luogu.com.cn/problem/P8339)

## 树状数组
### 维护前缀max...
运算只要有结合律就可以用树状数组维护前缀,
如max,|,&,gcd等等... ,但这些没法维护区间,只能维护前缀
### 区间修改 + 区间查询
普通的树状数组只能实现 
区间修改 + 单点查询 或 单点修改 + 区间查询
但我们想要二者兼得,
$$
d[i] = a[i] - a[i - 1] \\
sum[n] = \sum _{i} ^{i \leq n} a[i]\\
=\sum _{i} ^ {i \leq n} d[i] * (n - i + 1)\\
=(n + 1) * \sum _{i} ^{i \leq n} d[i] - \sum _{i} ^{i \leq n} {d[i] * i}
$$
所以只需要维护2颗树状数组,维护 $d[i]$ 和 $d[i] * i$
**本质是交换求和顺序来将重复的加法变为乘法**
### 高维树状数组
通过维度理解高维树状数组很难且难以拓展的 ?
因此此处用树套树的方式来理解
即树状数组的每个点还是一颗树状数组,每一层树状数组都代表了一维
当$qy(x,y)$时即在第一层树状数组qy(x),然后第二层qy(y)
eg : [上帝造题的七分钟](https://www.luogu.com.cn/problem/P4514)

## hash
### 映射函数
在hash中常将一个小数映射成另一个复杂的数来降低碰撞概率
此处给出一种方法
```cpp
ull g(ull x) {
    x ^= mask;
    x ^= (x << 13); x ^= (x >> 7); x ^= (x << 17);
    x ^= mask; return x;
}
```
其中mask随便选,要大!!!,加ll
通过更改mask合并并不能提供更强的g(),要改移动位数
### 集合hash
**hash除了比较单个数是否相同,也可以比较数集是否相同**
即给数集中每个数分配一个数,求全部数的异或和为整个数集的hash值
### 树hash
判断2棵树是否同构
1.将无根树转换为有根树,以树的重心为根,注意树可能有2个重心!!
2.每个点$hash(u) = c + \sum {g(hash(v))} $,
即对每个节点的子树做集合hash

## 启发式搜索
估算一下当前情况往后至少要多少代价,如果已经劣于最优解就退出
因为其依赖于最优解,所以要考虑搜索顺序,或者**迭代加深**

## 笛卡尔树
笛卡尔树在维护最大最小值中具有天然优势,
即将序列中的大小关系用树形来维护,因此
**当最大/小值 + 连续子序列时**,要想到笛卡尔树上dp
eg : [Comfortably Numb](https://www.luogu.com.cn/problem/CF1777F)
[Array Collapse](https://www.luogu.com.cn/problem/CF1913D)

## 堆拓展
当多个单调递增的序列求第k大时,
可以将每个序列的第一个数放入堆中,
每次取出堆头,然后在放入取出数所在序列中的下一个数,
重复k次即可

## 连续异或
$a_l\oplus a_{l + 1} \dots\oplus a_n = s_n \oplus s_{l - 1}$
即前缀异或和
**异或可以做前缀!!!**
**异或可以做前缀!!!**
**异或可以做前缀!!!**

## 树的重心
### 定义
删除该节点后分成子树大小的最大值最小(将树平均分为几个子树)
### 性质
1. **重心等价于其子树大小不超过原树的一半**
  证明:若u的子树$siz[v] > n / 2 $,向v移动一定更优
  为换为v后u所在$siz < n / 2$,肯定更优

- 树的重心最多只有2个,且必然相邻
  由1易得

1. 树上所有点到重心的距离和最小
  证明:类似换根dp的思路,u向v走,距离和变化量为$n - 2siz[v]$
  而重心又一直向$siz > n/2$的方向走,距离和一定最小

- 将两树连接新的重心在两树重心路径上
  
5. 树上添加/删除1个节点,其重心最多移动1格

**因为重心的优秀性质,其在各种问题中常被用做根**

## 树的直径
求法
- 两次dfs(只能边权非负)
- 树形dp,记录当前节点的最深深度,
  每次加入一颗子树时$d = max(d,maxn + dfs(v) + w(u,v))$


性质:
- 如果边权为正,树上所有直径有一个公共中点
- 将两棵树合并时,新的直径端点属于原树的直径端点
  具体而言,枚举6种直径可能的情况
  **注意:合并时就算是点交叉者并起来也可以,并不需要原来在两棵树中,**
  **一棵树中的点集合并也满足该性质**
  证明可以画出两点集的直径,枚举四个点所有连接方式,运用反证发现都满足该性质
- 一个点离树上最远的点是直径的一个端点

## 欧拉序
树上遍历除了dfs序还有欧拉序,
也就是在进入和退出时都加入序列
**这样相较于dfs序的优点是其出现之后有他们父亲节点的信息,**
### O(1) 的 lca
记录每个点第一次出现位置,
两点出现位置深度最浅的点就是他们的lca,用st表维护就是O(1)

## 分治妙用
### 向上合并答案
### 向下统计答案
分治能够到达每个叶子节点,
在向下过程中另一半区间不会再遍历到了,
所以在递归一个区间时加入另一个区间的答案
也可以看作是另一种倍增 ? 对求和顺序的优化 ?
**能够处理加入容易,删除困难的情况**
eg : [求和42](https://www.xinyoudui.com/ac/contest/74700232800040A022526E6/problem/7258)

#### 进一步
**加入很容易,删除很难,如操作类题目,**
**可以对时间建立线段树,**
得到某个一个操作在哪些时间会存在,
遍历叶子节点

**注意 : 要求满足操作具有交换性**

## 换根dp
换根dp的转移很复杂,给出一般转移方式
- 在dfs开始时重新更新u的节点信息
- 在遍历边过程中从u中删去v的贡献
- dfs后重新加上v的贡献
- 在结束时从u中删去fa贡献

大部分时候不用4步全写,简单dp大都可以合并几步

### 常见转移
1.f来自max,换根时记录最大值和次大值
2.f来自加减乘除,注意乘除时不一定有逆元,用前后缀积

## 除以数
**转移有加法时候除以数不一定逆元(刚好是p的倍数),**
所以要灵活的利用前后缀积避免除法
eg : [Road Improvement](https://www.luogu.com.cn/problem/CF543D)

## 贪心
### 邻项交换
很多贪心题只要排序一下就结束了,但是很难看出来,这里给出满足排序即可的条件

考虑原序列的相邻两项,分别算出交换前后的价值$a,b$,
**通过化简使不等式的一边只与一项有关,**
**这样其就满足了传递性**
证明其满足传递形后就可以排序做了

eg : [国王游戏](https://www.luogu.com.cn/problem/P1080)

#### 依赖类
这类贪心往往是在树形结构上,选一个点必须要选前面一些点,
这个时候可以先整体考虑,考虑全局最优,
该点在选完其前一个点后一定会选他,然后把这两个点合并为一个点
用邻项交换分析合为整体后的权值
eg : [给树染色](https://cdn.acwing.com/problem/content/description/117/)

### 反悔贪心
贪心时每次都选择,知道不能选时去掉前面一个更劣的换成这个
eg : [Work Scheduling G](https://www.luogu.com.cn/problem/P2949)

## 欧拉路径
Hierholzer算法:
去除s的一条出边和t的一条入边,使图有欧拉回路
先找到一个环,去除图中环上所有边,然后再从环上的点出发出发寻找新的环,递归进行,可得到欧拉回路
小奇技淫巧:
在一张所有入度出度都相等的有向图上找环,
一直走第一条边一定能找到环,即不会对边进行反悔不选
证明: 假设出发点为u,经过了点v
当到达v时,如果进入了v i次，那么最多从v出去i-1次,此时v必然还有出边
因而当无路可走时一定停在了u的位置,即找到了一个环

优化: 上述算法时间复杂度为O(n+m)但编码难度大,
既然我们知道无脑深搜一定可以找到环(找到环的顺序对正确性没有影响),
那么递归找环没有必要,直接dfs爆搜就可以了

## 区间内数出现次数为偶数
异或拥有同一个数异或两次为0的优秀性质,
**有一类题询问区间内是否数的出现次数为2次**
**为了防止冲突,可以给每个数随机赋一个新数,然后看区间异或值是否为0**