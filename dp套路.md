# dp的套路
## 计数类dp
### 排列
在排列时经常会遇到转移与前面构造的排列中的数有关的情况,
#### 需要维护新加入的数与前数的大小关系
这时可以用这种构造排列方式:

当构造到排列$a$的前$i$位时,保证所有$a_j\leq i ,j\in[1,i]$,
当从尾部插入一个数$p,p\in [1,i+1]$时,对所有$a_j\geq p,a_j \leftarrow a_j+1$
这样构造的好处是加入数时不会破坏前排列中每相邻2数的大小关系,同时也能得到全部排列
例题:[abc282_g](https://www.luogu.com.cn/problem/AT_abc282_g)
## 前缀和
当我们需要维护一段区间中a出现的次数>=b出现的次数时,并不需要单独维护a,b前缀和
可以将a记为1,b记为-1,前缀和>=0即为a出现次数>=b
eg:[p3105](https://www.luogu.com.cn/problem/P3105)

## 斜率优化
1.参变分离:
$i$为不变量(当前更新的,决策点改变不会改变的量),$j$为变量
2.**写成 $b = y - kx$ 的形式**:
$b$为要最大/小化的值($f[i]$),与j有关的是$y,x$,与$i$有关的是$k$
即将每个决策j变成了二维坐标上的点
3.由此即最大/小化截距,最终只需要维护凸包即可,
4.如果k有单调性,用单调队列可以做到 O(n),否则二分最优决策点,为O(n*lgn)
eg:[玩具装箱](https://www.luogu.com.cn/problem/P3195)

## 背包类
- 交换状态与答案 
eg : [スタンプラリー 3 (Collecting Stamps 3)](https://www.xinyoudui.com/ac/contest/74700232B00040A022519C6/problem/8650)
- dp退出
类似统计方案这种加入顺序没有影响的题,且没有取max这种阴间转移的题,可以考虑将dp数组回溯到之前的状态
eg : [消失之物](https://www.luogu.com.cn/problem/P4141)
- 枚举顺序

## 区间dp
区间dp常常需要记录上次转移来的位置,从左或右

## 状压dp
### 小技巧
1. 预处理集合大小
```cpp
fq(i,1,S) {
    c[i] = c[i ^ (i & (-i))] + 1;
    或
    c[i] = c[i & (i - 1)] + 1
}
```
自带函数
```cpp
__builtin_popcount(x); //返回int类型数的1的个数
__builtin_popcountll(x); //返回long long类型
```
2. 修改某连续位数
- 将要修改的部分变为0 (运用异或 或 &)
- 填补要修改的部分

3. **枚举子集**
```cpp
fq(s,1,S) {
    for(int t = s; t; t = (t - 1) & s){
        ....//code
    }
}
```
复杂度$\sum{n\choose i} 2^i = (1 + 2)^n = O(3^n)$

4. 从s少一个点转移过来,加上这个点的贡献
```cpp
ui pre = s ^ (s & (-s))
```

5. 用时间换空间,2个数组分别记录一半的点集,然后用时合并
这样能快速减小空间,但对时间影响小
eg : [ [省选联考 2020 A/B 卷] 信号传递](https://www.luogu.com.cn/problem/P6622)

### 一些理解
dp能够优化复杂度在于其只保留了需要的信息,
如在很多排列中只保留了末位信息与选择了哪些数,
而其他信息如前面的排列对于统计答案来说没有意义,不用保存,
因而比$n!$的暴力快

### 常见设计方式
- 排列问题f(s,i)表示选了哪些数,最后一个数
- 在棋盘/网格上 记录一条轮廓线,代表上面都转移过了,下面还没转移,
  其中轮廓线上的信息状压维护
  **为什么不用原来一行一行的转移方式呢?**
  考虑一行一行能更快的本质是其每过一行删除一次不需要的信息,
  推广这个思想就是一格格加入,每格删除一次不需要的信息
  也就是所谓轮廓线dp

## 数位dp
1.不考虑n的限制,只考虑放i个十进制位的方案数位$f$
2.考虑n的限制,加状态,上一位是否抵达上边界,前面是否全为前导0