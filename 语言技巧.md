## 函数指针
即一个指向函数的指针
### 指向普通函数
```cpp
int pt(int x){
    return x;
}

//此处的括号防止编译器理解为定义为返回值为int*的叫it的函数,记得加
int (*it)(int) = pt;
cout << it(4);
```
最终结果: 4
### 指向结构体中的函数
#### 静态函数
静态函数在实例化中不会占用地址,而是存在一个其他地址
因此在调用时并不需要实例化
```cpp
struct test{
    int static pt(int x){
        return  x;
    }
};

//注意此处的 & 是必须的,防止编译器认为在调用成员函数
int (*it)(int) = &test::pt; //注意不要打括号,
//否则test::pt变为右值(在寄存器中)无法取地址
cout << it(4);
```

#### 成员函数
成员函数需要实例化才可以调用

解释:
>所有类的对象都有自己数据成员的拷贝，但是成员函数都是共用的，为了区分是谁调用了成员函数，就必须有this指针，this指针是隐式的添加到函数参数列表里去的

```cpp
struct test{
    int pt(int x){
        return  x;
    }
};

/*前面的test::表示这是一个指向成员函数的指针
(传入参数是需要传入this指针)*/
int (test::*it)(int) = &test::pt;

test a;
/*此处(a.*it)的括号很重要,需要传入this指针才能使函数工作*/
cout << (a.*it)(10) << endl;

test *a = new test;
cout << (a->*it)(10)<<endl;
```
### 结合模板
```cpp
struct test{
    int x,y;
    int getx(){return x;}
    int gety(){return y;}
};

template<class T,int (T::*func)()>
void pt(T x){
    cout << (x.*func)()<<endl;
}

test a = {5,6};
pt<test,&test::getx>(a);
pt<test,&test::gety>(a);
```
## 常用函数
### reverse
reverse(begin,end) 翻转左闭右开的区间

## 类
### 返回引用
```cpp
struct Num {
    Num& f() {return *this;}
}
```
就会返回自己的引用
### 重载赋值运算符
```cpp
struct Num {
    Num& operator=(const Num& b) {
        .....
        return *this
    }
}
```
1.返回void也能运行,
返回同类型是为了能够连续 = 赋值,如果用void会报错
2.返回引用为了防止新构造,减少不必要的开销

## :遍历
在使用:遍历时其新建了一个变量,
如果要用其修改原值,需要使用&
```cpp
int a[100];
for(&x : a) x = 10;
```
## 左右值
左值 : 表达式结束后仍会存在的值
右值 : 表达式结束后立刻销毁的值

## &
在许多地方都可以使用引用来提升性能,
如函数的传参,函数的返回(不能返回函数结尾会被销毁变量的引用),:遍历等等 
如果想防止自己手贱改了引用内容,可以使用const &