## 函数指针
即一个指向函数的指针
### 指向普通函数
```cpp
int pt(int x){
    return x;
}

//此处的括号防止编译器理解为定义为返回值为int*的叫it的函数,记得加
int (*it)(int) = pt;
cout << it(4);
```
最终结果: 4
### 指向结构体中的函数
#### 静态函数
静态函数在实例化中不会占用地址,而是存在一个其他地址
因此在调用时并不需要实例化
```cpp
struct test{
    int static pt(int x){
        return  x;
    }
};

//注意此处的 & 是必须的,防止编译器认为在调用成员函数
int (*it)(int) = &test::pt; //注意不要打括号,
//否则test::pt变为右值(在寄存器中)无法取地址
cout << it(4);
```

#### 成员函数
成员函数需要实例化才可以调用

解释:
>所有类的对象都有自己数据成员的拷贝，但是成员函数都是共用的，为了区分是谁调用了成员函数，就必须有this指针，this指针是隐式的添加到函数参数列表里去的

```cpp
struct test{
    int pt(int x){
        return  x;
    }
};

/*前面的test::表示这是一个指向成员函数的指针
(传入参数是需要传入this指针)*/
int (test::*it)(int) = &test::pt;

test a;
/*此处(a.*it)的括号很重要,需要传入this指针才能使函数工作*/
cout << (a.*it)(10) << endl;

test *a = new test;
cout << (a->*it)(10)<<endl;
```
### 结合模板
```cpp
struct test{
    int x,y;
    int getx(){return x;}
    int gety(){return y;}
};

template<class T,int (T::*func)()>
void pt(T x){
    cout << (x.*func)()<<endl;
}

test a = {5,6};
pt<test,&test::getx>(a);
pt<test,&test::gety>(a);
```