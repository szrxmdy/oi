## [吃](https://www.luogu.com.cn/problem/P8365)
没有观察到
重要性质 : 所有$a[i] > 1$的中只会有一个是加

## [A Simple Task](https://www.luogu.com.cn/problem/CF558E?contestId=172291)
这道题肯定不能不是一般的排序方式,
经过陈龙的提醒,这题有性质 : 字母只有26个,
因此考虑进行桶排,
因为是**区间操作**,且要维护信息,所以想到线段树
这道题也是典型的知道是线段树就很好想

## [query](https://vjudge.net/problem/SPOJ-DQUERY)
只管想成桶来维护是难的,
因为不同的数不具备前缀和性质,所以无法直接主席树,
进行一个非常重要的套路转化,
将每个相同的数只统计一次转换为只统计一个区间内相同的数中最靠后的数的贡献
具体实现上,可以离线 + 树状数组
也可以主席树,统计$nex[x] >= r$的个数

## [上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145?contestId=173150)
这道题是经典套路,用并查集来维护删除掉的点

## [【模板】扫描线](https://www.luogu.com.cn/problem/P5490)
考虑有一条扫描线扫过,
用DS维护该y值的线段长度

在矩阵下边 +1,上边 -1,不为0时该线段做出贡献
这是朴素线段树无法维护的,
因为-1后无法统计哪些子区间停止做出了贡献
但是扫描线有性质 : 每次-1意味着之前给同一个区间+1过,
因而想到将更改留在这个区间不下传
标记永久化,不难发现是正确的

细节:离散化后线段树上每个节点代表了一条线段

## [FAR-FarmCraft](https://www.luogu.com.cn/problem/P3574)
贪心好题~~~:
$f[x]$ 为以x为根的子树所需的时间,
而$f[x]$的值会因为走子树的顺序不同而不同,联想到国王游戏
考虑贪心,假设有2颗子树a,b
先走a,后走b :
$f[x] = max(1 + f[a],2*siz[a] + 1 + f[b])$
先走b,后走a :
$f[x] = max(1 + f[b],2*siz[a] + 1 + f[b])$
即如果$max(1 + f[a],2*siz[a] + 1 + f[b]) > max(1 + f[b],2*siz[b] + 1 + f[a])$就先走b

**如果要套用国王游戏需要证明有传递性(式子的一边只与一个字母有关)**
$max(f[a] - f[b],2*siz[a]) > max(0,2*siz[b] + f[a] - f[b])$
因为$siz[a] > 0$
即为$max(f[a] - f[b],2*siz[a]) > 2*siz[b] + f[a] - f[b]$
$max(0,2*siz[a] + f[b] - f[a]) > 2*siz[b]$
因为$siz[b] > 0$
即为$2*siz[a] - f[a] > 2*siz[b] - f[b]$
具有传递性

## [烹调方案](https://www.luogu.com.cn/problem/P1417)
$a - t * b[i]$ , 时间$c[i]$
$f[i][j]$表示第$i$个物品,已经用了$j$的时间了
$f[i][j] = max(f[i - 1][j - c[i]] + a[i] - (j - c[i]) * b[i],f[i - 1][j])$
但是直接这样做就错啦 因为他的价值和做的顺序也有关系,直接便利只考虑了选或不选
国王游戏 ~ 如果选了x和y
先x后y : $a[x] - c[x]*b[x] + a[y] - (c[x] + c[y])*b[y]$
先y后x : $a[y] - c[y]*b[y] + a[x] - (c[x] + c[y])*b[x]$
$c[x] * b[y] < c[y] * b[x]$就先选x

## [世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)
本来写的map,但是map常数大,超时了,所以用数组 + 二分

**这启示我们桶中前缀和如果数据小可以直接记录数组来获得更小常数与更简洁的代码**

## [ [JRKSJ R5] 1-1 A](https://www.luogu.com.cn/problem/P8847)
对于构造题也是不太熟悉,这道题看了题解 :
记 a 为 1 的个数, b 为 -1 的个数,
1.a <= b + 1 从1开始,交替排列1和-1,最终答案为1
2.a > b + 1 
由于可以选择整个序列,所以不难发现答案最小为 a - b,
考虑能否构造出a - b来,即将1和-1交替排序,然后在最后放慢-1即可

**启示我们在做构造题时可以先找出一个答案的边界,再尝试进行构造**

## [[JRKSJ R5] 1-1 B](https://www.luogu.com.cn/problem/P8848)
P8847的拓展
a == b + 1 根据构造,显然只有1种方案
a < b + 1 即不存在2个连续的1 , C_{b + 1}^{a}
a > b + 1 答案的下界为 a - b
**区间问题想到前缀和,最长字段和就是区间问题,**
不难发现只要保证前缀和在[0,a - b]即可
dp是O(n ^ 2) , 此处挖坑,之后学习新算法补上正解
dp[i][j] 表示前i个,前缀和为j
dp[i][j] = dp[i - 1][j + 1] + dp[i - 1][j - 1]

## [[NOIP2009 普及组] 细胞分裂](https://www.luogu.com.cn/problem/P1069)
求出最小的t,使得 s[i]^t % m1^m2 == 0
这不是因式分解秒了
注意 **用:遍历map等容器时更改p不会更改容器中的值**

## [[NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)
显然可以转换成只有一种颜色
限制转换为 $(x + z) % 2 == 0$ , 
即 x & 1 == z & 1
贡献为 $(x + z) * (a[x] + a[z])$
维护一下前缀和秒啦

## [[HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)
不会做,最后还是看了题解:
是拆贡献的题,一条边的贡献就是其2边同色点个数的乘积
$f[i][j]$表示子树i中用了j个黑点时其内部边的贡献,
一个个加入子树,$f[i][j] = f[to][k] + f[i][j - k] + w * $
(白点个数乘积 + 黑点个数乘积)

**启示我们遇到答案与 类似点对/所有路径 等有关时可以尝试拆贡献到边上**

**注意:树上背包一定要一个个加子树才能保证$n^2$的复杂度**

## [[Opoi 2024] 简谐振动](https://www.luogu.com.cn/problem/P10534)
**先满足大部分的,然后在调整**
假设现在需要满足的序列 s1,s2....
可以是a[i + 1] = s[i] - a[i] , a[0] = 0;
这样除了s[n]都满足啦,接下来调整使s[n]满足,
发现一下更能+-2 , 最终发现只要s的和是偶数就可以啦

注意细节:最后一个数字必须选

## [[NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)
经典背包题,
如果一个数能被前面的数表示,他就没用,
01背包秒啦

## [[Opoi 2024] 二十六点](https://www.luogu.com.cn/problem/P10536)
先考虑pi都是1,
f[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
若pi != 1,
g[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
且 dep[k] - dep[x] > p[i]

考虑建26颗线段树,f就是每次询问一段dfn的答案
考虑如何求g,发现获得一段深度的线段树是很难的
考虑更改求得g的求解顺序,这不是拿桶维护一下就好了

## [[JRKSJ R2] 01 序列](https://www.luogu.com.cn/problem/P7809)
先考虑操作1
l ~ r取出最长的00011子序列
s0[k] - s0[l - 1] + s1[r] - s1[k]
= s1[r] - s0[l - 1] + s0[k] - s1[k]
操作2
直接判断一下nex就可以了
注意要更新l - 1能取到0

## [[HEOI2012] 采花](https://www.luogu.com.cn/problem/P4113)
这类题十分套路,即**拆贡献**,
先参考HH的项链的思路,即**只让最后一个点做出贡献**
但这样有些不该贡献的点也会贡献,
即如果一个点是最后一个点,且las < l那么他的贡献要减去
具体来说,给las + 1 ~ i的贡献 -1

## [[ABC238E] Range Sums](https://www.luogu.com.cn/problem/AT_abc238_e)
有m种操作,每个操作可以将l~r +-任意数,
求是否最终能将1~n全部变为1,
**区间+-可以转换为差分 ~~**
最终,d[1] = 1,d[n + 1] = -1,

## [Range Deleting](https://www.luogu.com.cn/problem/CF1167E)
因为在值域上操作
考虑做一个桶,即如果 $i < j$ , 那么$t[i]所有数 < t[j]$
$t[i].MAX < t[j].MIN $, 
即删除 $l ~ r$ 后 $t[i].MIN > t[i - 1].MAX$,用双指针维护即可

## [[SHOI2011] 双倍回文](https://www.luogu.com.cn/problem/P4287)
学了回文自动机后看到回文串就要想到他 ~~~ ,
双倍回文就是一个回文串的后缀中有个长度为他一半的回文,
在fail树上跳即可

## [[APIO2014] 回文串](https://www.luogu.com.cn/problem/P3649)
回文自动机因为加点时是从前往后加的,
所以一些简单的dp(如统计出现次数)没必要新建link树,只要从后往前便利即可

## [[JSOI2013] 快乐的 JYY](https://www.luogu.com.cn/problem/P5685)
回文串想到回文自动机~~
两个都建出来后处理一下出现次数,dfs即可

## [[NOI Online #2 提高组] 涂色游戏](https://www.luogu.com.cn/problem/P6476)
不妨令p1 < p2, 
kp1 % p2 = x , x 最小为gcd(p1,p2),
即只要从gcd(p1,p2)开始到p2 - 1有几个p1即可

## [[NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目](https://www.luogu.com.cn/problem/P3951)
这道题2数互质,有贝祖定理有
(gcd(a,b) = 1) | (x * a + y * b)
所以一定有答案

这类问题都比较相似,
**选一个做模数,从同余角度出发会好想一点**
不妨令 a > b
n = xa + yb
n % a = d -> n = ka + d = xa + yb
yb = (k - x)a + d >= 0
即k为x的最大的最小正整数解
k即为b / gcd(a,b) - 1, 即 b - 1,
n = (b - 1)a即可保证y一定>=0,
此时,n = (b - 1)a + 0 * b,
那么此时n - b就是最大的构造出的不符合的数
n = (b - a)a - b = ab - a - b

## [【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)
这道题看似需要高精,其实用到了一个数可以表示成
$\sum_i 10^i *a_i $ ,对每个数分别取模即可

## [Imbalance Value of a Tree](https://www.luogu.com.cn/problem/CF915F)
看到枚举点对,想到拆贡献,
考虑一个点做几次最大,几次最小
也就是求一个点相邻的由比他小的点构成的连通块大小
从小到大加点,并查集求连通块大小

据说把点权拆到边上可以获得更小的常数

## [ [TJOI2017] 可乐](https://www.luogu.com.cn/problem/P3758)
这是一道经典的套路题,即从u -> v经过t条边有几条路径
f[t][u][v]表示经过t条边后从u->v的路径数量
$f[t][u][v] = sum f[t - 1][u][k] * f[1][k][v] , k = 1 - > n$
牛逼的来了,我们发现这个是可以用矩阵乘法来模拟的,
所以矩阵快速幂就行了

**这启示我们看到三重循环就要想一下矩阵快速幂**
**以及图上那个经典的dp方式,每次加一条边/点**

对于这道题,具体来说,只要加入爆炸和不动的方式就行啦
自爆额外弄一个点统计一下答案

## [[BalticOI 2021 Day2] The Xana coup](https://www.luogu.com.cn/problem/P8127)
那么这道题的关键问题在于其会对父亲做出影响,
因此状态中我们设计一维表示父亲来处理后效性即可
f[x][0/1][0/1]表示将除x外所有点变为0后点x的权值,是否操作了x
考虑如何转移,
**此时又有一个树上dp经典套路,即考虑了前i个子树时的答案**
这样能够避免考虑操作的奇偶次数,
**这也是一个经典思想,即一个个加入替代一下次考虑全部**

## [[USACO23DEC] Flight Routes G](https://www.luogu.com.cn/problem/P9980)
如果是2个相邻的点,只要看是否为1即可,
然后考虑相邻3个点,我们看2个点算出的结果是否与其相同即可
一直往上枚举len即可

## [妖梦斩木棒](https://www.luogu.com.cn/problem/P3797)
忽略所有X,如果')'前面是'(',那么会做出一次贡献
因为要忽略所有X,所以考虑那个经典的删点套路,并查集~~
具体而言,离线后倒序操作 
爽,题看错了~~~~~~~~~ 还可以修改为X
接下来,我要珂了,bushi
**其实根本不用这么麻烦,我们删点其实用set就可以了,**
**之前用并查集只是因为常数小**

但这题数据过水,暴力比正解快~~~
这道题正解其实是线段树,以后可以补一下

## [由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)
问l ~ r是否可重排为连续的一段,单点修改
如果没有修改显然可以莽可持久化线段树,

转换为max - min = r - l + 1,且l ~ r中没有重复的数,
max和min可以用线段树维护,
**l ~ r没有重复的数可以转换为所有nex > r,即MIN(nwx) > r**
所以三颗线段树秒啦 

这道题题解中还有一种nb的做法，
如果我们知道了值域,就知道了每个数应该是多少,
**而要匹配是否数集全部相同,可以用hash + 异或来做**
即给每个数分配一个hash值,然后求出值域后比较前缀hash异或值是否相同

## [红色的幻想乡](https://www.luogu.com.cn/problem/P3801)
1.对(x,1~m) ^= 1,(1~n,y) ^= 1
2.求矩形中值为1的个数

(x,y)的值为对行x操作次数(f[i])^y操作次数(g[i]),
f[x] = 1 ? g[l ~ r] = 0的个数 : g[l ~ r] = 1的个数
所以2颗树状数组即可

## [双人游戏](https://www.luogu.com.cn/problem/P10608)
看了题解 ~~~:
R希望段数多,M希望段数少,求最后的段数
若s[i] != s[i - 1] & s[i] ,++cnt

对于一个已经填好颜色的块来说,将序列分成了2段,左右互补影响
所以我们考虑B_???? 怎么填,
对于R来说,填W是肯定不劣于填B,
如果因为填W而导致后面减少了贡献,其贡献最多减少1,
因为贡献减少1后就变为了与填B相同的情况,而W已经做出了一次贡献
同理,对M来说,填B不会劣于填W

如果没有已经填好的块,让第一个任意填即可

**这其实是一类套路题,即当贡献为1时,**
**我们可以构造只关注眼前的贪心,然后证明该贪心是不劣的,因为之后最多少1贡献**

## [Bear and Bowling 4](https://www.luogu.com.cn/problem/CF660F)
求最大的 sum i * a[i] 的连续子序列
要求sum i * a[i],
定义sum1为i * a[i]前缀和,sum2为a前缀和
sum[l ~ r] = sum1[r] - sum1[l - 1] - (sum2[r] - sum2[l - 1]) * (l - 1)

f[i] = max {s[j - i]}
= s1[i] - s1[j - 1] - (s2[i] - s2[j - 1]) * (j - 1)
= s1[i] + ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
f[i] - s1[i] = ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
        b    =       y                            -   k   *     x
k不一定单调递增,所以二分
**在一个先增后减的函数中二分最高点,可以看相邻点斜率**

## [[NOI2019] 回家路线](https://www.luogu.com.cn/problem/P5468)
将每班车视为一个点,如果y[u] == x[v],且q[u] <= p[v]
那么u向v连边 ? 最多有n^2条边 寄啦
所以不能简单最短路,还要考虑边权的规律
但是最短路的思路可以借鉴,用f[i]表示第i个班次的最小烦恼值,
显然f是按照p的顺序来更新的,且只与x的位置的点有关

f[i] = max{f[j] + w(j,i)} , j.q <= i.p , j.y = i.x
f[i] = f[j] + A * (i.p - j.q)^2 + B * (i.p - j.q) + C
f[i] - A * i.p^2 - B * i.p - C = A * j.q^2 - B * j.q + f[j] - 2 * A * j.q * i.p
        b                  =             y              -      x       * k
那么就是一个斜率优化,其中x单增,可以用单调栈搞

**这道题启示我们当要选边走时可以把边作为图上的点做最短路，**
**即图上跑那条边也可以看作一种决策**
**排序前后要确定是否将原有的编号打乱了~~~!!!!**

## [[NOI2005] 瑰丽华尔兹](https://www.luogu.com.cn/problem/P2254)
要让走的路程最长,即要让停止次数最少,
在一个区间内在哪里暂停都是相同情况,爆搜200^200 ~~
f[k][i][j]表示完成时到达i,j的最少暂停次数
然后暴力模拟,发现n^4,显然过不去,但数据比较水过了😒

**因为遍历时单向遍历,**
**且该题贡献时是全体加1,不会改变大小关系,所以可以单调队列**

## [Array Collapse](https://www.luogu.com.cn/problem/CF1913D)
看了题解
每次操作选择一个区间将除最小值外的值删去,
**因为与区间最小最大及其位置有关,所以考虑笛卡尔树**
f[x]为x子树中的方案数
f[x] = f[l] * f[r] + 一个东西
这个东西来自跨x的区间的删除方案
**如果在x中合并统计是很难的,所以在子树中统计这个东西的贡献**
注意取模时不能用max(..,1)来特判为0的情况,因为可能是个大数刚好模成0

## [[SCOI2005] 骑士精神](https://www.luogu.com.cn/problem//P2324)
继续看题解~~
每次交换最多会让一个棋子到达其符合的位置
所以就是忽略空格的与目标棋盘的不同数为估值函数

## [Black Hills golden jewels](https://codeforces.com/problemset/gymProblem/101064/D)
求序列中选2个第K大.
因为K十分大,考虑二分,然后就是双指针板子啦

## [特殊价值](https://www.xinyoudui.com/ac/contest/747001E3A00040A02251206/problem/8508)
s[r] - s[l - 1] - sx[r] ^ sx[l - 1]
考虑开始全部选完了,要减小一个数意味着其能使异或值也变小
且异或减小的值大于总和减小的值,但几个数异或起来 <= 他们的和
即从左右选尽可能多的数,使他们的价值不变

## [「CROI · R2」在相思树下 I](https://www.luogu.com.cn/problem/P10765)
考虑记录每次删完后留下的第一个数,不管哪个操作删完后中间的间隔都相同
秒了~!!!!

## [ランプ (Lamps)](https://www.luogu.com.cn/problem/AT_joisc2019_h)
看了题解,听了lay
最小操作数我们在于要让操作尽可能让更多的点满足条件
**即每次新加入一个点有多种方式满足条件,**
**看其是否能与前一个点的操作合并**

## [[NOI2010] 航空管制](https://www.luogu.com.cn/problem/P1954)
**这与菜肴制作是同一类题,即要将某个点尽可能早的遍历到**
**正着做很难,因为不知到某个点在哪个路径上,但反图上只要不选他即可**
**体现了正难则反的思想 ~~~~~**
对于这道题具体来说,除了入度为0还要满足其可以起飞
难点在于随着时间的进行一些之前入度以为0但不可以起飞的可以飞了,
观察到时间单调递增,且值域为n,所以可以用桶来维护

## [[国家集训队] 等差子序列](https://www.luogu.com.cn/problem/P2757)
等差数列只要三个就够了,排列考虑用桶来维护
考虑桶上如何做,即中间点左右两边桶上相同位置一个在左边一个在右边
即其所有都在左边就不满足,
所以从左往右扫描,把在左边标记为1,如果中间为回文串就不满足,这可以用hash判断
**即经典转换,当移动一个个时,将在左右的大小关系改为0/1标记**

## [Tourists](https://www.luogu.com.cn/problem/CF487E)
点双后方点的权值是所连圆的最小值,圆点就是圆点的权值
然后就卡住啦,被NEW_HOPE提醒后想出来了,圆方树也是树
**即我们查询一条链的时候,经过方节点时大多都经过了其父亲,只有一个没经过父节点**
所以方节点只需要记录其子节点的值就可以了,具体而言,
更新一个圆节点时只要让其更新其父节点的值即可

调试经验:用namespace分开不同的区块,
线段树每个函数都记得考虑up和down,
写树剖时考虑求数组的顺序与用当前点还是其链顶

## [[ZJOI2007] 最大半连通子图](https://www.luogu.com.cn/problem/P2272)
开始一眼没看出来是tarjan,
强连通图一定满足条件,所以先把强连通的点都缩掉,
然后就变成一张DAG,发现若连通子图只能是DAG上一条链
**计数问题要记得判重边**

## [Divan and Kostomuksha](https://codeforces.com/problemset/problem/1614/D1)
上课讲的题,
首先是贪心,即我们尽可能不让gcd下降,下降后答案一定劣于不下降
因为选择下降会使原来不下降的数贡献减少,但并不会增加其他数的贡献
考虑不得不下降时我们怎么选,下降到数x的贡献为x * 是x的倍数但不是当前数的倍数的个数
因为是当前数的倍数的数都在维持gcd时被用掉了
定义f[x]为gcd为x时不算x,后面的gcd的贡献

**这道题难点在于贪心,gcd下降的很快且不会上升的应用,**
**以及dfs过程中遍历因数可以一个个质因子除下去**

## [GCD](https://www.luogu.com.cn/problem/P2568)
要求$gcd = p$,对于此类题,一般的做法是将a,b同除p,
然后求$gcd(a,b) = 1$的个数,运用欧拉函数即可

## [Interval GCD](https://www.luogu.com.cn/problem/P10463)
这道题开始没有看出来,老师讲了才懂
**区间加是无法维护gcd的,我们只能维护单点修改的gcd,因此考虑差分,**
**差分后就是gcd本质的应用,即gcd(a,b) = gcd(b,a - kb)**
原来gcd对负数的也适用

## [完全平方数](https://www.xinyoudui.com/ac/contest/7470023980004390220CDC6/problem/8341)
要凑2是很难得,但要找到1比较简单
把所有数都乘起来,然后再把多余的除掉

## [消失之物](https://www.luogu.com.cn/problem/P4141)
dp回溯的经典应用
$f[x] = g[x] + g[x - w[i]]\\g[x] = f[x] - g[x - w[i]] $
回溯$g[x]$需要$g[x - w[i]] $,所以从前往后回溯

## [硬币购物](https://www.luogu.com.cn/problem/P1450)
之前做的容斥题,但一直不太懂,现在补上思路
我们要同时满足四种条件,因此是第二类容斥
即要做其对立条件的容斥.
对于硬币a数量 $\leq d_a$的对立条件就是$\geq d_a + 1$,
因此枚举条件组合时如果要求条件1的对立条件必须成立
我们我们可以钦定已经选了$d_a + 1$个硬币1,
而其他条件是不用管的,
**因为容斥时我们是通过条件找元素,而不是通过元素找条件**

## [[HAOI2011] Problem b](https://www.luogu.com.cn/problem/P2522)
**对于在数域上求区间方案数时,常见的方法是运用前缀和改为从好处理的从1开始**
**打开思路,对于此题来说就是二维前缀和**

## [猫尾酒馆](https://www.xinyoudui.com/ac/contest/74700232800040A022526E6/problem/7256)
订单按照品质排序,$f[i][j]$表示处理到第i个订单,剩下$j$瓶酒没有用时最多赚的钱
关键在于如何想到这个dp
**按照品质排序是显然的,这样通过调整dp顺序即可使得满足品质的约束**
**当酒买入后其对于答案有意义的只剩下了数量,所以dp状态中记录当前就的数量即可**

## [WTP的通缉](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4365)
难爆了,不会做,听老师讲
**树上距离最长应该想到直径**
这道题使用线段树来维护点集的直径,即点集直径的合并
**两点集的最长距离即枚举直径端点**

## [蹦蹦炸弹](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4640)
难爆了,不会做,听老师讲
倍增 + 并查集 类似 萌萌哒
显然最小生成树,关键在于如何维护并查集,
**观察到操作是很有规律的,因此可以考虑建立树形结构下传操作**
具体而言,第k层并查集如果连接了x ~ y,
代表了$x - x + 2^k$与$y - y + 2^k$依次连边,逐层下传连边
最多连$nlog(n)$次边
```cpp
int merge(int x,int y,int k) {
    int a(t[k].find(x)),b(t[k].find(y));
    if(a == b) return 0;
    t[k].fa[a] = b;
    if(!k) return 1;
    return merge(x,y,k - 1) + \
    merge(x + (1 << (k - 1)),y + (1 << (k - 1)),k - 1);
}
```
类似于st表的结构,与线段树的思路
**启示我们操作十分有规律,可以拆分成2半分别做时,可以构造树形结构倍增,上层对下一层只有2个节点,便于在层间传递信息**
**并不一定局限于打tag,每个点只会走一次也能将复杂度降低**