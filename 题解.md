## [吃](https://www.luogu.com.cn/problem/P8365)
没有观察到
重要性质 : 所有$a[i] > 1$的中只会有一个是加

## [A Simple Task](https://www.luogu.com.cn/problem/CF558E?contestId=172291)
这道题肯定不能不是一般的排序方式,
经过陈龙的提醒,这题有性质 : 字母只有26个,
因此考虑进行桶排,
因为是**区间操作**,且要维护信息,所以想到线段树
这道题也是典型的知道是线段树就很好想

## [query](https://vjudge.net/problem/SPOJ-DQUERY)
只管想成桶来维护是难的,
因为不同的数不具备前缀和性质,所以无法直接主席树,
进行一个非常重要的套路转化,
将每个相同的数只统计一次转换为只统计一个区间内相同的数中最靠后的数的贡献
具体实现上,可以离线 + 树状数组
也可以主席树,统计$nex[x] >= r$的个数

## [上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145?contestId=173150)
这道题是经典套路,用并查集来维护删除掉的点

## [【模板】扫描线](https://www.luogu.com.cn/problem/P5490)
考虑有一条扫描线扫过,
用DS维护该y值的线段长度

在矩阵下边 +1,上边 -1,不为0时该线段做出贡献
这是朴素线段树无法维护的,
因为-1后无法统计哪些子区间停止做出了贡献
但是扫描线有性质 : 每次-1意味着之前给同一个区间+1过,
因而想到将更改留在这个区间不下传
标记永久化,不难发现是正确的

细节:离散化后线段树上每个节点代表了一条线段

## [FAR-FarmCraft](https://www.luogu.com.cn/problem/P3574)
贪心好题~~~:
$f[x]$ 为以x为根的子树所需的时间,
而$f[x]$的值会因为走子树的顺序不同而不同,联想到国王游戏
考虑贪心,假设有2颗子树a,b
先走a,后走b :
$f[x] = max(1 + f[a],2*siz[a] + 1 + f[b])$
先走b,后走a :
$f[x] = max(1 + f[b],2*siz[a] + 1 + f[b])$
即如果$max(1 + f[a],2*siz[a] + 1 + f[b]) > max(1 + f[b],2*siz[b] + 1 + f[a])$就先走b

**如果要套用国王游戏需要证明有传递性(式子的一边只与一个字母有关)**
**即满足邻项交换**
$max(f[a] - f[b],2*siz[a]) > max(0,2*siz[b] + f[a] - f[b])$
因为$siz[a] > 0$
即为$max(f[a] - f[b],2*siz[a]) > 2*siz[b] + f[a] - f[b]$
$max(0,2*siz[a] + f[b] - f[a]) > 2*siz[b]$
因为$siz[b] > 0$
即为$2*siz[a] - f[a] > 2*siz[b] - f[b]$
具有传递性

## [烹调方案](https://www.luogu.com.cn/problem/P1417)
$a - t * b[i]$ , 时间$c[i]$
$f[i][j]$表示第$i$个物品,已经用了$j$的时间了
$f[i][j] = max(f[i - 1][j - c[i]] + a[i] - (j - c[i]) * b[i],f[i - 1][j])$
但是直接这样做就错啦 因为他的价值和做的顺序也有关系,直接便利只考虑了选或不选
国王游戏 ~ 如果选了x和y
先x后y : $a[x] - c[x]*b[x] + a[y] - (c[x] + c[y])*b[y]$
先y后x : $a[y] - c[y]*b[y] + a[x] - (c[x] + c[y])*b[x]$
$c[x] * b[y] < c[y] * b[x]$就先选x

## [世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)
本来写的map,但是map常数大,超时了,所以用数组 + 二分

**这启示我们桶中前缀和如果数据小可以直接记录数组来获得更小常数与更简洁的代码**

## [ [JRKSJ R5] 1-1 A](https://www.luogu.com.cn/problem/P8847)
对于构造题也是不太熟悉,这道题看了题解 :
记 a 为 1 的个数, b 为 -1 的个数,
1.a <= b + 1 从1开始,交替排列1和-1,最终答案为1
2.a > b + 1 
由于可以选择整个序列,所以不难发现答案最小为 a - b,
考虑能否构造出a - b来,即将1和-1交替排序,然后在最后放慢-1即可

**启示我们在做构造题时可以先找出一个答案的边界,再尝试进行构造**

## [[JRKSJ R5] 1-1 B](https://www.luogu.com.cn/problem/P8848)
P8847的拓展
a == b + 1 根据构造,显然只有1种方案
a < b + 1 即不存在2个连续的1 , C_{b + 1}^{a}
a > b + 1 答案的下界为 a - b
**区间问题想到前缀和,最长字段和就是区间问题,**
不难发现只要保证前缀和在[0,a - b]即可
dp是O(n ^ 2) , 此处挖坑,之后学习新算法补上正解
dp[i][j] 表示前i个,前缀和为j
dp[i][j] = dp[i - 1][j + 1] + dp[i - 1][j - 1]

## [[NOIP2009 普及组] 细胞分裂](https://www.luogu.com.cn/problem/P1069)
求出最小的t,使得 s[i]^t % m1^m2 == 0
这不是因式分解秒了
注意 **用:遍历map等容器时更改p不会更改容器中的值**

## [[NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)
显然可以转换成只有一种颜色
限制转换为 $(x + z) % 2 == 0$ , 
即 x & 1 == z & 1
贡献为 $(x + z) * (a[x] + a[z])$
维护一下前缀和秒啦

## [[HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)
不会做,最后还是看了题解:
是拆贡献的题,一条边的贡献就是其2边同色点个数的乘积
$f[i][j]$表示子树i中用了j个黑点时其内部边的贡献,
一个个加入子树,$f[i][j] = f[to][k] + f[i][j - k] + w * $
(白点个数乘积 + 黑点个数乘积)

**启示我们遇到答案与 类似点对/所有路径 等有关时可以尝试拆贡献到边上**

**注意:树上背包一定要一个个加子树才能保证$n^2$的复杂度**

## [[Opoi 2024] 简谐振动](https://www.luogu.com.cn/problem/P10534)
**先满足大部分的,然后在调整**
假设现在需要满足的序列 s1,s2....
可以是a[i + 1] = s[i] - a[i] , a[0] = 0;
这样除了s[n]都满足啦,接下来调整使s[n]满足,
发现一下更能+-2 , 最终发现只要s的和是偶数就可以啦

注意细节:最后一个数字必须选

## [[NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)
经典背包题,
如果一个数能被前面的数表示,他就没用,
01背包秒啦

## [[Opoi 2024] 二十六点](https://www.luogu.com.cn/problem/P10536)
先考虑pi都是1,
f[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
若pi != 1,
g[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
且 dep[k] - dep[x] > p[i]

考虑建26颗线段树,f就是每次询问一段dfn的答案
考虑如何求g,发现获得一段深度的线段树是很难的
考虑更改求得g的求解顺序,这不是拿桶维护一下就好了

## [[JRKSJ R2] 01 序列](https://www.luogu.com.cn/problem/P7809)
先考虑操作1
l ~ r取出最长的00011子序列
s0[k] - s0[l - 1] + s1[r] - s1[k]
= s1[r] - s0[l - 1] + s0[k] - s1[k]
操作2
直接判断一下nex就可以了
注意要更新l - 1能取到0

## [[HEOI2012] 采花](https://www.luogu.com.cn/problem/P4113)
这类题十分套路,即**拆贡献**,
先参考HH的项链的思路,即**只让最后一个点做出贡献**
但这样有些不该贡献的点也会贡献,
即如果一个点是最后一个点,且las < l那么他的贡献要减去
具体来说,给las + 1 ~ i的贡献 -1

## [[ABC238E] Range Sums](https://www.luogu.com.cn/problem/AT_abc238_e)
有m种操作,每个操作可以将l~r +-任意数,
求是否最终能将1~n全部变为1,
**区间+-可以转换为差分 ~~**
最终,d[1] = 1,d[n + 1] = -1,

## [Range Deleting](https://www.luogu.com.cn/problem/CF1167E)
因为在值域上操作
考虑做一个桶,即如果 $i < j$ , 那么$t[i]所有数 < t[j]$
$t[i].MAX < t[j].MIN $, 
即删除 $l ~ r$ 后 $t[i].MIN > t[i - 1].MAX$,用双指针维护即可

## [[SHOI2011] 双倍回文](https://www.luogu.com.cn/problem/P4287)
学了回文自动机后看到回文串就要想到他 ~~~ ,
双倍回文就是一个回文串的后缀中有个长度为他一半的回文,
在fail树上跳即可

## [[APIO2014] 回文串](https://www.luogu.com.cn/problem/P3649)
回文自动机因为加点时是从前往后加的,
所以一些简单的dp(如统计出现次数)没必要新建link树,只要从后往前便利即可

## [[JSOI2013] 快乐的 JYY](https://www.luogu.com.cn/problem/P5685)
回文串想到回文自动机~~
两个都建出来后处理一下出现次数,dfs即可

## [[NOI Online #2 提高组] 涂色游戏](https://www.luogu.com.cn/problem/P6476)
不妨令p1 < p2, 
kp1 % p2 = x , x 最小为gcd(p1,p2),
即只要从gcd(p1,p2)开始到p2 - 1有几个p1即可

## [[NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目](https://www.luogu.com.cn/problem/P3951)
这道题2数互质,有贝祖定理有
(gcd(a,b) = 1) | (x * a + y * b)
所以一定有答案

这类问题都比较相似,
**选一个做模数,从同余角度出发会好想一点**
不妨令 a > b
n = xa + yb
n % a = d -> n = ka + d = xa + yb
yb = (k - x)a + d >= 0
即k为x的最大的最小正整数解
k即为b / gcd(a,b) - 1, 即 b - 1,
n = (b - 1)a即可保证y一定>=0,
此时,n = (b - 1)a + 0 * b,
那么此时n - b就是最大的构造出的不符合的数
n = (b - a)a - b = ab - a - b

## [【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)
这道题看似需要高精,其实用到了一个数可以表示成
$\sum_i 10^i *a_i $ ,对每个数分别取模即可

## [Imbalance Value of a Tree](https://www.luogu.com.cn/problem/CF915F)
看到枚举点对,想到拆贡献,
考虑一个点做几次最大,几次最小
也就是求一个点相邻的由比他小的点构成的连通块大小
从小到大加点,并查集求连通块大小

据说把点权拆到边上可以获得更小的常数

## [ [TJOI2017] 可乐](https://www.luogu.com.cn/problem/P3758)
这是一道经典的套路题,即从u -> v经过t条边有几条路径
f[t][u][v]表示经过t条边后从u->v的路径数量
$f[t][u][v] = sum f[t - 1][u][k] * f[1][k][v] , k = 1 - > n$
牛逼的来了,我们发现这个是可以用矩阵乘法来模拟的,
所以矩阵快速幂就行了

**这启示我们看到三重循环就要想一下矩阵快速幂**
**以及图上那个经典的dp方式,每次加一条边/点**

对于这道题,具体来说,只要加入爆炸和不动的方式就行啦
自爆额外弄一个点统计一下答案

## [[BalticOI 2021 Day2] The Xana coup](https://www.luogu.com.cn/problem/P8127)
那么这道题的关键问题在于其会对父亲做出影响,
因此状态中我们设计一维表示父亲来处理后效性即可
f[x][0/1][0/1]表示将除x外所有点变为0后点x的权值,是否操作了x
考虑如何转移,
**此时又有一个树上dp经典套路,即考虑了前i个子树时的答案**
这样能够避免考虑操作的奇偶次数,
**这也是一个经典思想,即一个个加入替代一下次考虑全部**

## [[USACO23DEC] Flight Routes G](https://www.luogu.com.cn/problem/P9980)
如果是2个相邻的点,只要看是否为1即可,
然后考虑相邻3个点,我们看2个点算出的结果是否与其相同即可
一直往上枚举len即可

## [妖梦斩木棒](https://www.luogu.com.cn/problem/P3797)
忽略所有X,如果')'前面是'(',那么会做出一次贡献
因为要忽略所有X,所以考虑那个经典的删点套路,并查集~~
具体而言,离线后倒序操作 
爽,题看错了~~~~~~~~~ 还可以修改为X
接下来,我要珂了,bushi
**其实根本不用这么麻烦,我们删点其实用set就可以了,**
**之前用并查集只是因为常数小**

但这题数据过水,暴力比正解快~~~
这道题正解其实是线段树,以后可以补一下

## [由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)
问l ~ r是否可重排为连续的一段,单点修改
如果没有修改显然可以莽可持久化线段树,

转换为max - min = r - l + 1,且l ~ r中没有重复的数,
max和min可以用线段树维护,
**l ~ r没有重复的数可以转换为所有nex > r,即MIN(nwx) > r**
所以三颗线段树秒啦 

这道题题解中还有一种nb的做法，
如果我们知道了值域,就知道了每个数应该是多少,
**而要匹配是否数集全部相同,可以用hash + 异或来做**
即给每个数分配一个hash值,然后求出值域后比较前缀hash异或值是否相同

## [红色的幻想乡](https://www.luogu.com.cn/problem/P3801)
1.对(x,1~m) ^= 1,(1~n,y) ^= 1
2.求矩形中值为1的个数

(x,y)的值为对行x操作次数(f[i])^y操作次数(g[i]),
f[x] = 1 ? g[l ~ r] = 0的个数 : g[l ~ r] = 1的个数
所以2颗树状数组即可

## [双人游戏](https://www.luogu.com.cn/problem/P10608)
看了题解 ~~~:
R希望段数多,M希望段数少,求最后的段数
若s[i] != s[i - 1] & s[i] ,++cnt

对于一个已经填好颜色的块来说,将序列分成了2段,左右互补影响
所以我们考虑B_???? 怎么填,
对于R来说,填W是肯定不劣于填B,
如果因为填W而导致后面减少了贡献,其贡献最多减少1,
因为贡献减少1后就变为了与填B相同的情况,而W已经做出了一次贡献
同理,对M来说,填B不会劣于填W

如果没有已经填好的块,让第一个任意填即可

**这其实是一类套路题,即当贡献为1时,**
**我们可以构造只关注眼前的贪心,然后证明该贪心是不劣的,因为之后最多少1贡献**

## [Bear and Bowling 4](https://www.luogu.com.cn/problem/CF660F)
求最大的 sum i * a[i] 的连续子序列
要求sum i * a[i],
定义sum1为i * a[i]前缀和,sum2为a前缀和
sum[l ~ r] = sum1[r] - sum1[l - 1] - (sum2[r] - sum2[l - 1]) * (l - 1)

f[i] = max {s[j - i]}
= s1[i] - s1[j - 1] - (s2[i] - s2[j - 1]) * (j - 1)
= s1[i] + ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
f[i] - s1[i] = ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
        b    =       y                            -   k   *     x
k不一定单调递增,所以二分
**在一个先增后减的函数中二分最高点,可以看相邻点斜率**

## [[NOI2019] 回家路线](https://www.luogu.com.cn/problem/P5468)
将每班车视为一个点,如果y[u] == x[v],且q[u] <= p[v]
那么u向v连边 ? 最多有n^2条边 寄啦
所以不能简单最短路,还要考虑边权的规律
但是最短路的思路可以借鉴,用f[i]表示第i个班次的最小烦恼值,
显然f是按照p的顺序来更新的,且只与x的位置的点有关

f[i] = max{f[j] + w(j,i)} , j.q <= i.p , j.y = i.x
f[i] = f[j] + A * (i.p - j.q)^2 + B * (i.p - j.q) + C
f[i] - A * i.p^2 - B * i.p - C = A * j.q^2 - B * j.q + f[j] - 2 * A * j.q * i.p
        b                  =             y              -      x       * k
那么就是一个斜率优化,其中x单增,可以用单调栈搞

**这道题启示我们当要选边走时可以把边作为图上的点做最短路，**
**即图上跑那条边也可以看作一种决策**
**排序前后要确定是否将原有的编号打乱了~~~!!!!**

## [[NOI2005] 瑰丽华尔兹](https://www.luogu.com.cn/problem/P2254)
要让走的路程最长,即要让停止次数最少,
在一个区间内在哪里暂停都是相同情况,爆搜200^200 ~~
f[k][i][j]表示完成时到达i,j的最少暂停次数
然后暴力模拟,发现n^4,显然过不去,但数据比较水过了😒

**因为遍历时单向遍历,**
**且该题贡献时是全体加1,不会改变大小关系,所以可以单调队列**

## [Array Collapse](https://www.luogu.com.cn/problem/CF1913D)
看了题解
每次操作选择一个区间将除最小值外的值删去,
**因为与区间最小最大及其位置有关,所以考虑笛卡尔树**
f[x]为x子树中的方案数
f[x] = f[l] * f[r] + 一个东西
这个东西来自跨x的区间的删除方案
**如果在x中合并统计是很难的,所以在子树中统计这个东西的贡献**
注意取模时不能用max(..,1)来特判为0的情况,因为可能是个大数刚好模成0

## [[SCOI2005] 骑士精神](https://www.luogu.com.cn/problem//P2324)
继续看题解~~
每次交换最多会让一个棋子到达其符合的位置
所以就是忽略空格的与目标棋盘的不同数为估值函数

## [Black Hills golden jewels](https://codeforces.com/problemset/gymProblem/101064/D)
求序列中选2个第K大.
因为K十分大,考虑二分,然后就是双指针板子啦

## [特殊价值](https://www.xinyoudui.com/ac/contest/747001E3A00040A02251206/problem/8508)
s[r] - s[l - 1] - sx[r] ^ sx[l - 1]
考虑开始全部选完了,要减小一个数意味着其能使异或值也变小
且异或减小的值大于总和减小的值,但几个数异或起来 <= 他们的和
即从左右选尽可能多的数,使他们的价值不变

## [「CROI · R2」在相思树下 I](https://www.luogu.com.cn/problem/P10765)
考虑记录每次删完后留下的第一个数,不管哪个操作删完后中间的间隔都相同
秒了~!!!!

## [ランプ (Lamps)](https://www.luogu.com.cn/problem/AT_joisc2019_h)
看了题解,听了lay
最小操作数我们在于要让操作尽可能让更多的点满足条件
**即每次新加入一个点有多种方式满足条件,**
**看其是否能与前一个点的操作合并**

## [[NOI2010] 航空管制](https://www.luogu.com.cn/problem/P1954)
**这与菜肴制作是同一类题,即要将某个点尽可能早的遍历到**
**正着做很难,因为不知到某个点在哪个路径上,但反图上只要不选他即可**
**体现了正难则反的思想 ~~~~~**
对于这道题具体来说,除了入度为0还要满足其可以起飞
难点在于随着时间的进行一些之前入度以为0但不可以起飞的可以飞了,
观察到时间单调递增,且值域为n,所以可以用桶来维护

## [[国家集训队] 等差子序列](https://www.luogu.com.cn/problem/P2757)
等差数列只要三个就够了,排列考虑用桶来维护
考虑桶上如何做,即中间点左右两边桶上相同位置一个在左边一个在右边
即其所有都在左边就不满足,
所以从左往右扫描,把在左边标记为1,如果中间为回文串就不满足,这可以用hash判断
**即经典转换,当移动一个个时,将在左右的大小关系改为0/1标记**

## [Tourists](https://www.luogu.com.cn/problem/CF487E)
点双后方点的权值是所连圆的最小值,圆点就是圆点的权值
然后就卡住啦,被NEW_HOPE提醒后想出来了,圆方树也是树
**即我们查询一条链的时候,经过方节点时大多都经过了其父亲,只有一个没经过父节点**
所以方节点只需要记录其子节点的值就可以了,具体而言,
更新一个圆节点时只要让其更新其父节点的值即可

调试经验:用namespace分开不同的区块,
线段树每个函数都记得考虑up和down,
写树剖时考虑求数组的顺序与用当前点还是其链顶

## [[ZJOI2007] 最大半连通子图](https://www.luogu.com.cn/problem/P2272)
开始一眼没看出来是tarjan,
强连通图一定满足条件,所以先把强连通的点都缩掉,
然后就变成一张DAG,发现若连通子图只能是DAG上一条链
**计数问题要记得判重边**

## [Divan and Kostomuksha](https://codeforces.com/problemset/problem/1614/D1)
上课讲的题,
首先是贪心,即我们尽可能不让gcd下降,下降后答案一定劣于不下降
因为选择下降会使原来不下降的数贡献减少,但并不会增加其他数的贡献
考虑不得不下降时我们怎么选,下降到数x的贡献为x * 是x的倍数但不是当前数的倍数的个数
因为是当前数的倍数的数都在维持gcd时被用掉了
定义f[x]为gcd为x时不算x,后面的gcd的贡献

**这道题难点在于贪心,gcd下降的很快且不会上升的应用,**
**以及dfs过程中遍历因数可以一个个质因子除下去**

## [GCD](https://www.luogu.com.cn/problem/P2568)
要求$gcd = p$,对于此类题,一般的做法是将a,b同除p,
然后求$gcd(a,b) = 1$的个数,运用欧拉函数即可

## [Interval GCD](https://www.luogu.com.cn/problem/P10463)
这道题开始没有看出来,老师讲了才懂
**区间加是无法维护gcd的,我们只能维护单点修改的gcd,因此考虑差分,**
**差分后就是gcd本质的应用,即gcd(a,b) = gcd(b,a - kb)**
原来gcd对负数的也适用

## [完全平方数](https://www.xinyoudui.com/ac/contest/7470023980004390220CDC6/problem/8341)
要凑2是很难得,但要找到1比较简单
把所有数都乘起来,然后再把多余的除掉

## [消失之物](https://www.luogu.com.cn/problem/P4141)
dp回溯的经典应用
$f[x] = g[x] + g[x - w[i]]\\g[x] = f[x] - g[x - w[i]] $
回溯$g[x]$需要$g[x - w[i]] $,所以从前往后回溯

## [硬币购物](https://www.luogu.com.cn/problem/P1450)
之前做的容斥题,但一直不太懂,现在补上思路
我们要同时满足四种条件,因此是第二类容斥
即要做其对立条件的容斥.
对于硬币a数量 $\leq d_a$的对立条件就是$\geq d_a + 1$,
因此枚举条件组合时如果要求条件1的对立条件必须成立
我们我们可以钦定已经选了$d_a + 1$个硬币1,
而其他条件是不用管的,
**因为容斥时我们是通过条件找元素,而不是通过元素找条件**

## [[HAOI2011] Problem b](https://www.luogu.com.cn/problem/P2522)
**对于在数域上求区间方案数时,常见的方法是运用前缀和改为从好处理的从1开始**
**打开思路,对于此题来说就是二维前缀和**

## [猫尾酒馆](https://www.xinyoudui.com/ac/contest/74700232800040A022526E6/problem/7256)
订单按照品质排序,$f[i][j]$表示处理到第i个订单,剩下$j$瓶酒没有用时最多赚的钱
关键在于如何想到这个dp
**按照品质排序是显然的,这样通过调整dp顺序即可使得满足品质的约束**
**当酒买入后其对于答案有意义的只剩下了数量,所以dp状态中记录当前就的数量即可**

## [WTP的通缉](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4365)
难爆了,不会做,听老师讲
**树上距离最长应该想到直径**
这道题使用线段树来维护点集的直径,即点集直径的合并
**两点集的最长距离即枚举直径端点**

## [蹦蹦炸弹](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4640)
难爆了,不会做,听老师讲
倍增 + 并查集 类似 萌萌哒
显然最小生成树,关键在于如何维护并查集,
**观察到操作是很有规律的,因此可以考虑建立树形结构下传操作**
具体而言,第k层并查集如果连接了x ~ y,
代表了$x - x + 2^k$与$y - y + 2^k$依次连边,逐层下传连边
最多连$nlog(n)$次边
```cpp
int merge(int x,int y,int k) {
    int a(t[k].find(x)),b(t[k].find(y));
    if(a == b) return 0;
    t[k].fa[a] = b;
    if(!k) return 1;
    return merge(x,y,k - 1) + \
    merge(x + (1 << (k - 1)),y + (1 << (k - 1)),k - 1);
}
```
类似于st表的结构,与线段树的思路
**启示我们操作十分有规律,可以拆分成2半分别做时,可以构造树形结构倍增,上层对下一层只有2个节点,便于在层间传递信息**
**并不一定局限于打tag,每个点只会走一次也能将复杂度降低**

## [第一题](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4359)
这道题前面都在找规律,难的是最后对于hashsum的统计,
其用到了原串本身也是一个公共前后缀,因而可以dp求解

## [Master of Both](https://codeforces.com/gym/104090/problem/K)
上课讲的题,一眼不会做,加深了对字典树的理解
n,q都非常大,难以每次询问都重做一遍
**对于此类更改字符顺序的题,经典套路就是预处理出$f[i][j]$表示字符i在字符j前的贡献然后每次询问统计**
具体而言,在字典树上插入时统计即可

## [聚会](https://www.xinyoudui.com/ac/contest/74700232900040A02252416/problem/7301)
字典树合并 + tag 肯定可以完成一次
如何换根dp捏 ? 拆位异或,统计每位答案,那其实也不用字典树

## [Collapsing Strings](https://www.luogu.com.cn/problem/CF1902E)
上课讲的,一眼不会做
首先分析题目,转换成能看懂的东西,
末尾和开头一样是难以描述的,可以看成去除a和b的反串的lcp
|C(a,b)| 为 |a| + |b| - 2 * |lcp(a,b)| 
求lcp在字典树中易维护

## [Xor-Subsequence](https://www.luogu.com.cn/problem/CF1720D1)
上课讲的题,不讲我一百年都想不到~~~
在a中取出一些下标b,使得相邻2个下标有 a[b[i]] ^ b[i + 1] < a[b[i + 1]] ^ b[i]
我们希望让i在一边,i + 1在另一边,但异或后又不能维持 < 不边,
所以我们希望是 = ,考虑 < 的本质是二进制上从左往右某位左边是0而右边是1
即有一位p,p的前面b[i] ^ a[b[i]]全部相等,
第p位时 b[i - 1]_p != a[b[i]]_p , b[i]_p = a[b[i - 1]]_p
可以在字典树上状态转移更新

## [LuoTianyi and the Function](https://www.luogu.com.cn/problem/CF1824D)
经典套路,用容斥可以将i,j转换为从1开始
g(i,j)为最大的x使得a[i] ~ a[j]的数集与 a[x] ~ a[j]数集相同
如此复杂的转移在线维护不现实,考虑离线下来扫描线
对于固定的数集和j,x的取值是固定的,而数集大小我们很会求,拆贡献即可
考虑固定j后,我们可以用数集的个数来获得x的大小,
用f[j][k]表示当右端点为j,数集大小为k时x的大小,
即每个有贡献的位置到上个有贡献的位置其值是该位置的下标
现在用一个线段树就能轻易的统计 sum i = 1 - > l g(i,j)的大小啦,
然后统计j的和应该怎么办呢? 我们可以每次让线段树加一次自己 ?
到这里这道题就做完啦,但我不会区间历史和线段树,寄啦,看题解,学知识

## [「CQOI2018」解锁屏幕](https://www.luogu.com.cn/problem/P4460)
经典状压,排列顺序记录选了哪些数和最后一个数是什么
**关键在于合理的预处理帮助转移,这题可以预处理出点对i,j经过哪些点**

## [ [省选联考 2020 A/B 卷] 信号传递](https://www.luogu.com.cn/problem/P6622)
经典排列状压,记录选了哪些点
如何预处理才能快速转移 ?
如果a[i + 1]在a[i]左边,那么会贡献 $k * (p[a[i + 1]] + p[a[i]])$
如果a[i + 1]在a[i]右边,那么会贡献 $p[a[i + 1]] - p[a[i]]$
肯定要预处理i传给j信号几次,
**因为我们希望只记录选了哪些点就够了,所以考虑把贡献拆到点上**
即如果加入点i时j在i左边,贡献 += $w[i][j] * k * p + w[j][i] * p$
如果加入i时j在i右边,贡献 += $-w[i][j] * p + w[j][i] * k * p$
这样的转移时O(m^2)的,还是会T
考虑预处理,$cost(s,i)$表示点集s状态下加入i的代价,此处可以提前p减少码量
**具体而言,此处用了一个经典的套路,即cost(s,i)从s少一个点转移过来,可以用lowbit做**
**但这样又爆空间了,此时又用一个经典的套路,我们可以把他拆成2半,转移时再合并起来,注意拆分后的实际意义,$cost1[s][i]$是右半点集的贡献,而非$0...0 + s$的贡献**
相当于用时间换空间,时间 * 2,空间开根

## [[九省联考 2018] 一双木棋 chess](https://www.luogu.com.cn/problem/P4363)
轮廓线dp,记录当前轮廓线的信息,
从左下到右上的轮廓线,1表示该位置向上,0表示向右
合法状态少,用dfs写
当前位置为{n - ct(1),ct(0)},每次能把状态中10翻转为01

## [Petya and Spiders](https://www.luogu.com.cn/problem/CF111C)
蜘蛛的移动有特点,即其只能向周围4个点动一下
所以一个0周围4个点一定有1
用1表示空格,直接2 ^ 3m次

## [[NOIP2017 提高组] 宝藏](https://www.luogu.com.cn/problem/P3959)
最小生成树,边权为 w * 深度
**先设计状态涵盖所有情况**
f(S,T,d) 表示一棵树点集为S,叶子节点为T,深度为d
$+ w(i,j) * (d + 1) -> f(S + i,i,d + 1) , j \in T$
$+ w(i,j) * d -> f(S + i,T + i,d) , j not \in T$
这样就涵盖了所有的情况,
虽然连到非叶子节点后其深度不一定为d,转移非法,
**但这样一定不优,因而对答案没有影响,进一步套用该思想,叶子也不用记录**
快速转移,预处理一下g(s,i)表示i向集合s的最短连边即可

## [给树染色](https://cdn.acwing.com/problem/content/description/117/)
[link2](https://www.xinyoudui.com/ac/contest/747001E3800040A02252156/problem/8625)
**依赖类贪心模板题**
染色代价为 前面已染色的点 * 代价
我们要确定染色顺序
显然,如果树只有2层,那我肯定会先染权值最大的点
但可能权值小的点后面跟了一个大的点,先染权值小的点反而更优,那怎么办?
转换思路,从整颗树上考虑,朴素想法先染权值最大的点,
但权值最大的点不一定在第一个,
**可我们不难发现其父亲节点染完后一定会直接染他,所以可以将其和父亲节点合并为一个点**
考虑合并后的权值,用邻项交换来分析,不难发现就是其平均值
具体实现,用并查集进行节点合并,用堆找最大平均值

## [[AGC023F] 01 on Tree](https://www.luogu.com.cn/problem/AT_agc023_f)
贪心,有0肯定选0,但有时候0要先选1才能选,
仍然那个经典套路,把其和父节点合并,
不难发现块按照ct0 / ct1从大到小排序

## [[IOI2019] 排列鞋子](https://www.luogu.com.cn/problem/P5749)
考虑同种鞋子应该怎么放,
手模发现每个鞋子一定与其后面第一个同种鞋子配对
知道配对方案后如何求交换次数,此时用到一个小技巧,
**用原编号代表鞋子,每次交换会使最终情况中逆序对个数 +1,**
**所以最终情况的逆序对个数就是交换次数,**
逆序对个数邻项交换可贪心,
具体而言,设两数<a1,b1>,<a2,b2>,
若min(a1,b1) < min(a2,b2),
那么1在前面逆序对最多2个,2在前面逆序对至少两个

## [[CQOI2011] 分金币](https://www.luogu.com.cn/problem/P5817)
先考虑在链上的简化情况,每次考虑当前第一个不满足的,然后向后要/送金币即可
手模发现,最终的代价就是值 - avg后前缀和的绝对值的和

在环上怎么做 ? 考虑规定一个方向,正数表示给金币,负数表示要金币
$X_i$表示i向右传递的金币数,$a_i - x_i + x_{i - 1} = avg$,
$x_1 = a_1 + x_n - avg,x_2 = a_1 + a_2 + x_n - 2*avg,x_3= ...$
$x_i = x_n - i*avg + \sum^i_j a_j $
$ans = \sum_i^n |x_i|$
发现和链上类似,只是多了一个x_n项,而x_n可以任选,
就相当于给一堆数中,自己设定一个数x,是x到其他数的距离和最小
可以考虑每次增加一个数贪心,发现就是中位数

**启示我们在面对这类算术计数题,发现无法感性理解时,要进行数学建模转换成数学语言才能进行下一步推导**

## [细胞分裂](https://www.xinyoudui.com/ac/contest/74700233200040A02252EC6/problem/8452)
最后一个细胞一定不砍,且是原序列的最大值,
倒二个细胞最大值<=最后一个,且最小值要尽可能大
所以尽可能平分即可

## [Mathematical Problem](https://www.luogu.com.cn/problem/CF1916D)
构造题,在数的后面加2个零其仍是完全平方数,
在$169$中加零变为$10609,1006009$等其仍是完成平方数

## [Evaluate It and Back Again](https://www.luogu.com.cn/problem/CF1912E)
课上讲的题
如果表达式A只由个位数相加乘组成,其正反答案是一样的,
如果B = 0 - A,那么B反读为-B
考虑将p和q拆成 a + b 和 a - b , 构造即为 A + B - 0
但有时候并不能这样拆分,此时可以拆分为 a + b + 21 和 a - b + 12
构造即为A + B - 0 + 21
如果a是负数,0 - A - 0
其中0要对A/B中每一项都加

## [[COCI2018-2019#1] Teoretičar](https://www.luogu.com.cn/problem/P7307)
课上讲的题,
首先先找到答案的下界,C > 度数最多点的度数,
所以考虑构造一个<= 2 ^ log(度数最多点度数) 的方案,
因此考虑分治,每次将边集分成两半染色,然后合并,
如果每个点的边都只有一条,那就是都染成1,
合并边集就是将另一个边集的颜色全体加上一个数
问题在于如何分边集才能使一个端点的边被均分到2个边集中,
如果存在一条回路,那么给dfs时向右染1,向左染0即可

但原图上不一定存在回路. 考虑欧拉回路的存在条件是每个点度数为偶数,
思考二分图的度数特点,左右度数和是相同的,
为了保持度数都是偶数,我们可以两边各建一个虚点,向对面的奇节点连边
最终如果虚点使奇数,相互连边即可

**启示我们二分图上建虚点的技巧,将点上的边分为两半可以用回路**
**启示我们构造时运用分治**

## [[POI2013] MOR-Tales of seafaring](https://www.luogu.com.cn/problem/P3556)
d不一定是简单路径,我们可以在2个点上来回走即可,所以只要奇偶相等即可,
具体而言,记录一个点到另一个点路径长为奇/偶数的最短路,可以把一个点拆为2个点
注意特判孤立点的情况

## [百度地图的实时路况](https://www.xinyoudui.com/ac/contest/74700231C00040A022913F6/problem/8592)
便于添加但难以删除,求剩余每一个点不加,加入操作可换顺序
经典分治套路,向一边递归时加入另一边贡献

## [[NOIP2017 提高组] 逛公园](https://www.luogu.com.cn/problem/P3953)
f[u][k] 表示到u,比最短路长k的路径方案数
$f[v][k] += f[u][j] ,if dis[v] + k = dis[u] + w + j$
$j = dis[u] + k - dis[pre] - w$
如何进行转移 ? 注意到转移顺序非常复杂,
**对于转移顺序难的dp,即使是图上,也不要忘记了用dfs记忆化搜索!**
无解相当于一个点需要通过自己的状态转移
记录一下是否在栈中即可

如果不使用dfs的奇技淫巧,我们应该如何做呢? 
**对于图上dp顺序的依赖问题,可以考虑建立分层图,**
**具体而言,把每个点复制k遍,每层上的点代表了一个k**
而判无解就是在同层判0环,这要用tarjan,
具体来说,可以值考虑边权为0的边跑缩点,看有没有点个数 >0

## [K-th Path](https://www.luogu.com.cn/problem/CF1196F)
诈骗题!! 
**k这么小,首先先考虑一个答案的下界,**
k <= 400,所以答案不会大于长度第400大的边,
所以取前400条边做floyd即可

## [Shortest Path](https://www.luogu.com.cn/problem/CF59E)
额外记录一维表示从那个点过来,正常转移即可

## [Minimum spanning tree for each edge](https://www.luogu.com.cn/problem/CF609E)
对于最小生成树性质的利用,
考虑先建出最小生成树,然后加入一条边,
将原最小生成树u -> v路径上最大的边换掉,
因为MST的u -> v路径上最大的边就是u -> v所有路径最大边的最小值,
所以其值是唯一的,任意建立一个MST即可

## [「JOISC 2015 Day 4」Inheritance](https://loj.ac/p/3004)
考虑一条条加边,如果第一个人加不上去,就看第二个人,
一个往后看,所以建k个并查集,因为图越来越不联通,所以可以二分

## [Counting Graphs](https://www.luogu.com.cn/problem/CF1857G)
树上加入哪些边不会改变或增加最小生成树 ?
考虑枚举点对u,v,在其中加入一条边权大于u->v最大值的边即可

**发现复杂度爆掉了,难以枚举时要拆贡献,**
**将贡献从点对拆到最大值的边上**
枚举以某条边为最大值的点对有多少个
考虑从大到小删边,每次删边后分成的两个连通块的大小乘积就是点对个数,
那从小到大加边是一样的

## [[NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)
要获得边权$\geq$一定值的连通块,
经典套路,用最大生成kruskal重构树

## [Xor-MST](https://www.luogu.com.cn/problem/CF888G)
考虑kruskal,如何找到当前边权最小的
异或想到用tril树,考虑tril树上如何统计答案,
tril树上lca越深的节点肯定先被连起来,
画图发现tril树其实代表了连接的分治树,dfs遍历节点u,
节点u2子树内已经联通,然后选一条边权最短的边连接两子树,
可以遍历2子树即可,每个点最多被遍历log次,复杂度nlogn

关键在于将画图的方式转换为编程可实现的语言

## [Flip Digits 2](https://atcoder.jp/contests/typical90/tasks/typical90_aw)
区间翻转可以看作区间异或1,随意可以视为差分,
现在每个操作可以看作在2个点上^=1,
经典建图套路,将被操作的两点连起来,
如果最终得到图联通,我们就可以任意改这n个节点,
而第n + 1个由其他点权值得到

## [Power Tree](https://www.luogu.com.cn/problem/CF1120D)
区间加可以用差分变为改变两个点
仍然是那个经典套路,连接两个可以操作的边,
如果最终联通成树即表示其可改变所有点,
**可以从树上的叶子节点开始修改为指定的值,**
最终根节点的值由其他值决定

**常常以花代价购买操作为标志**

## [[NOIP2020] 移球游戏](https://www.luogu.com.cn/problem/P7115)
考虑n = 2的情况,
**不妨观察样例二就能看出怎么移动的,**
假设2号柱中有p个1球,先将1号柱上p个球移动到3号柱,
然后将2号中的p个1移到1号,m - p个2移到3号柱,此时2号空了,
之后将3号全部移动到2号,这样2就在最下面了,
再将1号的p个1移到3号,2号上方乱的移到1号,
最后将1号上方乱的,1移到3号,2移到2号,最后将3全部移到1号
至多用5m次操作,空行没有改变,1号全是1,2号全是2

我们发现n = 2的情况已经很复杂了,所以肯定不是想出n更大的通解,
**考虑将n更大的情况转换为n = 2,经典构造分治**
钦定一个mid,<= mid的标为0,> mid的标为1,
但0/1数量不一定相同,
我们可以将n = 2的情况看作把较多的数提取到一边
因此分治时两两遍历即可

**操作类题注意把操作封装为函数来写**

## [[NOI2019] 弹跳](https://www.luogu.com.cn/problem/P5471)
考虑h = 1,就是线段树优化建图,
所以二维就是线段树套线段树优化建图
但这样空间会爆炸,
线段树空间不够,可以改成平衡树,或直接使用KD树

优化建图的思路是可以套用的,
但把图上的边连完空间也就爆了,所以得利用数据结构来获得最短的距离,
**打开思路,dj中堆只是一个获得最短距离的工具,可以换成其他数据结构**
具体而言,就是每次更新一个方格内的最短距离,获得全局最小距离
这可以用KD-tree维护.

看了题解中有更妙的方法,
dj在边权为0时有一些特性,
**即如果一个u -> v为0,那么当遍历u时,v一定入队,**
所以给每个弹跳建虚点,用数据结构维护该虚点能够到达的点,然后直接把这些点删除即可

**因此在优化建图时常常将虚点到实点的边权赋为0,这样可以免去麻烦的取最小值,而改为简单的删除**

## [[NOI2010] 超级钢琴](https://www.luogu.com.cn/problem/P2048)
选出k个最大的l ~ r,价值为s[r] - s[l],L <= r - l <= R,l,r \in [0,n]
选择这么多,但要选出的数少,考虑堆拓展,
将每个r看作一个序列,每次从堆里选出一个数,加入所在序列的下一个数
具体而言,每个r选出一个数后其所要求的最短区间就被拆分成了两半,分别入堆即可
然后就是简单的RMQ了

## [Berland and the Shortest Paths](https://www.luogu.com.cn/problem/CF1005F)
选出n - 1条道路,使得dis[2] + dis[3] + dis[4] + ..最小
**考虑让贪心让每个dis最小,发现并不让其他dis更大,**
所以输出最短路树即可
考虑如何输出方案,每个点建桶即可

## [树与排列](https://www.xinyoudui.com/ac/contest/74700233000040A02252C06/problem/8718)
手模排列,将当前a_i当作下一个下标
发现问题等价于树上遍历所有点再回去的最长距离和
考虑在链上应该怎么做 ? 
手模发现来回跳一定最优 , 树上怎么做 ?
一直跳能跳的点的直径(边都为1)即可,这样不好统计贡献
将贡献拆掉边上,就是最小子树的大小*2,
证明 : 一个边最多被经过其最小子树大小 * 2次,
而刚刚构造的方法刚好达到了上界

## [[NOIP2012 提高组] 疫情控制](https://www.luogu.com.cn/problem/P1084)
显然,军队只可能在1号节点向下移动一次,其他时候都只会向上走,
如果1号节点叶子数多余m则无解,否则有解
直接制定耗时最短的方案非常难
**要最小化某一变量,且有单调性,考虑2分时间t,**
贪心一直向上走即可,
关键在于贪心如何做,先让所有点尽可能走,走到1的子树下方,
然后处理这些可以支援其他点的军队
错误的想法是子树中至少留一个点,
因为可能留下的这个点剩余距离还很长,
不如另一个子树中剩余距离短的点来代替他,让他支援另一个距离远的子树,
然后就不会做了,看题解,有性质,
**如果最后一个点无法走到1再走回自己,**
**那他不会支援其他子树,因为来代替他的军队剩余距离肯定大于他**

## [航班请求](https://www.xinyoudui.com/ac/contest/74700233A00040A02253206/problem/8334)
考虑答案上界为n,即将所有点连成环,互相两两可达,
考虑在环上操作,
要满足弱连通至少要n - 1条边,所以一个弱连通块答案只可能是n - 1或n
考虑何时答案是n - 1 ? 
如果u -> v,说明u是v的祖先,那看一下是否有环即可
如何判断弱联通呢 ? 使用并查集 nice

## [[APIO2010] 巡逻](https://www.luogu.com.cn/problem/P3629)
如果没有新道路,就是2n - 2,
1.K = 1怎么做 ? 一条道路建起来能少走中间的长度,所以连接直径即可,
2.K = 2 ? 猜结论,删除原直径后新的直径长度,是否一定最优 ? 
好的,结论错误了,查看了题解~~
原来的证明有问题,因为我贡献是在边上的,
而不是在点上的,就算那个点在原直径上,他可能通过其他边获得收益,
所以只要把原直径上的边权赋为-1即可
给出证明 : 假设我因为第一次不选直径而让答案全体更优,
第二次的路径肯定与不选的那段有交,画图发现这样一定不必选直径优

**惨痛的教训告诉要分清贡献究竟在点上还是边上,特别是树上问题时**

## [跳楼机](https://www.luogu.com.cn/problem/P3403)
同余最短路的模板题,
如果某次(ay + by) % x = k,
那么之后的所有k + c * x的高度都是可达的
所以考虑建立x的剩余系,跑同余最短路,
即到达k的最小高度
注意特判1

**同余最短路常常以$ax + by + cz + ...$为标志**

## [Roger卖鸭子](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8728)
观察到$ax + by + cz +..$所以是同余最短路
枚举一下同余系中每个元素的最大不可达数即可

## [gcd之和](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8729)
求$\sum_i^n gcd(n,i)$,但我们比较会的是$gcd = 1$的情况
**考虑更换枚举顺序,$gcd(n,i)$的值只可能是n的因数**
$$\sum_{d|n}d \sum_i^n[gcd(i,n) = d]\\=
\sum_{d|n}d\sum_i^{n/d}[gcd(n/d,i) = 1]\\=
\sum_{d|n}\phi(n/d)$$
然后这题就完结撒花啦!

求$\phi$时用了一个小技巧,$\ge \sqrt n$的质数只有一个,
所以遍历一下$\le \sqrt n$的质数即可

## [序列](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8730)
问有多少序列满足 (s[i + 1] + s[i]) / 2 = a[i]
显然有s[i] <= a[i],s[i + 1] >= a[i]
s[i + 1] = 2a[i] - s[i],所以规定s[1]即可得到整个s
考虑每个s[i]给s[1]的限制,
s[1] = 2a[1] - s[2] = 2a[1] - 2a[2] + s[3]
= 2a[1] - 2a[2] + 2a[3] - s[4]
整理得,s[1] = 2(a[1] - a[2] + a[3] - ..) + s[i + 1] * (i & 1)

## [Xum](https://www.luogu.com.cn/problem/CF1427E)
上课讲的构造题
先考虑只通过加法能够构造出的数,
类似于龟速乘,我们可以构造出x的所有倍数,
1只能通过 n ^ (n + 1)获得,如何构造出这两个数 ?
ax - by = 1,因此要构造一个与x gcd为1的y,显然只能通过异或构造,

给出老师的构造方式,设x二进制长度为k
先通过加法让x左移2^(k - 1),再异或上x,得到的即为 $2^{k - 1} * (x - 1) + x$,与x互质
可以看作通过补0将难做的异或变为减法,运用x是奇数构造出结果

## [[NOI2018] 屠龙勇士](https://www.luogu.com.cn/problem/P4774)
如果能通关,那用哪把剑是一定的,所以解方程,
x*atk_i % p_i = a_i,
这可以先用ex_gcd转换为 x % p_i = a_i的标准形式,
然后跑ex_crt模板

## [Count the Arrays](https://www.luogu.com.cn/problem/CF1312D)
**枚举最大值的位置非常难做,在做组合题时要多试几种枚举方式**
如果确定了前半部分有哪些颜色,那这些颜色的位置都是确定的,
因此考虑枚举有哪些颜色,那个颜色用了2次,剩下的颜色就是左右二选一

## [[HNOI2012] 排队](https://www.luogu.com.cn/problem/P3223)
老师只有2个,所以先考虑不管老师的方案 - 因为老师不合法的方案
$A(n+3,m)*(n+2)! - A(n+2,m)*(n+1)!*2$
注意不能直接插两次板,因为第一次插板时的方案会少统计,因为在第一插板时不合法的方案可能在第二次加入后就合法了

**当分离考虑时要注意当前不合法的在之后是否会合法**

## [「EZEC-2」机器](https://www.luogu.com.cn/problem/P6601)
推式子大题,用$P_n$表示时间为n时在一起的概率,$s$表示为瞬移奇数次的概率
$$s=\sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i}[i \% 2=1] $$
**对于与奇偶有关的式子,一定要想到拆出$(-1)^i$来**
$$\begin{aligned}
s &= \sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i} \frac{1-(-1)^i}{2}\\
&=1/2\sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i} - 1/2\sum_{i = 0}^n{n\choose i}(-p)^i(1 - p)^{n-i}\\
&=1/2 - 1/2{(1 - 2p)}^n
\end{aligned} $$
$$P_n = s^2 + (1 - s)^2 = 1/2 + 1/2(1 - 2p)^{2n} $$
$$ans = {1\over 2nt}\sum_{n=1}^t P_n $$
运用等比数列求和即可,**注意公比为1或0时不能用等比数列!**

## [Sasha and Array](https://www.luogu.com.cn/problem/CF718C)
用线段树维护矩阵,
**因为矩阵的乘法对于加法也具有结合律,**
因此可以用线段树维护乘法和区间和
注意为了获得更好的复杂度,要用矩阵存tag,防止每次下传都快速幂

## [Frets On Fire](https://codeforces.com/problemset/problem/1119/D)
li从几开始无所谓,不妨假设从0开始
考虑先排序,然后假装s[1] = 1
如果r足够大,那就是s[n] + r,问题在于中间有空
中间空的贡献是 - max((空长 - r),0),这可以排序后用二分解决

## [[六省联考 2017] 组合数问题](https://www.luogu.com.cn/problem/P3746)
不会做,看题解
**注意到其要求列数 %k = r 的所有数的和,同时所有的转移方式是相同的,**
**可以考虑放到%k的同余系下来做,f[n][r]表示所有 C_n^m 中 m % k = r 的和**
f[n][r] = f[n - 1][r - 1] + f[n][r],f[n][0] += f[n - 1][k]
因为k非常小,所以可以用矩阵快速幂来做

## [[SDOI2018] 战略游戏](https://www.luogu.com.cn/problem/P4606)
和割点有关的题,先考虑建圆方树,
问题变为圆方树上关键点间有多少圆点
**看到s的总和较小,复杂度与总和有关可以运用建虚树的方式来做**

## [[HNOI/AHOI2018] 排列](https://www.luogu.com.cn/problem/P4437)
$\forall j <= k,a_{p+j} \neq p_k$,
即如果要给p_k赋x,那么之后不能有a_x,即a_x一定在k前
即排列时值 a_x 要放在 x 前面
如果没有限制就是简单的从小到大排序,
而这类有限制的贪心就是经典的并查集 + 堆的套路
即取出后可以将其和父亲看作一组
假设一组内为 a1,a2 另一组为 a3,若a1,a2在前,则
a1 + 2a2 + 3a3 > a3 + 2a1 + 3a2,
即 1/2(a1 + a2) < a3,即按照组内平均值排序

## [Shortest Cycle](https://codeforces.com/problemset/problem/1205/B)
诈骗题!!
a[i]最多61位,而如果3个数都有1位为1,那肯定有环,所以只要考虑n <= 185的情况
不会啦,看题解.这可以用floyd求解,
具体而言,环要求i,j用2条不同的路径连起来,而floyd到k时k不在路径的中间点中,
所以可以在考虑k时枚举与k相邻的点i - k - j - i的路径

**需要获得不经过某些中间的路径时可以找floyd**

## [Pudding Monsters](https://codeforces.com/problemset/problem/526/F)
给一个排列,问有多少个子区间其最大 - 最小 + 1 恰为 区间长度
不会做,看题解!!
问有多少maxn - minn = r - l成立,考虑对于每个r有多少满足
每次移动r时,改变了一下r和部分的maxn和minn,这可以用单调栈获得
即f = maxn - minn + l - r,问多少个 = 0,
因为f肯定大于0,所以维护最小值和最小值个数即可

## [Unique Subsequence](https://atcoder.jp/contests/arc125/tasks/arc125_d)
如果a是一个独特的子序列,那么其右边加入一个在右边只出现了一次的数,其还是独特的
f[i]表示以i结尾的独特的子序列的个数,
$f[i] = \sum_{j \in [las[i],i - 1]} f[j]$,
同时$f[las[i]] = 0$

**启示我们在设计dp状态时不要过于直接开始想复杂,**
**先考虑清楚一个个加入的简单情况是否可行,如果不行其不行的关键是什么**

## [LIS to Original Sequence](https://atcoder.jp/contests/arc125/tasks/arc125_c)
求出长m的字典序最小的序列,使其最长上升子序列恰为a
不会做,听了cyn大佬的讲解!
我们可以画图进行理解,横轴是坐标,竖轴是数的大小,
对于每个a[i]来说,能在后面放更小的就放最小的能放的,
然后把剩下的都递减放到最后一个a[i]

**想不出来时画图感性理解**

## [Prefix XORs](https://atcoder.jp/contests/arc137/tasks/arc137_d)
将前缀异或的贡献打表出来,发现是一个分形的图形,
处理分形可以使用递归,只处理有1的矩形,时间复杂度为$3^{\log n}$
这样依旧会TLE,
有一个奇技淫巧,可以把最后一层的递归手动展开就变快了

**想不出来就打表,看到分形可以递归**

## [Distinct Numbers](https://atcoder.jp/contests/arc137/tasks/arc137_c)
**打表大题,结论题还是得打表~~** 不打表一百万年都看不出来
给出证明:
如果$a[n] \neq a[n - 1] + 1 $,alice可以把其变为$a[n-1]+1$,
如果此时Bob必败,那就这么走,
否则Bob将其变为$z$必胜的化,Alice可以反悔将其变为z

如果$a[n] = a[n - 1] + 1$,此时就变为了比较操作轮数的奇偶了

## [Coprime Pair](https://atcoder.jp/contests/arc137/tasks/arc137_a?lang=en)
诈骗题,直接暴力枚举答案即可
**因为互质的数分布是非常密集的,所以非常的快**

## [志愿者招募](https://www.luogu.com.cn/problem/P3980)
经典的网络流套路题
朴素的想法是将人连向天数,但这样没法处理一个人同时干多天,
可以把所有天都放在一条链上,i - i + 1 是$inf - a[i]$,
然后对每个志愿者s - t为一条s - t + 1的边

**本来容量只能处理最多为多少,**
**但连成链强迫其总流量为inf,**
**然后$inf - a[i]$又强迫其从志愿者哪里获得了$a[i]$的容量**

**当出现至多/至少时可以考虑进行网络流,又有同时给一系列点赋权**

## [最长k可重区间集问题](https://www.luogu.com.cn/problem/P3358)
**至多多少,给一系列点增加值,可以考虑网络流**
**区间覆盖的经典套路,放到一条链上去**
注意建图时的自环问题

## [Sequence Scores](https://atcoder.jp/contests/arc114/tasks/arc114_c)
不会做,听柳巨讲解,
考虑最劣的操作数为n * m^n,考虑最优操作比最劣的少操作了哪些
如果 a[i] = a[j] 且 i - j 中所有数都比a[i]大,那会少操作一次
对于左右为p,间隔为l的方案数为$(n - l - 1) * m^{n - l - 2}(n - p)^l$
又因为我们有所有的序列,所以枚举一下所有的p和间隔即可

**当题目出现类似有所有的序列/排列时,可以尝试利用每种情况都会出现的性质来列出贡献**
**当有条件才能减少贡献时可以尝试反算减少的贡献**

## [Moving Pieces on Line](https://atcoder.jp/contests/arc114/tasks/arc114_d)
又听柳巨讲解
**区间问题想到用差分解决,一个珠子相当于在其起点和终点位置都异或1,**
最终要得到一个t[i]处都为1的差分数组
又因为柱子是不能交叉移动的,否则肯定不优,
所以可以dp,
f[i][j]表示满足前i个点,用完了前j个柱子的最小方案数

**在最小步数类问题中经常与不能交叉移动有关**

## [Permutation Division](https://atcoder.jp/contests/arc114/tasks/arc114_f)
听了茹巨的讲解,
原序列肯定是最优的情况,要动肯定是做一个比原序列字典序更大的东西
如果最长下降子序列比k长,我们就可以使其不动,达到最优,
如果不能使整个序列不动了,我们希望从头开始不动的部分尽可能长,
因为其若是将x换了,肯定换了更大的,劣于换x + 1
要使前x个不变,需要前面的链头单下降,且x + 1后的每个链头都 < 前面最小的链头

现在问题变成了我们要求出这个分界点,使得这个分界点尽可能靠右的同时留下的k更小,
我们可以对于每个i求出最靠右的res,使得res - n中$< a[i]$的数有$k - f[i]$ 个,$f[i]$表示以i结尾的最长下降子序列长度
发现因为要求最大res,所以可以将res视为单调递增的,直接一个单增的指针 + 树状数组即可

## [Non Arithmetic Progression Set](https://atcoder.jp/contests/arc145/tasks/arc145_d)
不会做,看题解,
先不考虑 = M的条件,2y != x + z
对每个数进行3进制拆分,保证每位都是0/1即可
而通过同时对所有数加减,我们可以使其里目标 < n - 1,
给每个数最后一位留空,最后再加

**当我们要构造很多数使得他们满足一些条件时,可以进行进制拆分,使他们每一位都满足这些条件**
**因为条件约束使得我们只会构造很小的情况,这时通过进制拆分,将每一位独立开来,就可以通过很小情况的不同组合来构造大情况了**

## [Too Heavy](https://atcoder.jp/contests/arc111/tasks/arc111_c)
听了柳巨,lay,茹巨的讲解,
考虑所有i向p[i]连边,不难发现一定会形成一堆环,目标是将所有变为自环
任意交换环内两点,环一定变为2个,所以构造任意方案,其一定最优,且ans = n - 环个数
首先如果有一个p[i]不是自己且其已经被重死了,肯定无解
考虑如何构造方案 ? 给出柳巨的方案
我们可以找到环中的大力士(a最大),然后按顺序让环上每个人跟他换即可
无解仅当由物体比大力士还重,这肯定在开始就被判掉了

**排列上换来换去的问题常常和置换环有关**

## [Simple Math 3 ](https://atcoder.jp/contests/arc111/tasks/arc111_e)
听了lay的讲解 !
考虑一个答案的上界 ans <= (d - 1) / (c - b)
前面的有贡献仅当 (a + ci) / d = (a + bi - 1) / d + 1
所以我们就是求两个相减的值,就是类欧模板

## [A < AP](https://atcoder.jp/contests/arc151/tasks/arc151_b)
考虑第i位小于,前面a[j] = a[p[j]],后面随便选,用bcj维护即可

## [01 Game](https://atcoder.jp/contests/arc151/tasks/arc151_c)
听了lay的讲解
考虑每个棋子将其分成了多个互不干扰的小游戏,求这些小游戏的SG值,
记1 .. 0 , 1 .. 1 ,... 0,1 ...的SG值
打表一下发现 1 .. 0 即为 0,1 .. 1为1,..1为长度
**SG若列完 mex,异或 式子没思路时可以考虑打表**

## [Binary Representations and Queries](https://atcoder.jp/contests/arc151/tasks/arc151_d)
听了lay的讲解,
极端情况,n = 0如何做 ? 
每次操做时记录一下0 = x 0' + y 1',1同理,即可
n = 1 如何做 ?
对于相邻两个层数不同的操做,调换他们的顺序对结果没有影响,
所以一层层操做下去即可

**这类操做类题目往往可以往操做的合并,交换顺序等角度上思考**

## [Keep Being Substring](https://atcoder.jp/contests/arc151/tasks/arc151_e)
听了题解的讲解 
如果两者最长公共子串不为空,那先删成最长公共字串再加回去
那就是p + q - len
最长公共字串可以hash + 二分求解
否则先删成一个点,再一点点挪过去,可以用bfs求解

## [Bakery](https://www.luogu.com.cn/problem/AT_arc137_e)
假设每天都可以做 a_i 个面包
从志愿者招募的基础上出发,问题在于如何处理没有雇满的部分
稍作修改即可,即将没雇满也看作一个面包师,费用为d

## [Random IS](https://atcoder.jp/contests/arc108/tasks/arc108_e)
不会做,看题解 ~~~
即使是相同的方案,被打上标记的概率也是不同的,所有考虑对过程进行dp,
枚举第一个标记的点p,此时左右部分的选择互不影响,只与p有关,就被拆位了两个更小问题
因此进行区间dp,f[l,r]表示已经标记了l - 1,r + 1后区间内的标记个数期望
$f[l,r] = (\sum_{l < p < r,a[l - 1] < a[p] < a[r]} f[l,p - 1] + f[p + 1,r] + 1) / k$
其中k为p的个数
注意到这是个偏序问题,所以可以开n个树状数组解决

这题非常深刻,整理一下思路过程
首先我们按照普通的思路考虑方案发现错了,
**问题关键是不同方案的概率也是不同的**,
**因此考虑模拟取数的过程**
在取完第一个数后,我们相当于将问题分为了两个部分,**同时这两部分互不影响**,且只与取得那个数字有关,
由此,我们能够轻易得写出dfs的做法,正者做就是区间dp

**模拟选取过程往往与区间dp有点关系**

## [Paint Tree](https://atcoder.jp/contests/arc108/tasks/arc108_f)
不会做,看题解 !
**将两个点集点组合起来新的直径的端点一定来自两点集的直径的端点**,
所以考虑先求出直径
求出一条直径后直径上两端点若颜色相同则值为直径,考虑颜色不同的情况,
设直径两端点s,t,如果答案为f,说明所有和s距离 > f的都和s异色
如果一个点与s,t距离都 <= f,那么该点颜色随便,我们就得到了答案 <= f 的方案数

## [1 or 2](https://atcoder.jp/contests/arc121/tasks/arc121_d)
如果只能2个取,那么排完序后让最大和最小配对,次大次小配对,一直配下去,这个可以花数轴上用平均值来证明
取1个点可以是视作取a和0,所以枚举一下0的数量即可
时间$O(n^2)$

## [[HEOI2016/TJOI2016] 排序](https://www.luogu.com.cn/problem/P2824)
注意到只询问一个位置上的数字,
所以可以用该位置上的数将所有数分为 <= 它的和 > 它的,
设<= 它的为0,>为1
就变成了给01序列排序,而这用线段树非常好维护
二分一下该位置上的数是多少即可

**通过一个数来将难得序列问题变为简单得0/1问题是常用得思想**

## [Logical Operations on Tree](https://atcoder.jp/contests/arc121/tasks/arc121_f)
考虑哪些情况可以变成1,
我们可以先把所有 & 边都缩掉,变为了几个由 | 连接的连通块,
如果有一个连通块是1,那么最终就可以缩为1.
恰有一个连通块比较难维护,我们算不合法的方案数
f[u][1]表示除了u所在的连通块为1,其他都是0的方案数,
f[u][0]表示u子树所有连通块都是0的方案数

枚举该边是 | 或 &
2 * f[u][0] * f[v][0] + f[u][0] * f[v][1] + f[u][1] * f[v][0] -> f[u][0]
f[u][1] * f[v][1] + f[u][1] * f[v][0] -> f[u][1]

## [Directed Tree](https://atcoder.jp/contests/arc121/tasks/arc121_e)
所有点都合法的方案数 = 至少0个点不合法的方案数 - 至少1个点不合法的方案 + 至少2个点不合法方案 -..
理解 : 将每个点是否合法是做一个条件,就是一个要满足所有条件的容斥

f[u][i]表示子树u中至少有i个点不合法的方案,
1.u没有填到自己的子树中,一个个加入子树
f[u][m] = f[u][k] * f[v][m - k]
2.u被填到了子树中
f[u][m] += f[u][m - 1] * (siz[u] - 1 - (m - 1))

最终f[i] = f[i] * (n - i)!

**将序列全部合法用容斥转换为至少几个不合法是常用的方法**

## [Binomial Coefficient is Fun](https://atcoder.jp/contests/arc110/tasks/arc110_d)
**组合意义天地灭**,~~代数推导保平安~~
听了lay的讲解😊
有m个球,我们先将其分为n + 1组,前n组就是b,最后一组表示丢掉的,
C[b][a]乘起来就是每组选a个球标黑,
插板法,发现可以把隔板也是做黑球,最终求得的方案也是固定的
所以就是c[m + n][n + \sum a_i]

**通过设计一种映射方式,将复杂的方案映射成简单的情景**

~~组合意义天地灭~~,**代数推导保平安**
看了题解的式子推导,
考虑到$b \ge a$难维护,先变成${b + r\choose b}$,$m -= \sum a_i$
求解$\sum \prod_j^n {a_i + r_i\choose a_i}[\sum r_i \le m]$
**组合数学 + 总取数不超过m是个经典的生成函数套路**
先设计一个生成函数第 i 项表示 r = i,然后成起来即可
$$\begin{aligned}
  \prod_j^n(\sum_{i\ge 0} {a_j + i\choose a_j}x^i) & = \prod_j^n\frac{1}{(1 -  x)^{a_j + 1}}\\
  & = \frac{1}{(1 - x)^{n + \sum a_i}}\\
  & = \sum_{i \ge 0} {i + n + \sum a_i - 1\choose n - 1 +\sum a_i} x^i
\end{aligned} $$
$$ans = \sum_{i \in [0,m]} {i + n + \sum a_j - 1\choose n - 1 + \sum a_j} = {m + n + \sum a_j \choose n + \sum a_j} $$

## [Esoswap](https://atcoder.jp/contests/arc110/tasks/arc110_f)
题解做法:
如果i上是0,那么对i操做完还是0,
如果对一个位置连续操做,
其每次操做完变为一个新数,这个新数意味着其会与一个新的位置上的数交换,
意味着不会操做回原来出现过的数,所以最多n次其回变成0,
我们从 n - 1 -> 0 每个位置都操做成0,
n - 2的0来自n - 1,且那次交换他是1,所以n - 1上是1,
n - 3的0来自n - 2,且那次交换他是1,所以n - 2此时是1,n - 1是2,
以此类推

lay的做法:
对位置0上的数操做,其会回到原来的位置,
我们考虑将每个数字移到0上,用0来帮他交换,
但有时会出现没有数字能与0交换的情况,这时我们随机打乱一下即可

操作类题的常见观察 : **对0/1/n等特殊点操作 / 对一个数连续操作 / 按照递增/减顺序操做**