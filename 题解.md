[吃](https://www.luogu.com.cn/problem/P8365)
没有观察到
重要性质 : 所有$a[i] > 1$的中只会有一个是加

[A Simple Task](https://www.luogu.com.cn/problem/CF558E?contestId=172291)
这道题肯定不能不是一般的排序方式,
经过陈龙的提醒,这题有性质 : 字母只有26个,
因此考虑进行桶排,
因为是**区间操作**,且要维护信息,所以想到线段树
这道题也是典型的知道是线段树就很好想

[query](https://vjudge.net/problem/SPOJ-DQUERY)
只管想成桶来维护是难的,
因为不同的数不具备前缀和性质,所以无法直接主席树,
进行一个非常重要的套路转化,
将每个相同的数只统计一次转换为只统计一个区间内相同的数中最靠后的数的贡献
具体实现上,可以离线 + 树状数组
也可以主席树,统计$nex[x] >= r$的个数

[上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145?contestId=173150)
这道题是经典套路,用并查集来维护删除掉的点

[【模板】扫描线](https://www.luogu.com.cn/problem/P5490)
考虑有一条扫描线扫过,
用DS维护该y值的线段长度

在矩阵下边 +1,上边 -1,不为0时该线段做出贡献
这是朴素线段树无法维护的,
因为-1后无法统计哪些子区间停止做出了贡献
但是扫描线有性质 : 每次-1意味着之前给同一个区间+1过,
因而想到将更改留在这个区间不下传
标记永久化,不难发现是正确的

细节:离散化后线段树上每个节点代表了一条线段

[FAR-FarmCraft](https://www.luogu.com.cn/problem/P3574)
贪心好题~~~:
$f[x]$ 为以x为根的子树所需的时间,
而$f[x]$的值会因为走子树的顺序不同而不同,联想到国王游戏
考虑贪心,假设有2颗子树a,b
先走a,后走b :
$f[x] = max(1 + f[a],2*siz[a] + 1 + f[b])$
先走b,后走a :
$f[x] = max(1 + f[b],2*siz[a] + 1 + f[b])$
即如果$max(1 + f[a],2*siz[a] + 1 + f[b]) > max(1 + f[b],2*siz[b] + 1 + f[a])$就先走b

如果要套用国王游戏需要证明有传递性(式子的一边只与一个字母有关)
$max(f[a] - f[b],2*siz[a]) > max(0,2*siz[b] + f[a] - f[b])$
因为$siz[a] > 0$
即为$max(f[a] - f[b],2*siz[a]) > 2*siz[b] + f[a] - f[b]$
$max(0,2*siz[a] + f[b] - f[a]) > 2*siz[b]$
因为$siz[b] > 0$
即为$2*siz[a] - f[a] > 2*siz[b] - f[b]$
具有传递性