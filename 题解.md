## [吃](https://www.luogu.com.cn/problem/P8365)
没有观察到
重要性质 : 所有$a[i] > 1$的中只会有一个是加

## [A Simple Task](https://www.luogu.com.cn/problem/CF558E?contestId=172291)
这道题肯定不能不是一般的排序方式,
经过陈龙的提醒,这题有性质 : 字母只有26个,
因此考虑进行桶排,
因为是**区间操作**,且要维护信息,所以想到线段树
这道题也是典型的知道是线段树就很好想

## [query](https://vjudge.net/problem/SPOJ-DQUERY)
只管想成桶来维护是难的,
因为不同的数不具备前缀和性质,所以无法直接主席树,
进行一个非常重要的套路转化,
将每个相同的数只统计一次转换为只统计一个区间内相同的数中最靠后的数的贡献
具体实现上,可以离线 + 树状数组
也可以主席树,统计$nex[x] >= r$的个数

## [上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145?contestId=173150)
这道题是经典套路,用并查集来维护删除掉的点

## [【模板】扫描线](https://www.luogu.com.cn/problem/P5490)
考虑有一条扫描线扫过,
用DS维护该y值的线段长度

在矩阵下边 +1,上边 -1,不为0时该线段做出贡献
这是朴素线段树无法维护的,
因为-1后无法统计哪些子区间停止做出了贡献
但是扫描线有性质 : 每次-1意味着之前给同一个区间+1过,
因而想到将更改留在这个区间不下传
标记永久化,不难发现是正确的

细节:离散化后线段树上每个节点代表了一条线段

## [FAR-FarmCraft](https://www.luogu.com.cn/problem/P3574)
贪心好题~~~:
$f[x]$ 为以x为根的子树所需的时间,
而$f[x]$的值会因为走子树的顺序不同而不同,联想到国王游戏
考虑贪心,假设有2颗子树a,b
先走a,后走b :
$f[x] = max(1 + f[a],2*siz[a] + 1 + f[b])$
先走b,后走a :
$f[x] = max(1 + f[b],2*siz[a] + 1 + f[b])$
即如果$max(1 + f[a],2*siz[a] + 1 + f[b]) > max(1 + f[b],2*siz[b] + 1 + f[a])$就先走b

**如果要套用国王游戏需要证明有传递性(式子的一边只与一个字母有关)**
**即满足邻项交换**
$max(f[a] - f[b],2*siz[a]) > max(0,2*siz[b] + f[a] - f[b])$
因为$siz[a] > 0$
即为$max(f[a] - f[b],2*siz[a]) > 2*siz[b] + f[a] - f[b]$
$max(0,2*siz[a] + f[b] - f[a]) > 2*siz[b]$
因为$siz[b] > 0$
即为$2*siz[a] - f[a] > 2*siz[b] - f[b]$
具有传递性

## [烹调方案](https://www.luogu.com.cn/problem/P1417)
$a - t * b[i]$ , 时间$c[i]$
$f[i][j]$表示第$i$个物品,已经用了$j$的时间了
$f[i][j] = max(f[i - 1][j - c[i]] + a[i] - (j - c[i]) * b[i],f[i - 1][j])$
但是直接这样做就错啦 因为他的价值和做的顺序也有关系,直接便利只考虑了选或不选
国王游戏 ~ 如果选了x和y
先x后y : $a[x] - c[x]*b[x] + a[y] - (c[x] + c[y])*b[y]$
先y后x : $a[y] - c[y]*b[y] + a[x] - (c[x] + c[y])*b[x]$
$c[x] * b[y] < c[y] * b[x]$就先选x

## [世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)
本来写的map,但是map常数大,超时了,所以用数组 + 二分

**这启示我们桶中前缀和如果数据小可以直接记录数组来获得更小常数与更简洁的代码**

## [ [JRKSJ R5] 1-1 A](https://www.luogu.com.cn/problem/P8847)
对于构造题也是不太熟悉,这道题看了题解 :
记 a 为 1 的个数, b 为 -1 的个数,
1.a <= b + 1 从1开始,交替排列1和-1,最终答案为1
2.a > b + 1 
由于可以选择整个序列,所以不难发现答案最小为 a - b,
考虑能否构造出a - b来,即将1和-1交替排序,然后在最后放慢-1即可

**启示我们在做构造题时可以先找出一个答案的边界,再尝试进行构造**

## [[JRKSJ R5] 1-1 B](https://www.luogu.com.cn/problem/P8848)
P8847的拓展
a == b + 1 根据构造,显然只有1种方案
a < b + 1 即不存在2个连续的1 , C_{b + 1}^{a}
a > b + 1 答案的下界为 a - b
**区间问题想到前缀和,最长字段和就是区间问题,**
不难发现只要保证前缀和在[0,a - b]即可
dp是O(n ^ 2) , 此处挖坑,之后学习新算法补上正解
dp[i][j] 表示前i个,前缀和为j
dp[i][j] = dp[i - 1][j + 1] + dp[i - 1][j - 1]

## [[NOIP2009 普及组] 细胞分裂](https://www.luogu.com.cn/problem/P1069)
求出最小的t,使得 s[i]^t % m1^m2 == 0
这不是因式分解秒了
注意 **用:遍历map等容器时更改p不会更改容器中的值**

## [[NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)
显然可以转换成只有一种颜色
限制转换为 $(x + z) % 2 == 0$ , 
即 x & 1 == z & 1
贡献为 $(x + z) * (a[x] + a[z])$
维护一下前缀和秒啦

## [[HAOI2015] 树上染色](https://www.luogu.com.cn/problem/P3177)
不会做,最后还是看了题解:
是拆贡献的题,一条边的贡献就是其2边同色点个数的乘积
$f[i][j]$表示子树i中用了j个黑点时其内部边的贡献,
一个个加入子树,$f[i][j] = f[to][k] + f[i][j - k] + w * $
(白点个数乘积 + 黑点个数乘积)

**启示我们遇到答案与 类似点对/所有路径 等有关时可以尝试拆贡献到边上**

**注意:树上背包一定要一个个加子树才能保证$n^2$的复杂度**

## [[Opoi 2024] 简谐振动](https://www.luogu.com.cn/problem/P10534)
**先满足大部分的,然后在调整**
假设现在需要满足的序列 s1,s2....
可以是a[i + 1] = s[i] - a[i] , a[0] = 0;
这样除了s[n]都满足啦,接下来调整使s[n]满足,
发现一下更能+-2 , 最终发现只要s的和是偶数就可以啦

注意细节:最后一个数字必须选

## [[NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)
经典背包题,
如果一个数能被前面的数表示,他就没用,
01背包秒啦

## [[Opoi 2024] 二十六点](https://www.luogu.com.cn/problem/P10536)
先考虑pi都是1,
f[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
若pi != 1,
g[x] = f[k] + (c[x] <= c[k]) ,k在x的子树中
且 dep[k] - dep[x] > p[i]

考虑建26颗线段树,f就是每次询问一段dfn的答案
考虑如何求g,发现获得一段深度的线段树是很难的
考虑更改求得g的求解顺序,这不是拿桶维护一下就好了

## [[JRKSJ R2] 01 序列](https://www.luogu.com.cn/problem/P7809)
先考虑操作1
l ~ r取出最长的00011子序列
s0[k] - s0[l - 1] + s1[r] - s1[k]
= s1[r] - s0[l - 1] + s0[k] - s1[k]
操作2
直接判断一下nex就可以了
注意要更新l - 1能取到0

## [[HEOI2012] 采花](https://www.luogu.com.cn/problem/P4113)
这类题十分套路,即**拆贡献**,
先参考HH的项链的思路,即**只让最后一个点做出贡献**
但这样有些不该贡献的点也会贡献,
即如果一个点是最后一个点,且las < l那么他的贡献要减去
具体来说,给las + 1 ~ i的贡献 -1

## [[ABC238E] Range Sums](https://www.luogu.com.cn/problem/AT_abc238_e)
有m种操作,每个操作可以将l~r +-任意数,
求是否最终能将1~n全部变为1,
**区间+-可以转换为差分 ~~**
最终,d[1] = 1,d[n + 1] = -1,

## [Range Deleting](https://www.luogu.com.cn/problem/CF1167E)
因为在值域上操作
考虑做一个桶,即如果 $i < j$ , 那么$t[i]所有数 < t[j]$
$t[i].MAX < t[j].MIN $, 
即删除 $l ~ r$ 后 $t[i].MIN > t[i - 1].MAX$,用双指针维护即可

## [[SHOI2011] 双倍回文](https://www.luogu.com.cn/problem/P4287)
学了回文自动机后看到回文串就要想到他 ~~~ ,
双倍回文就是一个回文串的后缀中有个长度为他一半的回文,
在fail树上跳即可

## [[APIO2014] 回文串](https://www.luogu.com.cn/problem/P3649)
回文自动机因为加点时是从前往后加的,
所以一些简单的dp(如统计出现次数)没必要新建link树,只要从后往前便利即可

## [[JSOI2013] 快乐的 JYY](https://www.luogu.com.cn/problem/P5685)
回文串想到回文自动机~~
两个都建出来后处理一下出现次数,dfs即可

## [[NOI Online #2 提高组] 涂色游戏](https://www.luogu.com.cn/problem/P6476)
不妨令p1 < p2, 
kp1 % p2 = x , x 最小为gcd(p1,p2),
即只要从gcd(p1,p2)开始到p2 - 1有几个p1即可

## [[NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目](https://www.luogu.com.cn/problem/P3951)
这道题2数互质,有贝祖定理有
(gcd(a,b) = 1) | (x * a + y * b)
所以一定有答案

这类问题都比较相似,
**选一个做模数,从同余角度出发会好想一点**
不妨令 a > b
n = xa + yb
n % a = d -> n = ka + d = xa + yb
yb = (k - x)a + d >= 0
即k为x的最大的最小正整数解
k即为b / gcd(a,b) - 1, 即 b - 1,
n = (b - 1)a即可保证y一定>=0,
此时,n = (b - 1)a + 0 * b,
那么此时n - b就是最大的构造出的不符合的数
n = (b - a)a - b = ab - a - b

## [【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)
这道题看似需要高精,其实用到了一个数可以表示成
$\sum_i 10^i *a_i $ ,对每个数分别取模即可

## [Imbalance Value of a Tree](https://www.luogu.com.cn/problem/CF915F)
看到枚举点对,想到拆贡献,
考虑一个点做几次最大,几次最小
也就是求一个点相邻的由比他小的点构成的连通块大小
从小到大加点,并查集求连通块大小

据说把点权拆到边上可以获得更小的常数

## [ [TJOI2017] 可乐](https://www.luogu.com.cn/problem/P3758)
这是一道经典的套路题,即从u -> v经过t条边有几条路径
f[t][u][v]表示经过t条边后从u->v的路径数量
$f[t][u][v] = sum f[t - 1][u][k] * f[1][k][v] , k = 1 - > n$
牛逼的来了,我们发现这个是可以用矩阵乘法来模拟的,
所以矩阵快速幂就行了

**这启示我们看到三重循环就要想一下矩阵快速幂**
**以及图上那个经典的dp方式,每次加一条边/点**

对于这道题,具体来说,只要加入爆炸和不动的方式就行啦
自爆额外弄一个点统计一下答案

## [[BalticOI 2021 Day2] The Xana coup](https://www.luogu.com.cn/problem/P8127)
那么这道题的关键问题在于其会对父亲做出影响,
因此状态中我们设计一维表示父亲来处理后效性即可
f[x][0/1][0/1]表示将除x外所有点变为0后点x的权值,是否操作了x
考虑如何转移,
**此时又有一个树上dp经典套路,即考虑了前i个子树时的答案**
这样能够避免考虑操作的奇偶次数,
**这也是一个经典思想,即一个个加入替代一下次考虑全部**

## [[USACO23DEC] Flight Routes G](https://www.luogu.com.cn/problem/P9980)
如果是2个相邻的点,只要看是否为1即可,
然后考虑相邻3个点,我们看2个点算出的结果是否与其相同即可
一直往上枚举len即可

## [妖梦斩木棒](https://www.luogu.com.cn/problem/P3797)
忽略所有X,如果')'前面是'(',那么会做出一次贡献
因为要忽略所有X,所以考虑那个经典的删点套路,并查集~~
具体而言,离线后倒序操作 
爽,题看错了~~~~~~~~~ 还可以修改为X
接下来,我要珂了,bushi
**其实根本不用这么麻烦,我们删点其实用set就可以了,**
**之前用并查集只是因为常数小**

但这题数据过水,暴力比正解快~~~
这道题正解其实是线段树,以后可以补一下

## [由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)
问l ~ r是否可重排为连续的一段,单点修改
如果没有修改显然可以莽可持久化线段树,

转换为max - min = r - l + 1,且l ~ r中没有重复的数,
max和min可以用线段树维护,
**l ~ r没有重复的数可以转换为所有nex > r,即MIN(nwx) > r**
所以三颗线段树秒啦 

这道题题解中还有一种nb的做法，
如果我们知道了值域,就知道了每个数应该是多少,
**而要匹配是否数集全部相同,可以用hash + 异或来做**
即给每个数分配一个hash值,然后求出值域后比较前缀hash异或值是否相同

## [红色的幻想乡](https://www.luogu.com.cn/problem/P3801)
1.对(x,1~m) ^= 1,(1~n,y) ^= 1
2.求矩形中值为1的个数

(x,y)的值为对行x操作次数(f[i])^y操作次数(g[i]),
f[x] = 1 ? g[l ~ r] = 0的个数 : g[l ~ r] = 1的个数
所以2颗树状数组即可

## [双人游戏](https://www.luogu.com.cn/problem/P10608)
看了题解 ~~~:
R希望段数多,M希望段数少,求最后的段数
若s[i] != s[i - 1] & s[i] ,++cnt

对于一个已经填好颜色的块来说,将序列分成了2段,左右互补影响
所以我们考虑B_???? 怎么填,
对于R来说,填W是肯定不劣于填B,
如果因为填W而导致后面减少了贡献,其贡献最多减少1,
因为贡献减少1后就变为了与填B相同的情况,而W已经做出了一次贡献
同理,对M来说,填B不会劣于填W

如果没有已经填好的块,让第一个任意填即可

**这其实是一类套路题,即当贡献为1时,**
**我们可以构造只关注眼前的贪心,然后证明该贪心是不劣的,因为之后最多少1贡献**

## [Bear and Bowling 4](https://www.luogu.com.cn/problem/CF660F)
求最大的 sum i * a[i] 的连续子序列
要求sum i * a[i],
定义sum1为i * a[i]前缀和,sum2为a前缀和
sum[l ~ r] = sum1[r] - sum1[l - 1] - (sum2[r] - sum2[l - 1]) * (l - 1)

f[i] = max {s[j - i]}
= s1[i] - s1[j - 1] - (s2[i] - s2[j - 1]) * (j - 1)
= s1[i] + ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
f[i] - s1[i] = ( s2[j - 1] * (j - 1) - s1[j - 1]) - s2[i] * (j - 1)
        b    =       y                            -   k   *     x
k不一定单调递增,所以二分
**在一个先增后减的函数中二分最高点,可以看相邻点斜率**

## [[NOI2019] 回家路线](https://www.luogu.com.cn/problem/P5468)
将每班车视为一个点,如果y[u] == x[v],且q[u] <= p[v]
那么u向v连边 ? 最多有n^2条边 寄啦
所以不能简单最短路,还要考虑边权的规律
但是最短路的思路可以借鉴,用f[i]表示第i个班次的最小烦恼值,
显然f是按照p的顺序来更新的,且只与x的位置的点有关

f[i] = max{f[j] + w(j,i)} , j.q <= i.p , j.y = i.x
f[i] = f[j] + A * (i.p - j.q)^2 + B * (i.p - j.q) + C
f[i] - A * i.p^2 - B * i.p - C = A * j.q^2 - B * j.q + f[j] - 2 * A * j.q * i.p
        b                  =             y              -      x       * k
那么就是一个斜率优化,其中x单增,可以用单调栈搞

**这道题启示我们当要选边走时可以把边作为图上的点做最短路，**
**即图上跑那条边也可以看作一种决策**
**排序前后要确定是否将原有的编号打乱了~~~!!!!**

## [[NOI2005] 瑰丽华尔兹](https://www.luogu.com.cn/problem/P2254)
要让走的路程最长,即要让停止次数最少,
在一个区间内在哪里暂停都是相同情况,爆搜200^200 ~~
f[k][i][j]表示完成时到达i,j的最少暂停次数
然后暴力模拟,发现n^4,显然过不去,但数据比较水过了😒

**因为遍历时单向遍历,**
**且该题贡献时是全体加1,不会改变大小关系,所以可以单调队列**

## [Array Collapse](https://www.luogu.com.cn/problem/CF1913D)
看了题解
每次操作选择一个区间将除最小值外的值删去,
**因为与区间最小最大及其位置有关,所以考虑笛卡尔树**
f[x]为x子树中的方案数
f[x] = f[l] * f[r] + 一个东西
这个东西来自跨x的区间的删除方案
**如果在x中合并统计是很难的,所以在子树中统计这个东西的贡献**
注意取模时不能用max(..,1)来特判为0的情况,因为可能是个大数刚好模成0

## [[SCOI2005] 骑士精神](https://www.luogu.com.cn/problem//P2324)
继续看题解~~
每次交换最多会让一个棋子到达其符合的位置
所以就是忽略空格的与目标棋盘的不同数为估值函数

## [Black Hills golden jewels](https://codeforces.com/problemset/gymProblem/101064/D)
求序列中选2个第K大.
因为K十分大,考虑二分,然后就是双指针板子啦

## [特殊价值](https://www.xinyoudui.com/ac/contest/747001E3A00040A02251206/problem/8508)
s[r] - s[l - 1] - sx[r] ^ sx[l - 1]
考虑开始全部选完了,要减小一个数意味着其能使异或值也变小
且异或减小的值大于总和减小的值,但几个数异或起来 <= 他们的和
即从左右选尽可能多的数,使他们的价值不变

## [「CROI · R2」在相思树下 I](https://www.luogu.com.cn/problem/P10765)
考虑记录每次删完后留下的第一个数,不管哪个操作删完后中间的间隔都相同
秒了~!!!!

## [ランプ (Lamps)](https://www.luogu.com.cn/problem/AT_joisc2019_h)
看了题解,听了lay
最小操作数我们在于要让操作尽可能让更多的点满足条件
**即每次新加入一个点有多种方式满足条件,**
**看其是否能与前一个点的操作合并**

## [[NOI2010] 航空管制](https://www.luogu.com.cn/problem/P1954)
**这与菜肴制作是同一类题,即要将某个点尽可能早的遍历到**
**正着做很难,因为不知到某个点在哪个路径上,但反图上只要不选他即可**
**体现了正难则反的思想 ~~~~~**
对于这道题具体来说,除了入度为0还要满足其可以起飞
难点在于随着时间的进行一些之前入度以为0但不可以起飞的可以飞了,
观察到时间单调递增,且值域为n,所以可以用桶来维护

## [[国家集训队] 等差子序列](https://www.luogu.com.cn/problem/P2757)
等差数列只要三个就够了,排列考虑用桶来维护
考虑桶上如何做,即中间点左右两边桶上相同位置一个在左边一个在右边
即其所有都在左边就不满足,
所以从左往右扫描,把在左边标记为1,如果中间为回文串就不满足,这可以用hash判断
**即经典转换,当移动一个个时,将在左右的大小关系改为0/1标记**

## [Tourists](https://www.luogu.com.cn/problem/CF487E)
点双后方点的权值是所连圆的最小值,圆点就是圆点的权值
然后就卡住啦,被NEW_HOPE提醒后想出来了,圆方树也是树
**即我们查询一条链的时候,经过方节点时大多都经过了其父亲,只有一个没经过父节点**
所以方节点只需要记录其子节点的值就可以了,具体而言,
更新一个圆节点时只要让其更新其父节点的值即可

调试经验:用namespace分开不同的区块,
线段树每个函数都记得考虑up和down,
写树剖时考虑求数组的顺序与用当前点还是其链顶

## [[ZJOI2007] 最大半连通子图](https://www.luogu.com.cn/problem/P2272)
开始一眼没看出来是tarjan,
强连通图一定满足条件,所以先把强连通的点都缩掉,
然后就变成一张DAG,发现若连通子图只能是DAG上一条链
**计数问题要记得判重边**

## [Divan and Kostomuksha](https://codeforces.com/problemset/problem/1614/D1)
上课讲的题,
首先是贪心,即我们尽可能不让gcd下降,下降后答案一定劣于不下降
因为选择下降会使原来不下降的数贡献减少,但并不会增加其他数的贡献
考虑不得不下降时我们怎么选,下降到数x的贡献为x * 是x的倍数但不是当前数的倍数的个数
因为是当前数的倍数的数都在维持gcd时被用掉了
定义f[x]为gcd为x时不算x,后面的gcd的贡献

**这道题难点在于贪心,gcd下降的很快且不会上升的应用,**
**以及dfs过程中遍历因数可以一个个质因子除下去**

## [GCD](https://www.luogu.com.cn/problem/P2568)
要求$gcd = p$,对于此类题,一般的做法是将a,b同除p,
然后求$gcd(a,b) = 1$的个数,运用欧拉函数即可

## [Interval GCD](https://www.luogu.com.cn/problem/P10463)
这道题开始没有看出来,老师讲了才懂
**区间加是无法维护gcd的,我们只能维护单点修改的gcd,因此考虑差分,**
**差分后就是gcd本质的应用,即gcd(a,b) = gcd(b,a - kb)**
原来gcd对负数的也适用

## [完全平方数](https://www.xinyoudui.com/ac/contest/7470023980004390220CDC6/problem/8341)
要凑2是很难得,但要找到1比较简单
把所有数都乘起来,然后再把多余的除掉

## [消失之物](https://www.luogu.com.cn/problem/P4141)
dp回溯的经典应用
$f[x] = g[x] + g[x - w[i]]\\g[x] = f[x] - g[x - w[i]] $
回溯$g[x]$需要$g[x - w[i]] $,所以从前往后回溯

## [硬币购物](https://www.luogu.com.cn/problem/P1450)
之前做的容斥题,但一直不太懂,现在补上思路
我们要同时满足四种条件,因此是第二类容斥
即要做其对立条件的容斥.
对于硬币a数量 $\leq d_a$的对立条件就是$\geq d_a + 1$,
因此枚举条件组合时如果要求条件1的对立条件必须成立
我们我们可以钦定已经选了$d_a + 1$个硬币1,
而其他条件是不用管的,
**因为容斥时我们是通过条件找元素,而不是通过元素找条件**

## [[HAOI2011] Problem b](https://www.luogu.com.cn/problem/P2522)
**对于在数域上求区间方案数时,常见的方法是运用前缀和改为从好处理的从1开始**
**打开思路,对于此题来说就是二维前缀和**

## [猫尾酒馆](https://www.xinyoudui.com/ac/contest/74700232800040A022526E6/problem/7256)
订单按照品质排序,$f[i][j]$表示处理到第i个订单,剩下$j$瓶酒没有用时最多赚的钱
关键在于如何想到这个dp
**按照品质排序是显然的,这样通过调整dp顺序即可使得满足品质的约束**
**当酒买入后其对于答案有意义的只剩下了数量,所以dp状态中记录当前就的数量即可**

## [WTP的通缉](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4365)
难爆了,不会做,听老师讲
**树上距离最长应该想到直径**
这道题使用线段树来维护点集的直径,即点集直径的合并
**两点集的最长距离即枚举直径端点**

## [蹦蹦炸弹](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4640)
难爆了,不会做,听老师讲
倍增 + 并查集 类似 萌萌哒
显然最小生成树,关键在于如何维护并查集,
**观察到操作是很有规律的,因此可以考虑建立树形结构下传操作**
具体而言,第k层并查集如果连接了x ~ y,
代表了$x - x + 2^k$与$y - y + 2^k$依次连边,逐层下传连边
最多连$nlog(n)$次边
```cpp
int merge(int x,int y,int k) {
    int a(t[k].find(x)),b(t[k].find(y));
    if(a == b) return 0;
    t[k].fa[a] = b;
    if(!k) return 1;
    return merge(x,y,k - 1) + \
    merge(x + (1 << (k - 1)),y + (1 << (k - 1)),k - 1);
}
```
类似于st表的结构,与线段树的思路
**启示我们操作十分有规律,可以拆分成2半分别做时,可以构造树形结构倍增,上层对下一层只有2个节点,便于在层间传递信息**
**并不一定局限于打tag,每个点只会走一次也能将复杂度降低**

## [第一题](https://www.xinyoudui.com/ac/contest/774001AF600040A024C5E86/problem/4359)
这道题前面都在找规律,难的是最后对于hashsum的统计,
其用到了原串本身也是一个公共前后缀,因而可以dp求解

## [Master of Both](https://codeforces.com/gym/104090/problem/K)
上课讲的题,一眼不会做,加深了对字典树的理解
n,q都非常大,难以每次询问都重做一遍
**对于此类更改字符顺序的题,经典套路就是预处理出$f[i][j]$表示字符i在字符j前的贡献然后每次询问统计**
具体而言,在字典树上插入时统计即可

## [聚会](https://www.xinyoudui.com/ac/contest/74700232900040A02252416/problem/7301)
字典树合并 + tag 肯定可以完成一次
如何换根dp捏 ? 拆位异或,统计每位答案,那其实也不用字典树

## [Collapsing Strings](https://www.luogu.com.cn/problem/CF1902E)
上课讲的,一眼不会做
首先分析题目,转换成能看懂的东西,
末尾和开头一样是难以描述的,可以看成去除a和b的反串的lcp
|C(a,b)| 为 |a| + |b| - 2 * |lcp(a,b)| 
求lcp在字典树中易维护

## [Xor-Subsequence](https://www.luogu.com.cn/problem/CF1720D1)
上课讲的题,不讲我一百年都想不到~~~
在a中取出一些下标b,使得相邻2个下标有 a[b[i]] ^ b[i + 1] < a[b[i + 1]] ^ b[i]
我们希望让i在一边,i + 1在另一边,但异或后又不能维持 < 不边,
所以我们希望是 = ,考虑 < 的本质是二进制上从左往右某位左边是0而右边是1
即有一位p,p的前面b[i] ^ a[b[i]]全部相等,
第p位时 b[i - 1]_p != a[b[i]]_p , b[i]_p = a[b[i - 1]]_p
可以在字典树上状态转移更新

## [LuoTianyi and the Function](https://www.luogu.com.cn/problem/CF1824D)
经典套路,用容斥可以将i,j转换为从1开始
g(i,j)为最大的x使得a[i] ~ a[j]的数集与 a[x] ~ a[j]数集相同
如此复杂的转移在线维护不现实,考虑离线下来扫描线
对于固定的数集和j,x的取值是固定的,而数集大小我们很会求,拆贡献即可
考虑固定j后,我们可以用数集的个数来获得x的大小,
用f[j][k]表示当右端点为j,数集大小为k时x的大小,
即每个有贡献的位置到上个有贡献的位置其值是该位置的下标
现在用一个线段树就能轻易的统计 sum i = 1 - > l g(i,j)的大小啦,
然后统计j的和应该怎么办呢? 我们可以每次让线段树加一次自己 ?
到这里这道题就做完啦,但我不会区间历史和线段树,寄啦,看题解,学知识

## [「CQOI2018」解锁屏幕](https://www.luogu.com.cn/problem/P4460)
经典状压,排列顺序记录选了哪些数和最后一个数是什么
**关键在于合理的预处理帮助转移,这题可以预处理出点对i,j经过哪些点**

## [ [省选联考 2020 A/B 卷] 信号传递](https://www.luogu.com.cn/problem/P6622)
经典排列状压,记录选了哪些点
如何预处理才能快速转移 ?
如果a[i + 1]在a[i]左边,那么会贡献 $k * (p[a[i + 1]] + p[a[i]])$
如果a[i + 1]在a[i]右边,那么会贡献 $p[a[i + 1]] - p[a[i]]$
肯定要预处理i传给j信号几次,
**因为我们希望只记录选了哪些点就够了,所以考虑把贡献拆到点上**
即如果加入点i时j在i左边,贡献 += $w[i][j] * k * p + w[j][i] * p$
如果加入i时j在i右边,贡献 += $-w[i][j] * p + w[j][i] * k * p$
这样的转移时O(m^2)的,还是会T
考虑预处理,$cost(s,i)$表示点集s状态下加入i的代价,此处可以提前p减少码量
**具体而言,此处用了一个经典的套路,即cost(s,i)从s少一个点转移过来,可以用lowbit做**
**但这样又爆空间了,此时又用一个经典的套路,我们可以把他拆成2半,转移时再合并起来,注意拆分后的实际意义,$cost1[s][i]$是右半点集的贡献,而非$0...0 + s$的贡献**
相当于用时间换空间,时间 * 2,空间开根

## [[九省联考 2018] 一双木棋 chess](https://www.luogu.com.cn/problem/P4363)
轮廓线dp,记录当前轮廓线的信息,
从左下到右上的轮廓线,1表示该位置向上,0表示向右
合法状态少,用dfs写
当前位置为{n - ct(1),ct(0)},每次能把状态中10翻转为01

## [Petya and Spiders](https://www.luogu.com.cn/problem/CF111C)
蜘蛛的移动有特点,即其只能向周围4个点动一下
所以一个0周围4个点一定有1
用1表示空格,直接2 ^ 3m次

## [[NOIP2017 提高组] 宝藏](https://www.luogu.com.cn/problem/P3959)
最小生成树,边权为 w * 深度
**先设计状态涵盖所有情况**
f(S,T,d) 表示一棵树点集为S,叶子节点为T,深度为d
$+ w(i,j) * (d + 1) -> f(S + i,i,d + 1) , j \in T$
$+ w(i,j) * d -> f(S + i,T + i,d) , j not \in T$
这样就涵盖了所有的情况,
虽然连到非叶子节点后其深度不一定为d,转移非法,
**但这样一定不优,因而对答案没有影响,进一步套用该思想,叶子也不用记录**
快速转移,预处理一下g(s,i)表示i向集合s的最短连边即可

## [给树染色](https://cdn.acwing.com/problem/content/description/117/)
[link2](https://www.xinyoudui.com/ac/contest/747001E3800040A02252156/problem/8625)
**依赖类贪心模板题**
染色代价为 前面已染色的点 * 代价
我们要确定染色顺序
显然,如果树只有2层,那我肯定会先染权值最大的点
但可能权值小的点后面跟了一个大的点,先染权值小的点反而更优,那怎么办?
转换思路,从整颗树上考虑,朴素想法先染权值最大的点,
但权值最大的点不一定在第一个,
**可我们不难发现其父亲节点染完后一定会直接染他,所以可以将其和父亲节点合并为一个点**
考虑合并后的权值,用邻项交换来分析,不难发现就是其平均值
具体实现,用并查集进行节点合并,用堆找最大平均值

## [[AGC023F] 01 on Tree](https://www.luogu.com.cn/problem/AT_agc023_f)
贪心,有0肯定选0,但有时候0要先选1才能选,
仍然那个经典套路,把其和父节点合并,
不难发现块按照ct0 / ct1从大到小排序

## [[IOI2019] 排列鞋子](https://www.luogu.com.cn/problem/P5749)
考虑同种鞋子应该怎么放,
手模发现每个鞋子一定与其后面第一个同种鞋子配对
知道配对方案后如何求交换次数,此时用到一个小技巧,
**用原编号代表鞋子,每次交换会使最终情况中逆序对个数 +1,**
**所以最终情况的逆序对个数就是交换次数,**
逆序对个数邻项交换可贪心,
具体而言,设两数<a1,b1>,<a2,b2>,
若min(a1,b1) < min(a2,b2),
那么1在前面逆序对最多2个,2在前面逆序对至少两个

## [[CQOI2011] 分金币](https://www.luogu.com.cn/problem/P5817)
先考虑在链上的简化情况,每次考虑当前第一个不满足的,然后向后要/送金币即可
手模发现,最终的代价就是值 - avg后前缀和的绝对值的和

在环上怎么做 ? 考虑规定一个方向,正数表示给金币,负数表示要金币
$X_i$表示i向右传递的金币数,$a_i - x_i + x_{i - 1} = avg$,
$x_1 = a_1 + x_n - avg,x_2 = a_1 + a_2 + x_n - 2*avg,x_3= ...$
$x_i = x_n - i*avg + \sum^i_j a_j $
$ans = \sum_i^n |x_i|$
发现和链上类似,只是多了一个x_n项,而x_n可以任选,
就相当于给一堆数中,自己设定一个数x,是x到其他数的距离和最小
可以考虑每次增加一个数贪心,发现就是中位数

**启示我们在面对这类算术计数题,发现无法感性理解时,要进行数学建模转换成数学语言才能进行下一步推导**

## [细胞分裂](https://www.xinyoudui.com/ac/contest/74700233200040A02252EC6/problem/8452)
最后一个细胞一定不砍,且是原序列的最大值,
倒二个细胞最大值<=最后一个,且最小值要尽可能大
所以尽可能平分即可

## [Mathematical Problem](https://www.luogu.com.cn/problem/CF1916D)
构造题,在数的后面加2个零其仍是完全平方数,
在$169$中加零变为$10609,1006009$等其仍是完成平方数

## [Evaluate It and Back Again](https://www.luogu.com.cn/problem/CF1912E)
课上讲的题
如果表达式A只由个位数相加乘组成,其正反答案是一样的,
如果B = 0 - A,那么B反读为-B
考虑将p和q拆成 a + b 和 a - b , 构造即为 A + B - 0
但有时候并不能这样拆分,此时可以拆分为 a + b + 21 和 a - b + 12
构造即为A + B - 0 + 21
如果a是负数,0 - A - 0
其中0要对A/B中每一项都加

## [[COCI2018-2019#1] Teoretičar](https://www.luogu.com.cn/problem/P7307)
课上讲的题,
首先先找到答案的下界,C > 度数最多点的度数,
所以考虑构造一个<= 2 ^ log(度数最多点度数) 的方案,
因此考虑分治,每次将边集分成两半染色,然后合并,
如果每个点的边都只有一条,那就是都染成1,
合并边集就是将另一个边集的颜色全体加上一个数
问题在于如何分边集才能使一个端点的边被均分到2个边集中,
如果存在一条回路,那么给dfs时向右染1,向左染0即可

但原图上不一定存在回路. 考虑欧拉回路的存在条件是每个点度数为偶数,
思考二分图的度数特点,左右度数和是相同的,
为了保持度数都是偶数,我们可以两边各建一个虚点,向对面的奇节点连边
最终如果虚点使奇数,相互连边即可

**启示我们二分图上建虚点的技巧,将点上的边分为两半可以用回路**
**启示我们构造时运用分治**

## [[POI2013] MOR-Tales of seafaring](https://www.luogu.com.cn/problem/P3556)
d不一定是简单路径,我们可以在2个点上来回走即可,所以只要奇偶相等即可,
具体而言,记录一个点到另一个点路径长为奇/偶数的最短路,可以把一个点拆为2个点
注意特判孤立点的情况

## [百度地图的实时路况](https://www.xinyoudui.com/ac/contest/74700231C00040A022913F6/problem/8592)
便于添加但难以删除,求剩余每一个点不加,加入操作可换顺序
经典分治套路,向一边递归时加入另一边贡献

## [[NOIP2017 提高组] 逛公园](https://www.luogu.com.cn/problem/P3953)
f[u][k] 表示到u,比最短路长k的路径方案数
$f[v][k] += f[u][j] ,if dis[v] + k = dis[u] + w + j$
$j = dis[u] + k - dis[pre] - w$
如何进行转移 ? 注意到转移顺序非常复杂,
**对于转移顺序难的dp,即使是图上,也不要忘记了用dfs记忆化搜索!**
无解相当于一个点需要通过自己的状态转移
记录一下是否在栈中即可

如果不使用dfs的奇技淫巧,我们应该如何做呢? 
**对于图上dp顺序的依赖问题,可以考虑建立分层图,**
**具体而言,把每个点复制k遍,每层上的点代表了一个k**
而判无解就是在同层判0环,这要用tarjan,
具体来说,可以值考虑边权为0的边跑缩点,看有没有点个数 >0

## [K-th Path](https://www.luogu.com.cn/problem/CF1196F)
诈骗题!! 
**k这么小,首先先考虑一个答案的下界,**
k <= 400,所以答案不会大于长度第400大的边,
所以取前400条边做floyd即可

## [Shortest Path](https://www.luogu.com.cn/problem/CF59E)
额外记录一维表示从那个点过来,正常转移即可

## [Minimum spanning tree for each edge](https://www.luogu.com.cn/problem/CF609E)
对于最小生成树性质的利用,
考虑先建出最小生成树,然后加入一条边,
将原最小生成树u -> v路径上最大的边换掉,
因为MST的u -> v路径上最大的边就是u -> v所有路径最大边的最小值,
所以其值是唯一的,任意建立一个MST即可

## [「JOISC 2015 Day 4」Inheritance](https://loj.ac/p/3004)
考虑一条条加边,如果第一个人加不上去,就看第二个人,
一个往后看,所以建k个并查集,因为图越来越不联通,所以可以二分

## [Counting Graphs](https://www.luogu.com.cn/problem/CF1857G)
树上加入哪些边不会改变或增加最小生成树 ?
考虑枚举点对u,v,在其中加入一条边权大于u->v最大值的边即可

**发现复杂度爆掉了,难以枚举时要拆贡献,**
**将贡献从点对拆到最大值的边上**
枚举以某条边为最大值的点对有多少个
考虑从大到小删边,每次删边后分成的两个连通块的大小乘积就是点对个数,
那从小到大加边是一样的

## [[NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)
要获得边权$\geq$一定值的连通块,
经典套路,用最大生成kruskal重构树

## [Xor-MST](https://www.luogu.com.cn/problem/CF888G)
考虑kruskal,如何找到当前边权最小的
异或想到用tril树,考虑tril树上如何统计答案,
tril树上lca越深的节点肯定先被连起来,
画图发现tril树其实代表了连接的分治树,dfs遍历节点u,
节点u2子树内已经联通,然后选一条边权最短的边连接两子树,
可以遍历2子树即可,每个点最多被遍历log次,复杂度nlogn

关键在于将画图的方式转换为编程可实现的语言

## [Flip Digits 2](https://atcoder.jp/contests/typical90/tasks/typical90_aw)
区间翻转可以看作区间异或1,随意可以视为差分,
现在每个操作可以看作在2个点上^=1,
经典建图套路,将被操作的两点连起来,
如果最终得到图联通,我们就可以任意改这n个节点,
而第n + 1个由其他点权值得到

## [Power Tree](https://www.luogu.com.cn/problem/CF1120D)
区间加可以用差分变为改变两个点
仍然是那个经典套路,连接两个可以操作的边,
如果最终联通成树即表示其可改变所有点,
**可以从树上的叶子节点开始修改为指定的值,**
最终根节点的值由其他值决定

**常常以花代价购买操作为标志**

## [[NOIP2020] 移球游戏](https://www.luogu.com.cn/problem/P7115)
考虑n = 2的情况,
**不妨观察样例二就能看出怎么移动的,**
假设2号柱中有p个1球,先将1号柱上p个球移动到3号柱,
然后将2号中的p个1移到1号,m - p个2移到3号柱,此时2号空了,
之后将3号全部移动到2号,这样2就在最下面了,
再将1号的p个1移到3号,2号上方乱的移到1号,
最后将1号上方乱的,1移到3号,2移到2号,最后将3全部移到1号
至多用5m次操作,空行没有改变,1号全是1,2号全是2

我们发现n = 2的情况已经很复杂了,所以肯定不是想出n更大的通解,
**考虑将n更大的情况转换为n = 2,经典构造分治**
钦定一个mid,<= mid的标为0,> mid的标为1,
但0/1数量不一定相同,
我们可以将n = 2的情况看作把较多的数提取到一边
因此分治时两两遍历即可

**操作类题注意把操作封装为函数来写**

## [[NOI2019] 弹跳](https://www.luogu.com.cn/problem/P5471)
考虑h = 1,就是线段树优化建图,
所以二维就是线段树套线段树优化建图
但这样空间会爆炸,
线段树空间不够,可以改成平衡树,或直接使用KD树

优化建图的思路是可以套用的,
但把图上的边连完空间也就爆了,所以得利用数据结构来获得最短的距离,
**打开思路,dj中堆只是一个获得最短距离的工具,可以换成其他数据结构**
具体而言,就是每次更新一个方格内的最短距离,获得全局最小距离
这可以用KD-tree维护.

看了题解中有更妙的方法,
dj在边权为0时有一些特性,
**即如果一个u -> v为0,那么当遍历u时,v一定入队,**
所以给每个弹跳建虚点,用数据结构维护该虚点能够到达的点,然后直接把这些点删除即可

**因此在优化建图时常常将虚点到实点的边权赋为0,这样可以免去麻烦的取最小值,而改为简单的删除**

## [[NOI2010] 超级钢琴](https://www.luogu.com.cn/problem/P2048)
选出k个最大的l ~ r,价值为s[r] - s[l],L <= r - l <= R,l,r \in [0,n]
选择这么多,但要选出的数少,考虑堆拓展,
将每个r看作一个序列,每次从堆里选出一个数,加入所在序列的下一个数
具体而言,每个r选出一个数后其所要求的最短区间就被拆分成了两半,分别入堆即可
然后就是简单的RMQ了

## [Berland and the Shortest Paths](https://www.luogu.com.cn/problem/CF1005F)
选出n - 1条道路,使得dis[2] + dis[3] + dis[4] + ..最小
**考虑让贪心让每个dis最小,发现并不让其他dis更大,**
所以输出最短路树即可
考虑如何输出方案,每个点建桶即可

## [树与排列](https://www.xinyoudui.com/ac/contest/74700233000040A02252C06/problem/8718)
手模排列,将当前a_i当作下一个下标
发现问题等价于树上遍历所有点再回去的最长距离和
考虑在链上应该怎么做 ? 
手模发现来回跳一定最优 , 树上怎么做 ?
一直跳能跳的点的直径(边都为1)即可,这样不好统计贡献
将贡献拆掉边上,就是最小子树的大小*2,
证明 : 一个边最多被经过其最小子树大小 * 2次,
而刚刚构造的方法刚好达到了上界

## [[NOIP2012 提高组] 疫情控制](https://www.luogu.com.cn/problem/P1084)
显然,军队只可能在1号节点向下移动一次,其他时候都只会向上走,
如果1号节点叶子数多余m则无解,否则有解
直接制定耗时最短的方案非常难
**要最小化某一变量,且有单调性,考虑2分时间t,**
贪心一直向上走即可,
关键在于贪心如何做,先让所有点尽可能走,走到1的子树下方,
然后处理这些可以支援其他点的军队
错误的想法是子树中至少留一个点,
因为可能留下的这个点剩余距离还很长,
不如另一个子树中剩余距离短的点来代替他,让他支援另一个距离远的子树,
然后就不会做了,看题解,有性质,
**如果最后一个点无法走到1再走回自己,**
**那他不会支援其他子树,因为来代替他的军队剩余距离肯定大于他**

## [航班请求](https://www.xinyoudui.com/ac/contest/74700233A00040A02253206/problem/8334)
考虑答案上界为n,即将所有点连成环,互相两两可达,
考虑在环上操作,
要满足弱连通至少要n - 1条边,所以一个弱连通块答案只可能是n - 1或n
考虑何时答案是n - 1 ? 
如果u -> v,说明u是v的祖先,那看一下是否有环即可
如何判断弱联通呢 ? 使用并查集 nice

## [[APIO2010] 巡逻](https://www.luogu.com.cn/problem/P3629)
如果没有新道路,就是2n - 2,
1.K = 1怎么做 ? 一条道路建起来能少走中间的长度,所以连接直径即可,
2.K = 2 ? 猜结论,删除原直径后新的直径长度,是否一定最优 ? 
好的,结论错误了,查看了题解~~
原来的证明有问题,因为我贡献是在边上的,
而不是在点上的,就算那个点在原直径上,他可能通过其他边获得收益,
所以只要把原直径上的边权赋为-1即可
给出证明 : 假设我因为第一次不选直径而让答案全体更优,
第二次的路径肯定与不选的那段有交,画图发现这样一定不必选直径优

**惨痛的教训告诉要分清贡献究竟在点上还是边上,特别是树上问题时**

## [跳楼机](https://www.luogu.com.cn/problem/P3403)
同余最短路的模板题,
如果某次(ay + by) % x = k,
那么之后的所有k + c * x的高度都是可达的
所以考虑建立x的剩余系,跑同余最短路,
即到达k的最小高度
注意特判1

**同余最短路常常以$ax + by + cz + ...$为标志**

## [Roger卖鸭子](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8728)
观察到$ax + by + cz +..$所以是同余最短路
枚举一下同余系中每个元素的最大不可达数即可

## [gcd之和](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8729)
求$\sum_i^n gcd(n,i)$,但我们比较会的是$gcd = 1$的情况
**考虑更换枚举顺序,$gcd(n,i)$的值只可能是n的因数**
$$\sum_{d|n}d \sum_i^n[gcd(i,n) = d]\\=
\sum_{d|n}d\sum_i^{n/d}[gcd(n/d,i) = 1]\\=
\sum_{d|n}\phi(n/d)$$
然后这题就完结撒花啦!

求$\phi$时用了一个小技巧,$\ge \sqrt n$的质数只有一个,
所以遍历一下$\le \sqrt n$的质数即可

## [序列](https://www.xinyoudui.com/ac/contest/74700231200040A02253EC6/problem/8730)
问有多少序列满足 (s[i + 1] + s[i]) / 2 = a[i]
显然有s[i] <= a[i],s[i + 1] >= a[i]
s[i + 1] = 2a[i] - s[i],所以规定s[1]即可得到整个s
考虑每个s[i]给s[1]的限制,
s[1] = 2a[1] - s[2] = 2a[1] - 2a[2] + s[3]
= 2a[1] - 2a[2] + 2a[3] - s[4]
整理得,s[1] = 2(a[1] - a[2] + a[3] - ..) + s[i + 1] * (i & 1)

## [Xum](https://www.luogu.com.cn/problem/CF1427E)
上课讲的构造题
先考虑只通过加法能够构造出的数,
类似于龟速乘,我们可以构造出x的所有倍数,
1只能通过 n ^ (n + 1)获得,如何构造出这两个数 ?
ax - by = 1,因此要构造一个与x gcd为1的y,显然只能通过异或构造,

给出老师的构造方式,设x二进制长度为k
先通过加法让x左移2^(k - 1),再异或上x,得到的即为 $2^{k - 1} * (x - 1) + x$,与x互质
可以看作通过补0将难做的异或变为减法,运用x是奇数构造出结果

## [[NOI2018] 屠龙勇士](https://www.luogu.com.cn/problem/P4774)
如果能通关,那用哪把剑是一定的,所以解方程,
x*atk_i % p_i = a_i,
这可以先用ex_gcd转换为 x % p_i = a_i的标准形式,
然后跑ex_crt模板

## [Count the Arrays](https://www.luogu.com.cn/problem/CF1312D)
**枚举最大值的位置非常难做,在做组合题时要多试几种枚举方式**
如果确定了前半部分有哪些颜色,那这些颜色的位置都是确定的,
因此考虑枚举有哪些颜色,那个颜色用了2次,剩下的颜色就是左右二选一

## [[HNOI2012] 排队](https://www.luogu.com.cn/problem/P3223)
老师只有2个,所以先考虑不管老师的方案 - 因为老师不合法的方案
$A(n+3,m)*(n+2)! - A(n+2,m)*(n+1)!*2$
注意不能直接插两次板,因为第一次插板时的方案会少统计,因为在第一插板时不合法的方案可能在第二次加入后就合法了

**当分离考虑时要注意当前不合法的在之后是否会合法**

## [「EZEC-2」机器](https://www.luogu.com.cn/problem/P6601)
推式子大题,用$P_n$表示时间为n时在一起的概率,$s$表示为瞬移奇数次的概率
$$s=\sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i}[i \% 2=1] $$
**对于与奇偶有关的式子,一定要想到拆出$(-1)^i$来**
$$\begin{aligned}
s &= \sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i} \frac{1-(-1)^i}{2}\\
&=1/2\sum_{i = 0}^n{n\choose i}p^i(1 - p)^{n-i} - 1/2\sum_{i = 0}^n{n\choose i}(-p)^i(1 - p)^{n-i}\\
&=1/2 - 1/2{(1 - 2p)}^n
\end{aligned} $$
$$P_n = s^2 + (1 - s)^2 = 1/2 + 1/2(1 - 2p)^{2n} $$
$$ans = {1\over 2nt}\sum_{n=1}^t P_n $$
运用等比数列求和即可,**注意公比为1或0时不能用等比数列!**

## [Sasha and Array](https://www.luogu.com.cn/problem/CF718C)
用线段树维护矩阵,
**因为矩阵的乘法对于加法也具有结合律,**
因此可以用线段树维护乘法和区间和
注意为了获得更好的复杂度,要用矩阵存tag,防止每次下传都快速幂

## [Frets On Fire](https://codeforces.com/problemset/problem/1119/D)
li从几开始无所谓,不妨假设从0开始
考虑先排序,然后假装s[1] = 1
如果r足够大,那就是s[n] + r,问题在于中间有空
中间空的贡献是 - max((空长 - r),0),这可以排序后用二分解决

## [[六省联考 2017] 组合数问题](https://www.luogu.com.cn/problem/P3746)
不会做,看题解
**注意到其要求列数 %k = r 的所有数的和,同时所有的转移方式是相同的,**
**可以考虑放到%k的同余系下来做,f[n][r]表示所有 C_n^m 中 m % k = r 的和**
f[n][r] = f[n - 1][r - 1] + f[n][r],f[n][0] += f[n - 1][k]
因为k非常小,所以可以用矩阵快速幂来做

## [[SDOI2018] 战略游戏](https://www.luogu.com.cn/problem/P4606)
和割点有关的题,先考虑建圆方树,
问题变为圆方树上关键点间有多少圆点
**看到s的总和较小,复杂度与总和有关可以运用建虚树的方式来做**

## [[HNOI/AHOI2018] 排列](https://www.luogu.com.cn/problem/P4437)
$\forall j <= k,a_{p+j} \neq p_k$,
即如果要给p_k赋x,那么之后不能有a_x,即a_x一定在k前
即排列时值 a_x 要放在 x 前面
如果没有限制就是简单的从小到大排序,
而这类有限制的贪心就是经典的并查集 + 堆的套路
即取出后可以将其和父亲看作一组
假设一组内为 a1,a2 另一组为 a3,若a1,a2在前,则
a1 + 2a2 + 3a3 > a3 + 2a1 + 3a2,
即 1/2(a1 + a2) < a3,即按照组内平均值排序

## [Shortest Cycle](https://codeforces.com/problemset/problem/1205/B)
诈骗题!!
a[i]最多61位,而如果3个数都有1位为1,那肯定有环,所以只要考虑n <= 185的情况
不会啦,看题解.这可以用floyd求解,
具体而言,环要求i,j用2条不同的路径连起来,而floyd到k时k不在路径的中间点中,
所以可以在考虑k时枚举与k相邻的点i - k - j - i的路径

**需要获得不经过某些中间的路径时可以找floyd**

## [Pudding Monsters](https://codeforces.com/problemset/problem/526/F)
给一个排列,问有多少个子区间其最大 - 最小 + 1 恰为 区间长度
不会做,看题解!!
问有多少maxn - minn = r - l成立,考虑对于每个r有多少满足
每次移动r时,改变了一下r和部分的maxn和minn,这可以用单调栈获得
即f = maxn - minn + l - r,问多少个 = 0,
因为f肯定大于0,所以维护最小值和最小值个数即可

## [Unique Subsequence](https://atcoder.jp/contests/arc125/tasks/arc125_d)
如果a是一个独特的子序列,那么其右边加入一个在右边只出现了一次的数,其还是独特的
f[i]表示以i结尾的独特的子序列的个数,
$f[i] = \sum_{j \in [las[i],i - 1]} f[j]$,
同时$f[las[i]] = 0$

**启示我们在设计dp状态时不要过于直接开始想复杂,**
**先考虑清楚一个个加入的简单情况是否可行,如果不行其不行的关键是什么**

## [LIS to Original Sequence](https://atcoder.jp/contests/arc125/tasks/arc125_c)
求出长m的字典序最小的序列,使其最长上升子序列恰为a
不会做,听了cyn大佬的讲解!
我们可以画图进行理解,横轴是坐标,竖轴是数的大小,
对于每个a[i]来说,能在后面放更小的就放最小的能放的,
然后把剩下的都递减放到最后一个a[i]

**想不出来时画图感性理解**

## [Prefix XORs](https://atcoder.jp/contests/arc137/tasks/arc137_d)
将前缀异或的贡献打表出来,发现是一个分形的图形,
处理分形可以使用递归,只处理有1的矩形,时间复杂度为$3^{\log n}$
这样依旧会TLE,
有一个奇技淫巧,可以把最后一层的递归手动展开就变快了

**想不出来就打表,看到分形可以递归**

## [Distinct Numbers](https://atcoder.jp/contests/arc137/tasks/arc137_c)
**打表大题,结论题还是得打表~~** 不打表一百万年都看不出来
给出证明:
如果$a[n] \neq a[n - 1] + 1 $,alice可以把其变为$a[n-1]+1$,
如果此时Bob必败,那就这么走,
否则Bob将其变为$z$必胜的化,Alice可以反悔将其变为z

如果$a[n] = a[n - 1] + 1$,此时就变为了比较操作轮数的奇偶了

## [Coprime Pair](https://atcoder.jp/contests/arc137/tasks/arc137_a?lang=en)
诈骗题,直接暴力枚举答案即可
**因为互质的数分布是非常密集的,所以非常的快**

## [志愿者招募](https://www.luogu.com.cn/problem/P3980)
经典的网络流套路题
朴素的想法是将人连向天数,但这样没法处理一个人同时干多天,
可以把所有天都放在一条链上,i - i + 1 是$inf - a[i]$,
然后对每个志愿者s - t为一条s - t + 1的边

**本来容量只能处理最多为多少,**
**但连成链强迫其总流量为inf,**
**然后$inf - a[i]$又强迫其从志愿者哪里获得了$a[i]$的容量**

**当出现至多/至少时可以考虑进行网络流,又有同时给一系列点赋权**

## [最长k可重区间集问题](https://www.luogu.com.cn/problem/P3358)
**至多多少,给一系列点增加值,可以考虑网络流**
**区间覆盖的经典套路,放到一条链上去**
注意建图时的自环问题

## [Sequence Scores](https://atcoder.jp/contests/arc114/tasks/arc114_c)
不会做,听柳巨讲解,
考虑最劣的操作数为n * m^n,考虑最优操作比最劣的少操作了哪些
如果 a[i] = a[j] 且 i - j 中所有数都比a[i]大,那会少操作一次
对于左右为p,间隔为l的方案数为$(n - l - 1) * m^{n - l - 2}(n - p)^l$
又因为我们有所有的序列,所以枚举一下所有的p和间隔即可

**当题目出现类似有所有的序列/排列时,可以尝试利用每种情况都会出现的性质来列出贡献**
**当有条件才能减少贡献时可以尝试反算减少的贡献**

## [Moving Pieces on Line](https://atcoder.jp/contests/arc114/tasks/arc114_d)
又听柳巨讲解
**区间问题想到用差分解决,一个珠子相当于在其起点和终点位置都异或1,**
最终要得到一个t[i]处都为1的差分数组
又因为柱子是不能交叉移动的,否则肯定不优,
所以可以dp,
f[i][j]表示满足前i个点,用完了前j个柱子的最小方案数

**在最小步数类问题中经常与不能交叉移动有关**

## [Permutation Division](https://atcoder.jp/contests/arc114/tasks/arc114_f)
听了茹巨的讲解,
原序列肯定是最优的情况,要动肯定是做一个比原序列字典序更大的东西
如果最长下降子序列比k长,我们就可以使其不动,达到最优,
如果不能使整个序列不动了,我们希望从头开始不动的部分尽可能长,
因为其若是将x换了,肯定换了更大的,劣于换x + 1
要使前x个不变,需要前面的链头单下降,且x + 1后的每个链头都 < 前面最小的链头

现在问题变成了我们要求出这个分界点,使得这个分界点尽可能靠右的同时留下的k更小,
我们可以对于每个i求出最靠右的res,使得res - n中$< a[i]$的数有$k - f[i]$ 个,$f[i]$表示以i结尾的最长下降子序列长度
发现因为要求最大res,所以可以将res视为单调递增的,直接一个单增的指针 + 树状数组即可

## [Non Arithmetic Progression Set](https://atcoder.jp/contests/arc145/tasks/arc145_d)
不会做,看题解,
先不考虑 = M的条件,2y != x + z
对每个数进行3进制拆分,保证每位都是0/1即可
而通过同时对所有数加减,我们可以使其里目标 < n - 1,
给每个数最后一位留空,最后再加

**当我们要构造很多数使得他们满足一些条件时,可以进行进制拆分,使他们每一位都满足这些条件**
**因为条件约束使得我们只会构造很小的情况,这时通过进制拆分,将每一位独立开来,就可以通过很小情况的不同组合来构造大情况了**

## [Too Heavy](https://atcoder.jp/contests/arc111/tasks/arc111_c)
听了柳巨,lay,茹巨的讲解,
考虑所有i向p[i]连边,不难发现一定会形成一堆环,目标是将所有变为自环
任意交换环内两点,环一定变为2个,所以构造任意方案,其一定最优,且ans = n - 环个数
首先如果有一个p[i]不是自己且其已经被重死了,肯定无解
考虑如何构造方案 ? 给出柳巨的方案
我们可以找到环中的大力士(a最大),然后按顺序让环上每个人跟他换即可
无解仅当由物体比大力士还重,这肯定在开始就被判掉了

**排列上换来换去的问题常常和置换环有关**

## [Simple Math 3 ](https://atcoder.jp/contests/arc111/tasks/arc111_e)
听了lay的讲解 !
考虑一个答案的上界 ans <= (d - 1) / (c - b)
前面的有贡献仅当 (a + ci) / d = (a + bi - 1) / d + 1
所以我们就是求两个相减的值,就是类欧模板

## [A < AP](https://atcoder.jp/contests/arc151/tasks/arc151_b)
考虑第i位小于,前面a[j] = a[p[j]],后面随便选,用bcj维护即可

## [01 Game](https://atcoder.jp/contests/arc151/tasks/arc151_c)
听了lay的讲解
考虑每个棋子将其分成了多个互不干扰的小游戏,求这些小游戏的SG值,
记1 .. 0 , 1 .. 1 ,... 0,1 ...的SG值
打表一下发现 1 .. 0 即为 0,1 .. 1为1,..1为长度
**SG若列完 mex,异或 式子没思路时可以考虑打表**

## [Binary Representations and Queries](https://atcoder.jp/contests/arc151/tasks/arc151_d)
听了lay的讲解,
极端情况,n = 0如何做 ? 
每次操做时记录一下0 = x 0' + y 1',1同理,即可
n = 1 如何做 ?
对于相邻两个层数不同的操做,调换他们的顺序对结果没有影响,
所以一层层操做下去即可

**这类操做类题目往往可以往操做的合并,交换顺序等角度上思考**

## [Keep Being Substring](https://atcoder.jp/contests/arc151/tasks/arc151_e)
听了题解的讲解 
如果两者最长公共子串不为空,那先删成最长公共字串再加回去
那就是p + q - len
最长公共字串可以hash + 二分求解
否则先删成一个点,再一点点挪过去,可以用bfs求解

## [Bakery](https://www.luogu.com.cn/problem/AT_arc137_e)
假设每天都可以做 a_i 个面包
从志愿者招募的基础上出发,问题在于如何处理没有雇满的部分
稍作修改即可,即将没雇满也看作一个面包师,费用为d

## [Random IS](https://atcoder.jp/contests/arc108/tasks/arc108_e)
不会做,看题解 ~~~
即使是相同的方案,被打上标记的概率也是不同的,所有考虑对过程进行dp,
枚举第一个标记的点p,此时左右部分的选择互不影响,只与p有关,就被拆位了两个更小问题
因此进行区间dp,f[l,r]表示已经标记了l - 1,r + 1后区间内的标记个数期望
$f[l,r] = (\sum_{l < p < r,a[l - 1] < a[p] < a[r]} f[l,p - 1] + f[p + 1,r] + 1) / k$
其中k为p的个数
注意到这是个偏序问题,所以可以开n个树状数组解决

这题非常深刻,整理一下思路过程
首先我们按照普通的思路考虑方案发现错了,
**问题关键是不同方案的概率也是不同的**,
**因此考虑模拟取数的过程**
在取完第一个数后,我们相当于将问题分为了两个部分,**同时这两部分互不影响**,且只与取得那个数字有关,
由此,我们能够轻易得写出dfs的做法,正者做就是区间dp

**模拟选取过程往往与区间dp有点关系**

## [Paint Tree](https://atcoder.jp/contests/arc108/tasks/arc108_f)
不会做,看题解 !
**将两个点集点组合起来新的直径的端点一定来自两点集的直径的端点**,
所以考虑先求出直径
求出一条直径后直径上两端点若颜色相同则值为直径,考虑颜色不同的情况,
设直径两端点s,t,如果答案为f,说明所有和s距离 > f的都和s异色
如果一个点与s,t距离都 <= f,那么该点颜色随便,我们就得到了答案 <= f 的方案数

## [1 or 2](https://atcoder.jp/contests/arc121/tasks/arc121_d)
如果只能2个取,那么排完序后让最大和最小配对,次大次小配对,一直配下去,这个可以花数轴上用平均值来证明
取1个点可以是视作取a和0,所以枚举一下0的数量即可
时间$O(n^2)$

## [[HEOI2016/TJOI2016] 排序](https://www.luogu.com.cn/problem/P2824)
注意到只询问一个位置上的数字,
所以可以用该位置上的数将所有数分为 <= 它的和 > 它的,
设<= 它的为0,>为1
就变成了给01序列排序,而这用线段树非常好维护
二分一下该位置上的数是多少即可

**通过一个数来将难得序列问题变为简单得0/1问题是常用得思想**

## [Logical Operations on Tree](https://atcoder.jp/contests/arc121/tasks/arc121_f)
考虑哪些情况可以变成1,
我们可以先把所有 & 边都缩掉,变为了几个由 | 连接的连通块,
如果有一个连通块是1,那么最终就可以缩为1.
恰有一个连通块比较难维护,我们算不合法的方案数
f[u][1]表示除了u所在的连通块为1,其他都是0的方案数,
f[u][0]表示u子树所有连通块都是0的方案数

枚举该边是 | 或 &
2 * f[u][0] * f[v][0] + f[u][0] * f[v][1] + f[u][1] * f[v][0] -> f[u][0]
f[u][1] * f[v][1] + f[u][1] * f[v][0] -> f[u][1]

## [Directed Tree](https://atcoder.jp/contests/arc121/tasks/arc121_e)
所有点都合法的方案数 = 至少0个点不合法的方案数 - 至少1个点不合法的方案 + 至少2个点不合法方案 -..
理解 : 将每个点是否合法是做一个条件,就是一个要满足所有条件的容斥

f[u][i]表示子树u中至少有i个点不合法的方案,
1.u没有填到自己的子树中,一个个加入子树
f[u][m] = f[u][k] * f[v][m - k]
2.u被填到了子树中
f[u][m] += f[u][m - 1] * (siz[u] - 1 - (m - 1))

最终f[i] = f[i] * (n - i)!

**将序列全部合法用容斥转换为至少几个不合法是常用的方法**

## [Binomial Coefficient is Fun](https://atcoder.jp/contests/arc110/tasks/arc110_d)
**组合意义天地灭**,~~代数推导保平安~~
听了lay的讲解😊
有m个球,我们先将其分为n + 1组,前n组就是b,最后一组表示丢掉的,
C[b][a]乘起来就是每组选a个球标黑,
插板法,发现可以把隔板也是做黑球,最终求得的方案也是固定的
所以就是c[m + n][n + \sum a_i]

**通过设计一种映射方式,将复杂的方案映射成简单的情景**

~~组合意义天地灭~~,**代数推导保平安**
看了题解的式子推导,
考虑到$b \ge a$难维护,先变成${b + r\choose b}$,$m -= \sum a_i$
求解$\sum \prod_j^n {a_i + r_i\choose a_i}[\sum r_i \le m]$
**组合数学 + 总取数不超过m是个经典的生成函数套路**
先设计一个生成函数第 i 项表示 r = i,然后成起来即可
$$\begin{aligned}
  \prod_j^n(\sum_{i\ge 0} {a_j + i\choose a_j}x^i) & = \prod_j^n\frac{1}{(1 -  x)^{a_j + 1}}\\
  & = \frac{1}{(1 - x)^{n + \sum a_i}}\\
  & = \sum_{i \ge 0} {i + n + \sum a_i - 1\choose n - 1 +\sum a_i} x^i
\end{aligned} $$
$$ans = \sum_{i \in [0,m]} {i + n + \sum a_j - 1\choose n - 1 + \sum a_j} = {m + n + \sum a_j \choose n + \sum a_j} $$
**看到求和式可以考虑代数方法,看到有乘法直接考虑一下生成函数**

## [Esoswap](https://atcoder.jp/contests/arc110/tasks/arc110_f)
题解做法:
如果i上是0,那么对i操做完还是0,
如果对一个位置连续操做,
其每次操做完变为一个新数,这个新数意味着其会与一个新的位置上的数交换,
意味着不会操做回原来出现过的数,所以最多n次其回变成0,
我们从 n - 1 -> 0 每个位置都操做成0,
n - 2的0来自n - 1,且那次交换他是1,所以n - 1上是1,
n - 3的0来自n - 2,且那次交换他是1,所以n - 2此时是1,n - 1是2,
以此类推

lay的做法:
对位置0上的数操做,其会回到原来的位置,
我们考虑将每个数字移到0上,用0来帮他交换,
但有时会出现没有数字能与0交换的情况,这时我们随机打乱一下即可

操作类题的常见观察 : **对0/1/n等特殊点操作 / 对一个数连续操作 / 按照递增/减顺序操做**

## [Xor Sum 5](https://www.luogu.com.cn/problem/AT_arc156_d)
假设第i个数加了$c_i$次,$\sum c_i = k$,
如果$\frac{k!}{\prod c_i!} \mod 2 = 1$,那么这种情况会被异或上,
$v_2{k\choose c_1,c_2,c_3\dotsc_n} = 0 $
由类似 kummer 定理的知识可知,
对 $c_i$ 二进制分解后所有1的个数和 k 的二进制分解中 1 的个数相同
由因为 $k = \sum c_i$ ,所以 $c_i$ 是k集合的一个拆分即可
考虑求和为 s 的方案数,如果为奇数,答案异或上 s 
$f[i][s] $表示考虑到k的第i位时s的方案数
$f[i][s] = \sum_j f[i - 1][s - 2^ia_j] $
问题在于s非常大,根本存不下,
当处理到第 i 位时,此时无论选那个数都不会改变答案第 i - 1位值了,
因为此时无论选那个数给 s 在第 i - 1位加的都是0,
所以我们只需要记录 s 从第 i 位开始的状态即可,因为 a 只有10位,所以记录 10 位即可

## [[ZJOI2019] 语言](https://www.luogu.com.cn/problem/P5327)
考虑记录一个点能到达的点,那就要记录这个点被哪些路径经过了
这是典型的树上差分,问题是如何记录这些路径经过了哪些点?
这可以通过线段树来记录,合并子树时进行线段树的合并,
记录线段树的最小值和最小值个数
**树上问题常常和可并数据结构结合考察**
动态开点线段树合并,代码非常屎,但有些经验

标记下穿非常难,因为很多时候没有子节点,所以可以标记永久化
合并时先合并左右节点后通过左右节点得到该点的值,然后再合并永久化的标记
要好好规定没有节点时取到的值应该是多少
树剖注意dfn在第二次求
注意什么时候需要引用

## [『STA - R7』求和](https://www.luogu.com.cn/problem/P11009)
考虑操作 $x + \lfloor log2(x - 1) \rfloor$
x = [2^n + 1,2^(n + 1)] -> x + n -> [n + 2^n + 1,n + 2^{n + 1}]
操作1 位 n + 2^n ,所以 >= 2 的每个数都能被表示,并且表示方式唯一

如果x > log(n),那么其实操作1就没有意义了,x <= log(n)时才需要进行操作1,
先得到所有操作1得到的数,然后从这些出发,一直用操作二
问题变成了如何求从x开始一直用操作2多少次
这个一次跳 2^(log x) 次即可

## [『STA - R7』异或生成序列](https://www.luogu.com.cn/problem/P11008)
发现不一样是有保证的$p$和$p\oplus s_i$是肯定不相等的,所以只要保证最大值 = n即可,这个用字典树做一下即可

## [[NOIP2022] 建造军营](https://www.luogu.com.cn/problem/P8867)
连通性问题考虑tarjan,边双缩点后非桥边选不选都没关系,
变成树后考虑如何做 ?
所有建造的军营都要连在一起,发现这和虚树很像,类似虚树的思想
g[u] 表示以 u 为建造的所有军营的lca时的建造方案数,
那么所有军营都要与 u 相连,但要 2 个字数内有非常难统计,
更改状态为 g[u] 表示只在 u 种设军营且所有军营都与 u 相连的方案数,
那么除了跟节点外 $g[u] *= (m - siz[u])$ 表示除了该子树中的边和其父边外都可以随便选
其父边不能选否则会被统计到其父亲的答案中去

**树上联通性问题常常用只在子树 u 中选且都与 u 相连设计状态**

## [[SDOI2014] 数数](https://www.luogu.com.cn/problem/P3311)
这是数位dp 和 ac自动机 dp 杂交的恶果

稍微回顾一下数位 dp
$f[i][k][2]$ 
表示到第 i 位, k 是题目中的一些特殊限制, 0/1 表示到这位是否紧贴上界,受限制
处理前导0只要先跑出位数和上界相同的情况,再跑位数小的即可

## [Modulo Shortest Path](https://www.luogu.com.cn/problem/AT_abc232_g)
很好的建图题目,
我们发现从 u 连出的边分为两部分,一部分正常,另一部分 - m,
且有一个分界点,前半部分都正常,后半部分 - m,
所以可以给 b[i] 排个序,用前缀优化建图,即一条虚点链
**将连点分为几部分的都可以用前缀优化建图/线段树优化建图**,
但发现有负权,sfpa会超时,这时可以钦定一个势能,即可跑dj

## [[ARC159D] LIS 2](https://www.luogu.com.cn/problem/AT_arc159_d)
f[l] 表示长度为 l 的最长上升子序列末尾最小值
f[upper_bound(x - 1)] = x
我们只关注每个 l 的位置,然后进行连续修改
注意到 f[l] 的值是一段一段的,所以可以用 set 来维护

## [Looking for Order](https://codeforces.com/problemset/problem/8/C)
剪枝题,因为与取的顺序无关,容易想到状压dp,但直接2 ^ 24 * n^2会TLE的,
同时我们发现相较于普通dp,其最后取哪一个也是无所谓的,
所以我们钦定其最后都是取编号最小的所在组即可

**与顺序无关时钦定顺序是常见剪枝手法**

## [Banned Substrings](https://www.luogu.com.cn/problem/AT_abc305_g)
套路题,如果 n 非常小,就是文本生成器,
n 非常大,套一个矩阵快速幂即可

## [Cards](https://www.luogu.com.cn/problem/AT_abc247_f)
这类题都十分形似,先搞出置换环,然后考虑一个置换环内怎么做 ?
对于有n个点的置换环,我们考虑dp求出答案,
$f[i]$表示考虑了前 i 个边,最后一个边必须选的方案数 $f[i] = f[i - 1] + f[i - 2] $,
发现就是斐波那契数列,预处理一下即可

## [Max Dot](https://www.luogu.com.cn/problem/AT_arc128_c)
$\ge$ 不好维护,我们可以用差分的思想考虑,每个点代表了加后面所有点
考虑对后缀平均值排序,每次加平均值最大的点
如果不考虑M的限制,就是从某个数开始,之后所有数的值都一样
如果超过了m的话,就不得不把一些值放到前面,
这样就变成了问题规模更小的子问题,n ^ 2求解一下即可

## [Neq Neq](https://www.luogu.com.cn/problem/AT_arc128_d)
相邻的相同数永远无法删除,会把问题分成更小规模,所以考虑没有相邻相同的数
考虑如何才能删除一个区间,因为没有相邻的数,手摸一下,
发现区间[l,r] 无法删除仅当[l - 1,r + 1] 的字符集只有2个且长度 > 1,
因此用 f[i] 表示考虑前 i 个,最后一个必须保留的方案数,转移即可,
然后把互不干扰的区间乘起来即可
可以把难的删除区间转换为较简单的保留节点

## [「EZEC-4」可乐](https://www.luogu.com.cn/problem/P6824)
经典的字典树上 dp,
如果 x 这一位取 1 且 k 这一位为1 , 那么就是所有这一位为0的a[i]后面几位都 <= k后面几位的个数 + 这一位为1的a[i]个数
如果k取0,就是这一位为 x ^ 1 后面几位都 <= k 后面几位的个数
所以建出字典树后dfs转移即可

**某数位和后面数位有关系时,可以考虑字典树上dp**

## [[AHOI2005] 病毒检测](https://www.luogu.com.cn/problem/P2536)
**同时处理多个字符串/位运算,无论如何都要考虑一下字典树!**
如何匹配呢 ? 考虑在字典树上进行dfs,
如果t当前位是 ? ,那就dfs(x + 1,任意儿子),若* -> dfs(x,任意儿子) / dfs(x + 1,不动),
记忆化一下即可

## [[CQOI2014] 通配符匹配](https://www.luogu.com.cn/problem/P3167)
直接套用病毒匹配思路会寄,因为这里串长非常长,
考虑只有 * 怎么做,我们只要给 T 按照 * 分段,从前往后匹配最早出现的即可
中间有 '?' 怎么做,因为最多只会出现 10 个,匹配时按 ? 分段特殊处理即可,只是把 O(1)匹配变成了O(10)

## [Springboards G](https://www.luogu.com.cn/problem/P6007)
跳一个跳板节省的距离是 y2 - y1 + x2 - x1,要使用这个跳板,只能从其起始左下角的跳板选择
左下角是个典型的二维偏序,用线段树维护一下最小值即可

## [「EVOI-RD2」童年](https://www.luogu.com.cn/problem/P7925)
很好的贪心题,
一个正的点在能选一定会被选,朴素的想法是把所有正节点都和其父亲合并,
但问题是有些点合并后仍是负的,借鉴思想,我们希望通过合并使所有点都是正的,
这样对于每个点只要能选我们就一定会选,
问题转换出对于每个点求出合并后最少带着多少进入能带着更多出来,
将u,v合并后,$nd[u] = max(nd[u],nd[v] - a[u])$,所以对 v 按照从小到大的顺序合并即可

## [暗杀](https://www.luogu.com.cn/problem/P2843)
显然前缀和一下,考虑到r时
如果有一个 l 其与r所有前缀差值都相等,就找到了一个答案,
如何刻画差值相等 ?
如果一个序列和另一个序列所有数差值相等,其实就是他们的差分数组相等,
所以对前缀和的差分数组hash一下用map记录即可

**即对一个序列同加减,其差分数组不变的应用**

## [天体探测仪](https://www.luogu.com.cn/problem/P7726)
性质题,考虑从小到大确定每个点所在位置,
对 1 来说,只要 $i(n - i + 1) = $ 1 出现的位置即可,
对 2 来说,一个是和出现次数相同,还要求其所在区间长度为其最后一次出现位置长度,
因为在构造过程中,我们只关系每个长度的区间的出现次数,所以这样一定是对的,而与区间位置无关,
所以这样是对的

## [[BalticOI 2020 Day2] 图](https://www.luogu.com.cn/problem/P6696)
对于有环的连通块来说,解方程即可,我们只要考虑树.
考虑根的值为 x ,我们可以把每个节点都表示为 $|x - b|$ 的形式,
即转换了选出一个 x ,使其到一些点的距离和最小,直接取中间那个数即可,
考虑画出数轴,如果左边的数更多,那么往左走能够得到更优的答案,所以选中间即可
**绝对值和最小选中间**,类似于树重心的证明,即调整法的应用

## [K Different Values](https://www.luogu.com.cn/problem/AT_arc128_e)
看了题解,
考虑没有数量限制时,当放 i 时,放最小的 las[j] + k - 1 < i 的 j 即可,
如果有数量限制时如何放,将剩余的按 k 分段后,设分为了 c 段,最后剩了 v 个,
如果 a[i] = c + 1 的有 v 个,那就一定要在这 v 个里选,否则就按无限制选,
这样贪心出的答案肯定字典序最小,只要证明这样不会使原来可以合法的答案不合法即可.
这样构造的方案肯定合法啦

## [XOR Matching](https://www.luogu.com.cn/problem/AT_abc126_f)
如果 k 大于最大值,那么 k 必然没法搞出来,
否则直接 k 0 1 2 .. k 2 1 0 ...
因为所有数异或起来是 0 ,所以 k 之间是 k ,其他数显然是 k 

## [[Ynoi Easy Round 2021] TEST_152](https://www.luogu.com.cn/problem/P8512)
先把离线询问扫描线,区间覆盖是很难维护的,考虑每次操作对答案的贡献,
记录一下 $p \in [l,r]$ 内最后一次覆盖的 id 是多少,
操作 i 对所有 $l < id$ 的询问有$v - op[id].v$ 的贡献,而对$l > id$有 v 的贡献,
这个用树状数组维护一下即可,而最后一次覆盖 id 可以使用珂朵莉树

## [[JSOI2015] 字符串树](https://www.luogu.com.cn/problem/P6088)
**树上求 u - v 间的计数类问题,经典套路是 ans[u] + ans[v] - 2 * ans[lca(u,v)]**
所以问题转换为了求 1 - x 的路径上有多少个字符串的前缀为 s ,
这个可以用字典树来求,进入时插入 s ,回溯时删除 s 即可

## [Permutation Oddness](https://www.luogu.com.cn/problem/AT_abc134_f)
看了题解,
绝对值不好考虑,考虑一个元素作出贡献为多少只与其与坐标的大小关系有关,坐标同理
可以把模型转换为 n 个球放到 n 个盒子内,总的怪异度就是连线经过了几条横线
f[i][j][k] 表示考虑前 i 个球和盒子,有 j 对没有配对,怪异度为 k 的方案数

**遇到过的几种处理排列的方式** :
- 每加入一个数就把前面的 >= 的 + 1(大小关系 的问题)
- 每加入一个数和前面选一个数交换位置
- 将其抽象为球和盒子配对问题(一般与坐标和元素都有关系的问题)

## [「NOIP2022」比赛](https://loj.ac/p/3899)
区间问题考虑 分治 / 扫描线,
此处考虑扫描线 + 线段树,
扫描线需要区间修改 a / b,维护 ai * bi,以及 ai * bi 的版本历史和
**区间覆盖非常难维护,改成区间加是常用的手段**
维护 1.a += val 2.b +=val 3.ans += a[i] * b[i]
维护 sa,sb,s,his_s,adda,addb,upd
a += x -> sa += x * len,s += x * sb,adda += x
upd -> ans += s,++upd
如何合并操作序列 ? 不妨令每次先 upd 再 add,
upd * n + ada + adb + upd * m -> 
upd * (n + m) + m * (ada * sb + adb * sa + ada * adb)
额外记录 m * ada 的和, m * adb 的和 与 m * ada * adb  的和

设计状态时的技巧 : 
- 先定义好操作的顺序以及合并操作序列的方式,
- 下穿标记时的修正标记应当只与标记有关,
- 将修改标记与修改值封装成函数

## [[COCI2014-2015#4] STANOVI](https://www.luogu.com.cn/problem/P7179)
对于一个 n * m 的矩阵,其可以看作两个公寓拼起来,所以我们爆搜
$f[n][m][u][d][l][r] $表示大小为 n * m 的矩形上下左右是否可开窗的最小值,
dfs即可. 因为上下左右是对称的,剪一下枝即可

## [[HNOI2015] 实验比较](https://www.luogu.com.cn/problem/P3240)
看了题解
f[u][l] 树 u 内长度为 l 的方案数 
f[u][l] += f[u][l1] * f[u][l2] * orz ,l1 < l,l2 < l
如何求orz ? 第一个只能放 u ,先放 l1 个,再用 l2 填满剩下的,然后再将 l2 剩下的l1合并
orz = c[l - 1][l1 - 1] * c[l1 - 1][l1 + l2 - l]
orz 的正确性是因为 l 的顺序是固定的,所以我们只需要决策哪些点合并或放置即可获得与方案的映射

**这类顺序固定的题常常转换为不考虑顺序选择放在哪些点,再和实际方案映射**

## [[十二省联考 2019] 异或粽子](https://www.luogu.com.cn/problem/P5283)
堆拓展 + 可持久化字典树
**总数很多但 k 很小,考虑经典套路堆拓展,**
求异或第 x 大,考虑字典树,因为要求某个区间,所以可持久化

## [[CQOI2015] 选数](https://www.luogu.com.cn/problem/P3172)
很好的莫反题目
**考虑到我们能够快速求出 gcd = x 的倍数的个数,如何求 gcd = 1 的个数 ? 经典莫反**
$f[i] $ 表示 gcd = ki 的方案数,对与$\forall p > 1,\sum_{i \le p} \mu(i) = 0 $,
所以直接求 $\sum_{1\le i\le y} \mu(i) f[i] $ 即可,
问题在于 y 非常大,考虑运用 y - x 这一条,
对于所有 $> y - x$ 的 i ,其 $f[i]$ 只有当 i 是 x - y 中一个倍数才为1,其他都为0,
所以我们先求出 $\le y - x$ 的方案数,然后再求大的,
记求$\sum_{p\in [l,r]} \sum_{d | p,d > len} \mu(d) = -\sum_{p\in [l,r]}\sum_{d|p,d \le len} \mu(d),p > 1 $
这个式子算一下 l - r 有多少 d 的因数即可
特判一下 l = 1 的情况即可,因为$\mu(1) = 1 $,

## [「ZJOI2008」骑士](https://loj.ac/p/3795)
一道很烦的基环树~~ 
每个点都有一条边 -> 基环树
一些需要注意的点 : 
- 找环不要自己乱想想,请使用现成的 tarjan 来找环
- 注意有些上面没有环,就是一颗树
- 环上dp可以多设计一维表示最后一个点的状态

## [最小度限制生成树](https://www.luogu.com.cn/problem/P5633)
很麻烦的wqs模板
细节 : 1.共线点有最小的点来代表切点(通过将与 s 相连的边放到同权值最后)
2.s至少要有 k 条互不相同的边
3.s 只用 k 条边仍能连成数

## [撤离](https://www.xinyoudui.com/ac/contest/774001C190004830288FD36/problem/4554)
观察性质 :
- 不可能会有两个人在同一个点走同一个方向,否则这两个人一定会从同一出口出去
- 不可能会有两人走同一个点为相反的方向,否则会从互相来的路线回去
- 因此一个转换器只会被一个人使用
  
考虑网络流,将点分为竖着走和横着走,在横竖转换时连一条费用为 c 的边,所有边容量都为 1

## [[ZJOI2013] K大数查询](https://www.luogu.com.cn/problem/P3332)
整体二分的板题,其原理是**操做和询问都会被分到二分后 2 个区间的一个以保证复杂度**
考虑一次询问可以二分答案,求最小的比 mid 大的数小于 c 的数
整体二分也二分答案,询问显然会被分过去,操做如何分 ?
$c \le mid$ 的操做分到左区间即可,其对右区间的询问显然之后不会有任何贡献,
$c > mid$ 的操做放到右区间后,其对左区间所有询问之后贡献不变,所以给左区间的询问 - 比 mid 大的数的个数即可

用数据结构维护时常见的方式是离散化,注意离散化后的影响,或者写可撤销的数据结构

## [Zigzag Tree](https://atcoder.jp/contests/arc130/tasks/arc130_d)
要求排列,考虑 f[u][k][0/1] 表示 u 子树中赋了 1 - siz[u] 的值,u 的值为 k,为周围点中最小/大的方案数
要把两个排列合并成一个新排列,即将一些数映射到一个新数上去,
如将值域 1234 和 12 的排列合并,
可以看作把 1 2 插入到 5 个空隙中的任意两个,然后将原值映射为新的坐标,
在此题中为了保证映射后的大小关系,我们可以枚举有多少个数放在了 i 前面,不妨设 v 中有 t 个数放在 i 前,
f[u][i + t][0] += C[i + t - 1][t] * C[siz[u] + siz[v] - i - t][siz[v] - t] * f[u][i][0] * f[v][j][1],0 <= t < j
f[u][i + t][1] += C[i + t - 1][t] * C[siz[u] + siz[v] - i - t][siz[v] - t] * f[u][i][1] * f[v][j][0],siz[v] >= t >= j
考虑化为树形背包的形式,我们枚举 i 和 t 的值,然后前缀和处理 j 即可

**将两个排列映射到 1 个排列的 经典方式 :**
举例 : 有排列 A(4个数) 和 B(2个数),我们将 ab 插入到 1234 中,
如得到了 12a3b4,就代表将B中 a/b 映射到3/5 A 中3/4 映射到4/6

## [Replace by Average](https://www.luogu.com.cn/problem/AT_arc130_f)
题解给出的性质 :
1.因为 B(x) <= (B(x - 1) + B(x + 1)) / 2,所以 B 是下凸的函数
2.$min{a_i - kx},k \in Z$,在变化 A 的过程中是固定不会变的,
proof : 考虑对于 k 我们先找到一个最小的 i,对于第一次变化来说因为k \in Z,肯定是满足的,
而每个点都是满足的,所以对之后每次变化都会满足

令 a_k = min{a_i - kx},k \in Z,
B(x) = max{a_k + kx}
proof : $B(x) \ge res $显然,否则性质2就不满足了,
考虑证明$\le res$,因为是下取整,手玩一下确实可以

## [[HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)
一类经典的网络流类型,
**有多类物品,每类物品只能选一个,有一堆约束,最小化贡献**
可以把每类物品都放到一条链上,链上第 i -> i + 1连边权为选 i 的代价,反着连边权为 $\infty$ 的边
这样跑最小割断开那条边就代表选了那个点,而反向的 inf 边则保证了其在添加约束条件后不会在同一条链上割两次,
对于 $\le D$ 的约束条件,我们可以在有约束的链上 i 向 i - D 连边,这样如果选了两个 $> D$ 的边割掉,依然联通

**加入反向边后不会在一条链上割两次**的证明 :
如果我们将 u -> v 割掉,说明 S -> u 且 v -> T 有路径,否则一定不如不割优,
画图发现如果一条链上有两条割边,那么他一定不是一个割的方案,
有路径 S -> u2 -> v1 -> T
可以运用这个判断无解

## [Chess Strikes Back (hard version)](https://codeforces.com/problemset/problem/1379/F2)
看出分成 2 * 2 ,对于每个只能放右下角的点,其右下角必须全都能放右下角,如何维护 ?
我们将只能放右下角的标记为 R,左上角为 L ,即每个 R 右下角没有 L
对于一行来说,我们只要记录最大的 L 和最小的 R 即可判断,
对于单次询问,我们可以分治处理,
每次处理跨区间的是否合法只要看上方最小 R 是否小于下方最大 L 即可,
多次询问可以使用线段树在线维护

要计数是很难的,但该题只要求判断有没有,所以维护最值即可

## [New Year and Handle Change](https://codeforces.com/problemset/problem/1279/F)
如果没有 k 的限制,就是简单的滑动窗口优化 dp,
有 k 的限制,考虑 wqs 二分,简单证明一下是凸包,
我们多加入一段其增加的消除个数肯定 $\le$ 上一次增加的消除个数,
所以是一个上凸包

## [One Billion Shades of Grey](https://codeforces.com/problemset/problem/1427/G)
发现其填的数一定是已经出现的数
先考虑只有 1 / 2 的特殊情况,相当于每个数选集合 s 或 t,
值为 1 在 s ,2 在 t 里,s 向每个 1 连 inf 边,t 向 2 连 inf 边,相邻点连 1 边,求最小割即可
我们希望在数更多时也应用这个方法,
**可以使用绝对值的经典转换,把贡献拆解到数轴上的数上面**,即跨过这个数的数对个数
把数分成$\le v_i$ 和 $>v_i$ 的,那么 $v_i$ 的贡献就是该情况下的最小割

问题来了 ? 是否有数在某次$\le v_1$ 第二次$> v_2$ 呢 ?
实际上使整体绝对值最小等价于使每个数的贡献最小,
考虑移动一个点,当我们使某个区间的覆盖数降低时,不会使其他区间的覆盖数增加
本质是线性规划的单纯形法 ?

此题要运用到退流的技巧 :
当要在网络流中删除一条边时,假设流经该边的流量为 w,
就是跑 u -> S ,流量为 w 的网络流和 T -> v,流量为 w 的网络里路,
然后把改边及其反边残存流量全设为0即可

## [[ARC112E] Cigar Box](https://atcoder.jp/contests/arc112/tasks/arc112_e)
hack 题解,
将数分成不动的和动的两类,不动只会是中间连续的一段递增序列,我们枚举这个不动得序列,
有 i 个数最后一次操作时被放到了左边,j 个被放到了右边,又有 m - i - j 个无用操做,
先将 m 个操做分给 i + j 个数,
操做是互不相同得,但分到得盒子是相同的,因为要根据该盒子内最后得操做来决定该操做序列操做那个数,因此是第二类斯特林数
然后决定操做数字得顺序,即将左右两个排列合并为新排列,是c[i + j][i]
最后无用得操做左右都可以 , 2^(m - i - j)

## [String Journey](https://codeforces.com/problemset/problem/1063/F)
因为是真子串,
我们不妨直接令 t[i] 为 t[i + 1] 增加一个字符,肯定是不劣的,
因为 $1 + 2 + 3 + .. k \le n$ ,所以答案最多为 $\sqrt n$,
启示我们设计状态 f[i][j] 表示从 i 开始,长度为 j 的串作为开头是否合法,
要求 [i + j : ] 中有一个有点 p ,满足 f[p][j - 1] = 1 且其为 [i : i + j - 1] 去掉头或尾,
这个可以用 hash 转移,用bitset来卡常

## [String Set Queries](https://codeforces.com/problemset/problem/710/F)
二进制分组的经典应用,
**如果需要维护的东西不支持插入,每次更改都要整体重构计算,可以使用二进制分组**
我们像二进制数一样将元素分成一组组,
第 0 组有 0/1 个元素,第 1 组有 0/2 个元素,第 2 组有0/4 个元素 ..
每次加入元素时,如果有一组到达了限制,就暴力和前一组合并,
具体实现上可以记录一个 sum ,然后把 lowbit 及后面的全部拍扁,重构到lowbit上

时间复杂度分析 : 
一个元素每次被重构时肯定被放到了一个更高位的组中,因此其对时间贡献最多为 log 的

## [Binary Strings](https://atcoder.jp/contests/arc127/tasks/arc127_c)
考虑画出0/1树来并根据在该节点结束的大小给节点标号
然后观察,发现在 0/1 树上向左走就是排名 -1,向右走 $-2^{n - dep}$ 直到要求排名为 1 时结束
所以就是维护一个高精的 - 2 的幂次, - 1,同时减 2 的幂次只会减最高位,暴力模拟即可
退位为均摊 log

## [Sum of Min of Xor](https://atcoder.jp/contests/arc127/tasks/arc127_d)
$\sum min(a_i \oplus a_j , b_i \oplus b_j)$ 
枚举所有的 i 和 j 是不现实的,我们希望将 i 与 i 放在一起才能够处理,
对于位运算比大小的经典方法是高位全部相同,在某一位更大,我们在能比较出大小的第一位统计答案
对于高位$a_i \oplus a_j = b_i \oplus b_j \Rightarrow a_i \oplus b_i = a_j \oplus b_j $
枚举一下 a,b 的所有取值情况,将能在这一位比出大小的 i , j 对统计掉答案,然后递归下去比较不能比出大小的

##  [BZOJ3252 攻略](https://www.luogu.com.cn/problem/P10641)
从根到叶子几条路径的并就是几条链结合起来,所以是带权长链剖分,取前 k 条即可

## [Unite](https://atcoder.jp/contests/abc296/tasks/abc296_h)
连通性状压模板,对于每行的状态记录某个点属于哪一个连通块,
先预处理出所有合法连通块情况,然后用 hash 来转移,
输出最后用 # 的行每个有 # 的的点都属于一个连通块的方案

## [[CTSC2013] 猴子大战](https://www.luogu.com.cn/problem/P4507)
假设目前手上牌集合为 S ,胜率为 $f_S$
$f_S = \frac{\sum_{i\in S} \sum_{j\notin S} f_{i + S}w_{ij} + f_{S-i}w_{ji}}{|S|(n - |S|)}$
于是我们呢就有了 $(2^n)^3$ 的高斯消元做法
题解中有结论 $f_{A + B} = f_A + f_B$,
证明 : 考虑设计一个三个人同时参加的游戏,每次等概率选两个人进行比赛,
那么对于其中的一个人来说其胜率相较两人没有改变,
因为它可以把另外两个人看作一个整体,其换牌相当于一个人在自己内部交换牌序
即有$f_A + f_B + f_C = 1$ ,所以$f_B + f_C = f_{B + C} = 1 - f_A$
所以用单个的进行高斯消元即可,注意最后一个方程是全部加起来是1

如何想到这个结论 ? 从另一个角度看这个结论,
假设有 n 个人=每个人拿一张,其中有一些人是一队的,仍然是等概率选两个人比赛

## [[NOISG2021 qualification] Departure](https://www.luogu.com.cn/problem/P10772)
斜率优化的恶心题目
考虑答案是整天数 + 零碎的天数,对于整天数,每天贪心走最远的,前缀 max 即可
对于零碎的天数,我们画出当天汽车坐标随时间变化的直线,要在相同的时间内走的尽可能远,我们就是要维护一个当天的凸包
注意以分数存储时的负号的处理,维护凸包时同斜率的处理,当天额外加一条斜率为 0 的线

## [Hypnos](https://xinyoudui.com/ac/contest/774001C4900048302954976/problem/4345)
朴素的$n^3log$做法并不能通过,发现 k 非常小,考虑将点从区域转换为 k 个通道
将每个通道看作一个点,求出从通道 i -> j 经过 z - 1 步的方案数,
然后枚举一下第一步和最后一步走的通道即可,
处理 $\le z$ 可以建立 k 个虚点,虚点只有入边和自环,没有出边,其进入虚点后代表了路径的结束

## [丛林宝藏](https://xinyoudui.com/ac/contest/774001C4900048302954976/problem/4378)
一道非常深刻的题目 
首先考虑暴力怎么做 ? **计算所有方案的贡献一个经典套路是记录方案数再算贡献**
此题通过枚举第一个取的数做到不重不漏
$f_u$表示第一个取 u 后的方案数,$g_u$ 表示第一个取 u 后所有方案的贡献和
$f_u = 1 + \sum_j f_j$ , $g_u = f_uv_u \sum_j g_u$ ,j 在子树 u 中且与 u 的距离 $\ge$ k
为了快速统计 j 的贡献,我们需要额外记录一维代表钥匙的状态,
而一个 j 会给所有的父亲都更新贡献,这样复杂度就爆了,
**给所有父亲做贡献,有是一个经典优化方式,记录一个全局变量,记录进入子树前的状态和出来后的状态,减一下就是子树的贡献**
更新时有 2 种方法 :
- 给 $key_u$ 加上贡献,算 $f_u$时枚举子集
- 给 $key_u$ 的所有超集加上贡献,算 $f_u$ 时直接得到答案
  
注意到两种方法一个在取得 f 的值时算,一个在更新贡献时算,
所以我们将两者结合,将时间均摊到修改和求得上,以获得更好的时间复杂度

具体而言,我们用 high 和 low 分别代表 $key_u$ 的高位和低位
算 f 时求 high 的所有子集 + low
加贡献时给 high + low的所有超集 加上贡献

对于这类指数复杂度的东西,想办法拆开高位和低位用 2 种方法分别统计贡献往往能得到更优秀的复杂度

## [[USACO21DEC] Tickets P](https://www.luogu.com.cn/problem/P7984)
首先肯定要线段树优化建图,
问题在于如何求 i - 1 和 n 两个终点的最短路径,
考虑路径一定是 i - k - 1 + k - n 两条路径的合并
朴素的想法是枚举中间点 k ,但这样时间复杂度爆炸了,
可以把每个点 i 的 dis 设为 dis(1,u) + dis(n,u) ,再跑一次最短路
因为 i - k 的路径 k 是直接 dis(1,k) + dis(n,k) ,
而对于不是直接两个相加的,一定来自某个 k 到此的最短路

## [PolandBall and Gifts](https://www.luogu.com.cn/problem/CF755F)
对于最多,直接贪心间隔的选即可
对于最少,贪心的选完整个环,最后只有一条链多出来,所以就变成了询问环的 siz 能否拼出 k
这是经典的 0/1 背包,注意到 $\sum w_i = n$,所以本质不同的 w 最多由 $\sqrt n$ 个,
所以只考虑本质不同的 w ,做分组多重背包 + bitset 优化即可

## [Swaps 2](https://atcoder.jp/contests/arc120/tasks/arc120_c)
手模发现结论若 $a_i + i = b_j + j$ ,i 放到 j 上就是合法方案,
问题变成了**最少交换次数排序好数组,就是逆序对个数**
一次交换只能减少一个逆序对,且由逆序对一定由相邻的大于,可以通过交换来减少,
或者可以用冒泡排序来理解

## [Pancakes](https://atcoder.jp/contests/arc119/tasks/arc119_e)
考虑交换 l - r ,相当于 $|x_i - y_i| + |x_j - y_j| \rightarrow |x_i - x_j| + |y_i - y_j|$
考虑二元组相当于一条线段,如果线段方向相同,其贡献就是 2倍的相交区间,否则无贡献
所以两个方向各求一遍交即可

## [[ABC221G] Jumping sequence](https://www.luogu.com.cn/problem/AT_abc221_g)
两维背包是很难得,考虑将 X 和 Y 分开考虑,
**将坐标轴旋转 45 度,每次往哪个方向走就不会影响另一个方向了**
**即旋转可以把4个方向改为两个维度的正负号**
所以就变成了 bitset 优化 0/1 背包,负号可以把等式两边同时加全部的和来消除

## [长门有希的序列](https://xinyoudui.com/ac/contest/774001C5F00048302972556/problem/4557)
考虑费马小，发现 $2^k \mod 998244352$存在循环节且非常小
所以用线段树维护循环数组即可
$998244352 = 2^23 \times 191$ ,所以循环节是 $\phi(191)$ 的一个因数,打表枚举一下即可

## [小D砍树(treecut)](https://xinyoudui.com/ac/contest/774001C5F00048302972556/problem/10218)
联通集合大小平方 -> 连接的点对数
**平方往往可以拆成枚举点对**
$$ans_i = \sum_{d = 0}^{n - 1} cnt_d \frac{(n - 1 - i)!(n - 1 -d)!}{(n - 1)!(n - 1 - i -d)!} = \frac{(n - 1 - i)!}{(n - 1)!} \sum_{d = 0}^{n - 1}cnt_d\frac{(n - 1 -d)!}{(n - 1 - i - d)!} $$
其中$cnd_d$表示路径长度为 d 的点对个数

**可以使用 ntt 优化枚举相乘和的式子** 构造两个东西使他们相加为定值即可
$f_d = cnt_d(n - 1 - d)! , g_{n - 1 - d - i} = \frac{1}{(n - 1 - i - d)!} , h = f * g$
$h_{n - 1 - i} = \sum_{d = 0}^{n - 1} \frac{(n - 1 - d)!}{(n - 1 - d - i)!} cnt_d$

对于路径长度为 d 的路径数,可以使用 点分治 + ntt 来做

## [序列 sequence](https://www.luogu.com.cn/problem/P4597)

## [涛涛的英语课](https://xinyoudui.com/ac/contest/774001C5B00048302A13486/problem/20442)
长度为 n 的本质不同的字符出最多只有 O(n) 个(由 PAM),
所以建立广义 PAM + 最短路即可
注意 PAM 代表的是先往上走后往下走的字符串

## [[APIO2016] 烟火表演](https://www.luogu.com.cn/problem/P3642)
$f_{ux}$ 表示子树 u 中所有叶子离 u 的距离为 x 的最小花费
合并子树 : $f_{ux} += MIN  f_{vy} + |y + w - x|,y \le x $
**f(x) 是一个凸函数,且由绝对值加起来得到,所以斜率是一点点变化的,可以记录拐点**
记 $x \in [L,R]$ 时函数取到最小值
$$f_{ux} += \begin{cases}
f_{vx} + w & x \le L \\
f_{vL} + w - x + L & L \le x \le L + w \\
f_{vL} & L + W \le x \le R + W  \\
f_{vL} + x - R - W & R + W \le x
\end{cases} $$
所以合并子树前对 v 的操错为 :
1.将 R 右侧的斜率变为 1
2.将拐点 L 和 R 向右平移 w
3.将 L - L + w 的斜率设置为 -1
对于拐点的操作即为 : 将 R 右侧的所有拐点删除,将 L 和 R 向右移动w

具体而言,叶子只有 L = R = 0
由于每个儿子只会带来一个斜率为 1 的直线,所以删除 儿子数 - 1 个点即可找到 R
最后知道f(0)的值,根据拐点递推即可

## [[THUPC 2023 初赛] 背包](https://www.luogu.com.cn/problem/P9140)
V 非常的大,对于后面的 V ,可以直接贪心的选单位价值最大的,因此考虑同余最短路
设单位价值最大的物品为 v 和 c, $V \mod v = r$,
$ans = \frac{(V - v_r) c}{v} + c_r \Rightarrow c_r - \frac{v_rc}{v} + \frac{Vc}{v} $
所以边权为 $c_j - \frac{v_jc}{v} $ ,
spfa 被卡,但 SLF 优化后可过,即每次和队首判断是否更小,更小即放在队首

**注意 : 同余最短路只有 V 大于 $nD^2$ 时才可以使用**,
否则有些同余点的 v 可能会超出 V . 其每个点仍然只经过一次,否则可被替换
如果要求 $ \le V$ , 可以增加价值为 0 ,体积为 1 的物品

此题还有严格 O(nD) 做法 : 
本质上我们是在跑模意义下的完全背包,而又知道一个点不可能经过两次,
所以绕着环转两圈就好了

## [[IOI2016] aliens](https://www.luogu.com.cn/problem/P5896)
要覆盖住点 (x,y) ,即要有一个正方形覆盖了区间 [x,y],
**所以转换为区间问题,考虑被包含的区间肯定不用考虑,只考虑左右端点各自递增的区间**
然后 wqs + 斜率优化即可

## [入侵者](https://xinyoudui.com/ac/contest/774001C6600048302A13106/problem/20421)
肯定是前面一部分都是胜利,后面都是失败,考虑前面胜利部分的特点 :
对于胜利的部分,记 $s_i$ 为 $\sum_{j < i} p_i$ , 则有 $h_i \ge s_{i - 1}$
希望只与 i 有关,则有 $l_i = h_i + p_i \ge s_i$
如果根据 $l_i$ 排序后放入无法放入全部,那么交换后必然也无法放入全部,
证明 : 如果一个较小的不合法 $l_i$ 往后调,其 $\sum s$ 不减,仍不合法,
把一个较大的不合法的 $l_i$ 往前调,其原来前一个位置肯定会变得不合法,
因为其$\sum s$ 变得和本来不合法的位置的一样了,但 $l_i$ 更小了
**写出前缀和的式子把下标调成相同后,分析交换时就可以利用同位置前缀和不变来做**

考虑 dp 求解 ,记 $f_i$ 为打败 i 个敌人后最小的 $\sum p$ ,
没加入一个敌人时二分一下暴力修改能做到 $n^2$ ,
显然$f_i$是个下凸包,可以维护凸包

## [大赛](https://xinyoudui.com/ac/contest/774001C6600048302A13106/problem/20422)
记录竞赛图结论 :
**竞赛图只知道出度即可得到整个图的结构** :
**连续的出度和 = $\frac{n(n - 1)}{2} + 该连通块连向后方点的边$ 为一个连通块**
用双指针求解即可

对于此题而言,可以3个2为偏序 - 2 * 3维偏序容斥一下得到出度即可

## [Points](https://codeforces.com/problemset/problem/1701/F)
考虑固定数时如何统计答案 ? 
对于一个数 x ,$[x + 1,x + d]$ 中有 $f_x$ 个数,
那么 x 的贡献为 : $\frac{(f_x - 1)f_x}{2} \Rightarrow \frac{(f_x^2 - f_x)}{2} $
考虑插入一个数对 $f_x$ 的贡献是 $[x - d,x - 1]$ 区间 + 1,与对 x 单点修改,
$(x + k)^2 = x^2 + 2kx + k^2$ , 所以我们需要维护 $f_x^2,f_x,f_x^0,特别定义0^0 = 1$ 

## [科研基地](https://xinyoudui.com/ac/contest/774001C6E00048302A27546/problem/20445)
选出一个连通块,使得未选择点的个数 $\le$ K,且连通块的边权和最小,
**对于选择连通块的问题,经典的dp状态是钦定联通块最浅的节点为 u**,
这样只需要考虑 u 子树内的点即可
剩下的转移类似树上背包

## [单调](https://xinyoudui.com/ac/contest/774001C7600048302BB32D6/problem/10175)
区间考虑线段树,单调栈的值还和时间有关,
但线段树关于时间有很好的性质,**由于每次修改前都会下传标记,因此标记的下传顺序就是该区间被更新的时间顺序**
考虑用数据结构在每个节点模拟单调栈,即要实现删除一个区间,将一段合并到另一端上去,
由于要让两个儿子都合并同一个区间,因此要用可持久化平衡树

注意点 : 
可持久化数据结构本质是每次给每个有改变的值的点新开一个,
因此要严格保证不会修改某个点的值,除非新开一个点在新的点上修改,
merge 和 split 要同时可持久化,否则会导致版本混乱

## [圣诞树装饰](https://xinyoudui.com/ac/contest/774001C6900048302BB35B6/problem/20465)
令 $f_{uk}$ 表示子树 u 中放了 k 个的平衡代价,dfs 即可,
每次都 / 2 ,类似于线段树,每个节点最多有 奇数 / 偶数两种情况,所以是 o(n) 的

## [[NOI2009] 管道取珠](https://www.luogu.com.cn/problem/P1758)
对于类似 $n^k$ 的式子,
**一个经典操作是将其拆为 $(a_1 + a_2 + a_3 + \dots)(b_1 + b_2 + b_3 + \dots)(\dots)$**
对于这道题而言,将其拆位 $(1 + 1 + ...)(1 + 1 + ...)$
其贡献即为有多少种方案对数,使得2种方案得到的序列是相同的,
$f_{l,a,b}$ 代表共放了 l 个球,
第一种方案中 A 放了前 a 个,第二种方案种 A 放了前 b 个,有多少种方案对数得到的答案相同

## [The Knapsack problem](https://codeforces.com/gym/101064/problem/L)
令 $f_i$ 表示容量为 i 的背包的最大价值,
**完全背包还有一种递推方式 : $f_i = max(f_k + f_j),k + j = i$**,即将两个包拼起来
由于可以将物品在两个包中调整,因此 $|k - j| \le D$,
因此 $f_x = max f_i + f_{x - i} ,i \in [\lceil \frac{x - D}{2} \rceil ,\lfloor \frac{x + D}{2} \rfloor ] $
显然 x - i 的取值范围与 i 相同,因为 $\frac{x}{2} - D \le \frac{x - D}{2} $,
因此记忆化后复杂度为 $D \log S$

## [主旋律](https://vjudge.net/contest/659866#problem/G)

## [The Great Wall](https://codeforces.com/gym/104022/problem/B)
极差取 max 满足平行四边形不等式,因此我们可以很快的写出 $n \log n$ 的做法,但难以进行下一步优化了
考虑极差的特点,其是区间内两数相减的最大值,而此题也要求求解区间极差和的最大值,
因此我们可以任意钦定某个区间的最大 / 小值,钦定错了一定不优,不会记录答案
令 $f_{i,j,0/1/2/3} $ 表示前 i 个数分成了 j 段,最后一段为钦定值,钦定了最大/小值,两个值都钦定了
$f_{i,j,0} = max f_{i - 1,j,0} , f_{i - 1,j - 1,3} $
$f_{i,j,1} = max f_{i - 1,j,0} - a[i] , f_{i - 1,j,1} , f_{i - 1,j - 1,3} - a[i] $
$f_{i,j,3} = max f_{i - 1,j,3},f_{i - 1,j,0},f_{i - 1,j - 1,3},f_{i - 1,j,1} + a[i],f_{i - 1,j,2} - a[i] $
**其核心在于求极差与求和的最大值都是取 max,因此我们任意钦定,钦定错了不会被记录答案**

## [[SDOI2014] LIS](https://www.luogu.com.cn/problem/P3308)
先考虑没有字典序的限制,
$f_i$表示 i 结尾的最长上升子序列长度,$f_i = max f_j + 1,j < i 且 a_j < a_i$
对 f 的转移建图,要破坏所有从最小的 f $\rightarrow$ 最大的 f 的路径,
拆点为边跑最小割即可
考虑字典序,我们要贪心的选取字典序最小的点,
**问题变为判定某条边在当前图中是否可作为最小割的一部分,结论是在残存网络中 u -> v 没有路径即可作为最小割一部分**
因为 u -> v 有路径的话将改变删去后整张网络的最大流并不会减少 w
然后将 u -> v 的流量推流即可,具体而言,就是 u -> S 跑 w 的流量,T -> v 跑 w

## [Ex - Shojin](https://atcoder.jp/contests/abc305/tasks/abc305_h)
wqs + dp

## [[ARC136F] Flip Cells](https://www.luogu.com.cn/problem/AT_arc136_f)
**对于以完成状态后就停止的问题,由于难以列出方程高斯消元,常常以生成函数为解**
令 $F[n]$ 表示从给定状态操作 n 次后到达一个满足条件的状态的概率(一直不停止)
$G[n]$ 表示从给定状态操作 n 次后恰第一次到达一个满足条件的状态的概率,
$H[n]$ 表示从任意一个满足条件的状态出发操作 n 次后在一个满足条件的状态的概率
$G * H = F$ , 即先从给定状态出发到达一个结束态后经过一下操作仍然在结束态
现在求期望,即求 $G'(1)$,因此只要求出 $F,H$ 都是永不停止的概率

由于该操作有先后顺序,需要使用 EGF , 先求解 $\hat{F} $
任意终态是比较难求解的,考虑钦定终态 $T_i$,再将所有终态的生成函数相加
$\hat{F_i}$ 表示对于终态 $T_i$ 的生成函数,假设 $T_i$ 相对于给定状态有 x 个格子改变了,
对于一个格子来说,$\hat{L_1}[n]$ 表示经过 n 次操作后改变值得生成函数,$\hat{L_0}[n] $ 不改变
$\hat{L_1} = \frac{x}{hw} + \frac{1}{3!}(\frac{x}{hw})^3 + \frac{1}{5!} (\frac{x}{hw})^5 + \dots = 0.5(e^{\frac{x}{hw}} - e^{\frac{-x}{hw}}) $
$\hat{L_0} = 0.5(e^{\frac{x}{hw}} + e^{\frac{-x}{hw}} ) $
$\hat{F_i} = (\hat{L_1})^x * (\hat{L_0})^{hw - x} $
发现$\hat{F_i}$ 只与 x 有关,因此可以先 dp 求出 $c_x$ 表示有多少个终态与给定状态相比满足有 x 个格子不同
$$\begin{aligned} 
\hat{F} & = \sum_{k \in [0,hw]} c_k * (\hat{L_1}^k * \hat{L_0}^{hw - k})\\
& = \sum_{k \in [0,hw]} \frac{c_k}{2^n}[\sum_{i = 0}^k {k \choose i}(-1)^{k - i} e^{\frac{2xi - kx}{n}} ][\sum_{i = 0}^{n - k} {n - k\choose i} e^{\frac{2xi + kx - nx}{n}} ]\\
& = \sum_{k \in [0,hw]} \frac{c_k}{2^n}\sum_{i = 0}^k \sum_{j = 0}^{n - k} {k \choose i}{n - k\choose j} (-1)^{k - i}e^{\frac{2(i + j)}{n}x - x}\\
\end{aligned} 
$$
其中 n = hw
对于 F 而言,只要将 $\hat{F}$ 中 $e^{px}$ 替换为 $\frac{1}{1 - px} $
对于 H 而言,只要再求一遍 dp 更换一下 $c_k$ 的值即可

## [[APIO2016] 划艇](https://www.luogu.com.cn/problem/P3643)
离散化后考虑上次游艇的数量落在一个区间内,记录第 j 个区间,
*离散化后为一些关键点,要用区间不重不漏的覆盖关键点可以令每个关键点代表了到下个关键点的**左闭右开**区间*
$f_{i,j,k} $ 表示最后一个是第 i 个游艇,放的游艇数量在区间 j 内,这个区间共有 k 个学校放了游艇
长度为 D 的区间内选 k 个递增的数方案数为 ${D\choose k} $,同时不同区间的答案合并遵循乘法原理
$$\begin{aligned}
f_{i,j,1} & = D \sum_{p < i,q < j,k \in Z} f_{p,q,k}\\
f_{i,j,k} &= \sum_{p < i} f_{p,j,k - 1} \frac{{D\choose k}}{{D\choose k - 1}} & k > 1
\end{aligned}$$
其中 D 为区间 j 的长度,前缀和一下可以做到 $n^3$

## [小 N 的独立集](https://www.luogu.com.cn/problem/P8352)
dp 套 dp 板,
考虑内部的判定dp,$f_{u,0/1}$ 表示 u 选/不选时子树 u 的最大独立集大小
$\begin{aligned}
f_{u,1} &= w + \sum f_{v,0}\\
f_{u,0} &= \sum Max f_{v,0} , f_{v,1}
\end{aligned}$
直接设计三维 dp 状态会 TLE , 注意到 $f_{u,1}$ 只有比 $f_{u,0}$ 大时才有用,且最多大 K,
所以令 $g_{u,x,dt} $ 表示 u 节点时,$f_{u,0}$ 为 x,$f_{u,1}$ 大 $dt$ 的方案数,
$$g_{u,x1 + x2 + dt2,dt1 - dt2} +=  g'_{u,x1,dt1} * g_{v,x2,dt2} $$

## [[TJOI2018] 游园会](https://www.luogu.com.cn/problem/P4590)
dp 套 dp 的一个典的将判定 dp 设计入计数 dp 状态的方式
先写出判定 dp 
$\begin{aligned}
f_{i,j} &= max f_{i,j - 1},f_{i - 1,j} & S_i \nq T_i \\
f_{i,j} &= f_{i - 1,j - 1} + 1 & S_i = T_i
\end{aligned} $
计数 dp[i][state][k] 表示 S 的第 i 位,记录了 $f_i$ 所有 j 的值的一个状态,末尾构成了 NOI 的前几个
由于 $f_{ij}$ 最大可以取到 15,显然不能直接记录每一位的值,
**由于在转移中相邻的 j 的 f 值最多相差 1 ,所以可以记录差分数组** ,这样只需要 $2^15$ 个状态即可

## [序列](https://xinyoudui.com/ac/contest/774001C7000048302BCB056/problem/20350)
最终串本质不同,先考虑如何判定,
对于一个最终序列,因为我们可以随意的删除数,
所以我们判定时一个个加入最终序列的每个数,贪心的找用从上个位置到新位置的数能异或出 x 的第一个位置即可,
考虑计数 dp ,用 $f_i$ 表示最终序列的最后一个数匹配到位置 i 的方案数,
考虑钦定给最终序列加入数 x ,那么 $f_i \rightarrow f_j$ , j 是用 [i + 1,j] 中的数能够异或出 x 的第一个位置,
因此$f_j += f_i * w$, w 为用 $[i + 1,j]$ 比 $[i + 1,j - 1]$ 能够多异或出的数的个数,
使用前缀异或线性基可以做到 $n \log n$
具体而言,从后往前预处理线性基得到 w

## [吞天得手](https://xinyoudui.com/ac/contest/774001C7000048302BCB056/problem/10226)
类似超级钢琴的套路,为了不重复的记录,额外记录一个 $[l,r]$ 表示从当前串能加的下一个字符的取值范围
选完 s + mid 后,剩下了 $s + c \in [l,mid - 1] $ , $s + c\in [mid + 1,r] $,$s + mid + c \in [mid + 1,n] $
问题来到了堆中快速比较两个串的字典序大小,这可以使用字典树求 lca 来做到(by __lyc__)

## [[CSP-S 2022] 星战](https://www.luogu.com.cn/problem/P8819)
题目要求出度均为 1 且从任何点出发都能到一个环里 , 第二个条件显然无用,
对于第一个条件,考虑 hash 维护,
给每个节点赋一个随机值,令边的权值为其入点的值,边权相加为点权和时就说明满足,
本质是一种集合 hash,即将出度都为 1 -> 边的入点集合 = 所有点集

## [BZOJ3569 DZY Loves Chinese II](https://www.luogu.com.cn/problem/P10778)
对边构造一种边权,使得跨过 u , v 的边异或和为 0 , 这个可以通过 dfs 树来做到,
然后询问删去边的权值能否异或出 0 即可

如果通过删除多条树边使中间的不连通,那么覆盖两条删除树边的剩余边集一定相同

## [Kazaee](https://codeforces.com/problemset/problem/1746/F)

## [fib](https://xinyoudui.com/ac/contest/774001C7F00048302BD8626/problem/10276)

## [路径](https://xinyoudui.com/ac/contest/774001C7F00048302BD8626/problem/4568)
要求 路径总长 / 点集方案数 , 分别 dp 求解,方案数直接在链顶统计答案即可,
路径总长分三种情况考虑 :
- 单个点的 :
在 u 时记录 u 向子树内的最长/次长路径和子树外到 u 的最长路径,经典换根 dp
- 先上去再下来
考虑点集的两个端点分别为 x / y,其 lca 为 u ,记$h_u$为 u 内最深节点的深度,$dep_u$ 为带权深度,$d_u$为结构深度,
则其贡献为 : 
$(h_x + h_y - 2 dep_u)2^{d_y + d_x - 2d_u - 1} \Rightarrow \\\frac{1}{2^{d_u} + 1}(h_x2^{d_x}2^{d_y} + h_y2^{d_y}2^{d_x} - 2dep_u2^{d_x}2^{d_y}) $
则记录$f_{u0}$ 表示 u 内 $2^{d_x} $ 的和,$f_{u1} $ 表示 u 内 $2^{d_x}h_x $ 的和,合并子树时求贡献即可
- 成祖先关系
类似转移即可

分析过程 :
一个点集选择哪条路径只与其两个端点的选择有关,所以我们先钦定选择的端点 x / y,
然后对端点不同的相对位置分别考虑贡献,
由于其是任意配对,所以可以在子树内相加, lca 处用相乘来合并子树信息

## [[_-0 C] 猜数](https://www.luogu.com.cn/problem/P9477)
假设最终答案是 v ,用 $p(v = x)$ 表示 v 是数 x 的概率,考虑一次交互对概率的影响,
假设该次交互为事件 A ,则
$p(v=x | A) = p(A | v=x) \frac{P(v = x)}{P(A)} $
虽然 $P(A)$ 我们并不会求,但由于其对每个 x 来说都是一样得,所以直接最后除掉使和为 1 即可
对于$P(A | v=x)$ , 假设 $A = <,a$ , 则
$P(A|v=x) = \begin{cases}
p & x < a \\
0 & x = a \\
1 - p & x > a
\end{cases}$
问题变为了如何选择 a 使得最终 $P(v = v)$ 的概率最大,
我们先不考虑 $\div P(A)$,只考虑乘法,最后全部 $\div \sum_x p(v = x) $,
考虑 $P(v = v)$ 的期望,每次选择有 p 的概率使其乘 p , (1 - p) 的概率使其乘 (1 - p)
**乘法无法运用期望的线性性,因此 ln 后变为加法** 
$E(\ln P(v = v)(不归约)) = q(p\ln p + (1 - p)\ln(1-p)) $
发现和选择的 a 的位置无关,因此我们只需要使 $\sum_x P(v = x)$ 最小即可,

较宽松的想法是找到使得返回 < 和 > 号后最终 sum 较大的那个最小的位置,即找到前缀概率为 0.5 的位置,
显然可以通过分析返回 < 或 > 号的概率得到更优的决策位置,但已经可以通过此题

正确性分析(以下全都是归约前的值) :
即最终的 $P(v = v) > 0.5 \sum_x P(v = x) $ 就能保证输出的是正确答案,

我们使用正态分布分析概率,即 $\ln 2 +\ln P(v = v) > \ln \sum_x P(v = x) $ 的概率
$\mu = E(\ln P(v = v)) =  q(p\ln p + (1 - p)\ln(1-p))$
$\begin{aligned} 
\sigma ^ 2 & = D(ln P(v = v)) \\
& = qE((\Delta x - E(\Delta x))^2)\\
& = \dots
\end{aligned}$
带入每个 subtask p 和 q,此处以最后一个 subtask 为例 :
$n = 10^{18},p = 49,q = 2.5 * 10^{5}$
由于 q 相较于 n 过小,可直接看做没有值变为 0 ,
则  阿爸阿爸,算不出来
算一下差值是几倍 $\sigma$ 即可

代码实现 : 
这题要实现一个有初始值的动态开点线段树,同时过大的乘除范围有不能标记永久化,
每次 pushodwn 时检查一下是否有左右儿子,没有就先按照初值建立再 pushdown 即可

## [[JSOI2016] 独特的树叶](https://www.luogu.com.cn/problem/P4323)
树 hash 除了钦定 重心/中心为根 , **求出以每个节点为根的hash也是一种思路**
具体而言,先求出以 1 为根的 hash,然后跑换根 dp,
$f_u = xorshift(\sum f_v + 1)$ , 换根往v走时父亲的子树求 $\sum$ 时减掉 v 就行了

## [[LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)
如何快速算 x 和多个点的 lca 的 dep 呢 ? 
**lca 可以看作其共同的祖先,将深度的贡献拆到每个祖先上**,
 $dep[lca(x,y)]$ 可以看作将 x 及其所有祖先 + 1后询问 1 - y 的权值和,
要询问 x 和 $[1,u]$ 的 lca 的 dep 和将 $[1,u]$ 每个点及其祖先 + 1 后询问 1 - x 的权值即可
对于询问区间 $[l,r]$ 询问离线下来做个差分就可以了

## [[✗✓OI R1] 左方之地](https://www.luogu.com.cn/problem/P7949)
非常妙的构造题,
可以看作每次下一个数都是由上一个 异或 一个 popcount 为 k 的数得到的 , 
因此判断有无解可以看只用 popcount 为 k 的数是否能够异或出所有数来,这可以用线性基做到,
得到线性基后构造解可以使用格雷码,某位为 1 的就异或上线性基的该位数,
由于格雷码保证了相邻两数只差一位,这样保证了相邻数异或一个 popcount 为 k 的数得到

格雷码 : n = 1 为 0/1,每次加一个位就是先加前导 0 ,然后加前导 1 倒着写一遍,
如 n = 2 位 00,01,11,10

## [仓鼠找sugar II](https://www.luogu.com.cn/problem/P3412)

## [[CSP-S 2023] 消消乐](https://www.luogu.com.cn/problem/P9753)
一档裆部分分考虑 :
- 35pts : 考虑某个区间可消除,说明其可以表示为 AB 或 cAc , 其中 A/B 为可消除的序列,直接区间 dp 即可
- 50pts : 
从前往后加入字符,看当前区间是否可删除,我们直接贪心的与之前未消除的消除即可,
证明 : 
唯一可能出错的是 cAc 的形式,如果到第二个 c 时开头的 c 已经被消掉了,那么 A = DcBcE,依然可用上述方式消除
直接用栈模拟为 $n^2$ 的
- 100pts : 
快速模拟栈的做法,
队点 i,如果找到了最短的可消除序列 $[g_i,i]$,那么以 i 结尾的所有可消除序列都可表示为 A + $[g_i,i]$
所以令 $f_i$ 表示以 i 结尾的可消除序列的个数,则 $f_i = f_{g_i - 1} + 1$,
最短的可消除序列一定可以表示为 cAc 的形式,直接暴力跳 $g_i$ 即可,
因为 $g_i$ 最多增加 n 次,而每次跳都会使其减少,所以时间 $O(n)$

## [已经没有什么好害怕的了](https://www.luogu.com.cn/problem/P4859)
显然先给 a , b 排个序
定义 $f_{i,j}$ 表示前 i 个中恰有 j 个 a > b 的方案数,
$$\begin{cases}
f_{i,j} * (还未选的 < a_{i + 1} 的b的个数) \Rightarrow f_{i + 1,j + 1}
f_{i,j} * (还未选的 > a_{i + 1} 的b的个数) \Rightarrow f_{i + 1,j}
\end{cases}$$
但显然,我们并不知道还有多少个未选的 $< a_{i + 1}$ 的 b 的个数,要知道我们需要记录每个数是否被配对,显然不太现实,
考虑我们能够快速求出什么 ? $h_i$ 为 < $a_i$ 的 b 的个数,
由于从小到大,我们能够知道当前未选的 $< a_{i + 1}$ 的 b 的个数在所有方案中**最多**只有 $h_{i + 1} - j$ 个,
这启示我们可以考虑求出至少有 j 个 a > b 的方案数 , 然后在二项式反演回去 ,
设 $f_{i,j}$ 表示

## [书店](https://xinyoudui.com/ac/contest/774001C9500048302C6A6C6/problem/19272)
比较显而易见的是,对于一个偶环,其交替染色就可以了,考虑奇环的情况,
如果一个连通块内只有一个基环,那么其肯定是不行的,因为其形成一颗基环树,要选树边的话叶子一定无法满足,
而如果有两个及以上的奇环,任选两个基环,在其上面和连接他们的链上交替染色也是可以的.

问题来到如何找环,无向图的环比较套路的先搞出 dfs 树,然后进行分讨 :
- 返祖边直接形成了偶环
- 返祖边全都是奇环 , 先任选两个环 xd,xu,yd,yu , 令 k = lca(xd,yd)
   - 两条环直接由嵌套关系,由于 奇 + 奇 - 2 * x = 偶数 , 
   所以直接 xd - k - yd - yu - xu - xd 的偶环即可
   - 无嵌套关系,分成两环都在 lca 之下或 lca 在一个环上分讨即可

## [卡萨内](https://xinyoudui.com/ac/contest/774001C9500048302C6A6C6/problem/19273)
这道题是一个经典套路的小修改 ,
**经典套路** : 
要求解形如 A...A(k 个A) 的字串个数,
考虑区间第一个 A 的起始位置 i 和第二个 A 的起始位置 j ,只要满足$lcp([i,n],[j,n]) \ge (k-1)(j - i) $ 即可,
起始这就是区间的定义形式,即 $str_i = str_{i + T} $

对于这道题而言,求解 ABABAB...AB , B = rev(A) , 的形式,可以考虑用中间的位置来限制,
记 $f_i$ 为最长的 $[i - f_i + 1,i] = [i + 1,i + f_i] $ , 
对 k 为奇数的情况,令第 k / 2 个结束位置为 i , 第 k / 2 + 1 个结束位置为 j,
只要满足 $\begin{cases} f_i \ge \lfloor \frac{k}{2} \rfloor (j - i) \\ f_j \ge \lfloor \frac{k}{2} \rfloor (j - i)\end{cases}$
化简使得等式一遍只与 j 有关,枚举 i ,跑二维数点即可
对于 k 为偶数稍作修改即可

## [淀粉](https://xinyoudui.com/ac/contest/774001C9500048302C6A6C6/problem/19274)
考虑我们已经确定了 T2 的根, T2 为 T1 的点分数的充要条件为
对于 T2 中每一条 $u \rightarrow v$ , u 为 v 的父亲的边,其要满足 T1 中 u 连接了一个 T2 中 v 的子树中的点.
即确定 T2 的根后, T2 中的每条边限制变为了 T1 中某个点的边连向的点要有属于一个区间的点,且区间不交,
而 T1 每次修改显然最多满足一条边的限制,
所以只要看一下 T2 中有多少个不满足限制的边即可,这个可以给 T1 的边排个序用二分做,
然后选根就是简单的换根 dp ,因为每次只会改变一条边的父子关系

## [曼哈顿距离](https://xinyoudui.com/ac/contest/774001C9200048302C709C6/problem/20488)
今天太困了 , 受不了了 , 先记一下思路 , 之后再写代码 ~~~~~~~
考虑到距离应该是一个类似背包的东西,
记 $f_{T,i,d}$ 表示点 i 与所有 $[T,n - 1]$ 位相同距离为的 d 的点的权值和

## [Fair Elevator](https://atcoder.jp/contests/arc104/tasks/arc104_c)
钦定出每个人的方案过于困难 , 考虑观察最终的情形是怎么样的 , 
发现其必然是一些小块构成,每个小块都是连续的向后距离相同的连边 , 启示我们进行区间 dp ,
考虑初值要看一个块是否能构成最小的合法的块,限制就是某个点上电梯的人其一定在对应的点下,
看该点是否被占用或合法即可

## [Multiset Mean](https://atcoder.jp/contests/arc104/tasks/arc104_d?lang=en)
首先平均值的经典操作 , 要让平均值为 x , 直接给每个数 - x 即可,然后就是求分组背包使得和为 0,
显然单次是易于做到 $n^4$ 的,改变平均值有两种做法 
- 注意到改变平均值时只是删除了一个数,新增了一个数,所以直接运用退背包的技巧即可
- 可以按照 0 分成两半,绝对值相同,预处理 $[1,i]$ 能表示出数的方案数即可

## [Random LIS](https://atcoder.jp/contests/arc104/tasks/arc104_e)
由于 n 非常小 , 不难想到直接爆搜每个数的相对大小关系 , 
然后直接就变成了选出几个不同的递增的数,每个数值域为 $[1,lim_i]$ , 直接套用划艇模板即可,
即记录最后所在区间,最后区间有几个数

## [Alice and Recoloring 2](https://codeforces.com/problemset/problem/1592/F2)
人类智慧( 或二维方格异或的套路题 ?)
首先显然只有左上角和右下角有意义,其他都可以表示为这两个,
如果我们令 $b_{i,j} = a_{i,j} \oplus a_{i + 1,j} \oplus a_{i,j + 1} \oplus a_{i + 1,j + 1} $,
那么对于修改左上角的一个矩形 $(1,1) - (i,j)$ , 只有 $b_{i,j} $ 会被改变,其他的 b 都有偶数个位置在矩形内,因此值不会改变,
对于修改右下角的矩形 $(i,j) - (n,m)$ , 只有 $b_{i - 1,j - 1} , b_{i - 1,m} , b_{n,j - 1},b_{n,m}$ 会被改变,
同时 a 数组全为 0 的充要条件是 b 数组全为 0 ,
因此我们考虑修改 b 数组,就是找到 (i,j) , (i,m) , (n,j) 三个点的配对,可以 i 向 j 连边,跑二分图匹配即可

## [Utakotoba](https://codeforces.com/gym/105423/problem/G)
通过异或来表示数,我们可以考虑建立异或线性基,
发现操作是可逆的,所以只要我们将 a,b 表示成相同的线性基再倒着输出 b 即可,
先贪心的构造线性基,然后考虑如何将两个线性基转变成每个数相同,
我们可以做求 最/第k大值 时对线性基的调整,使每个为 1 的位其他数该位都是 0,
这样显然能得到唯一对应线性基 (本质是高斯消元)

## [[AHOI2022] 山河重整](https://www.luogu.com.cn/problem/P8340)
考虑从小到大向集合中加数 , 
我们会发现如果要用 $[1,n]$ 中的子集表示出数 $[1,n]$ ,
那么其能且仅能表示出一个前缀 $[1,p]$ ,
证明 : 归纳法 , 假设我们能够表示出前缀 $[1,p]$ , 其中 $p < n$
现在要通过加入 x 来拓展这个前缀,则能表示出的数变为 $[1,p] \cup [x,p + x]$ ,
如果 $x > p + 1$ ,那么之后 x 更大 , p + 1 将会永远无法被表示,因此我们一定有 $x \le p + 1$,
而如果此时 $p \ge n$ 了,那么我们再加入一个 x ,能够表示出的数显然还是一个前缀

所以能够写出简单的 $n^2$ dp , $dp_{i,j}$ 表示前 i 个数能够表示出前缀 $[1,j]$ 的方案数
难以进一步优化,正难则反,考虑求解不合法的方案数

如果一个方案不合法,其无法表示 $[1,n]$ 中的某些数,我们枚举其无法表示的 $[1,n]$ 中的第一个数
用 $f_i$ 表示用 $[1,i]$ 表示出前 i 个数且第 i + 1 个数无法被表示的方案数 (由性质,后面所有数都无法被表示)
只使用 $[1,i]$ 中的数可以将问题简化为后面的数都无法表示,因此拥有良好性质,即数集的和恰为 i
$ans = 2^{n} - f_{i} 2^{n - i - 1} $
$2^{n - i - 1}$ 即考虑放 $[i + 1,n]$ 中的数,i + 1 不可以放,剩下的数随便放都能让 i + 1 无法表示

求解 $f_i$ 依旧使用容斥,令 $g_i$ 表示 $[1,i]$ 的数某个子集和为 $i$ 的方案数,
$f_i = g_i - \sum_{j} f_j h_{i,j} $
其中 $h_{i,j}$ 表示用 $[j + 2,i]$ 中的数选出一个子集其和为 $i - j$ 的方案数

我们先考虑求解 $g_i$ , **拆分数问题等求和类使用 Ferrers图像** ,
即先每列都是不用的数,且列的长度单调递减,然后我们从行的方向来看图像,
其行上的限制为
- 其一行的长度最长为 $\sqrt n$
- 某行较上一行长度要么不变要么减 1
- 最后一行的长度一定是 1

我们考虑从长向短枚举长度 , $g_{len,i}$ 表示最后一行长度为 len , 大小为 i 的方案数,
1. 将上一行比 len 长的接上去 $g'_{len,i} = g_{len + 1,i + len}$ , 注意接一段空(即改行为开头)
2. 重复长度为 len 的行数,即做一个完全背包 $g_{len,i} = g'_{len,i} + g'_{len,i - len} + g'_{len,i - 2len} + g'_{len,i - 3len} + \dots $

然后我们要求 $H_i = \sum_{j \le i} h(i,j)f_j $
考虑求解 $h(i,j)$ , 画出矩形后将上面的矩形给去掉,
类似于求 g 的做法 , 将接一个空段的坐标变为 $(j + 2) len $ , 
然后求解 $H_i$ 时如果要枚举 j 我们就超时了 , 
接下来我们要用**一个没有对应的现实意义但能够保证结果正确的数学技巧**,
注意到我们进行 dp 的过程时纯线性的,且不同的 j 是互不影响的,所以我们在每次赋初值时枚举 j 赋予 f_j 即可,
类似于 $f_j(a +  b + c + \dots) = f_ja + f_jb + f_jc + \dots$ , 
又因为纯线性,我给某个地方加上 j2 的贡献时并不会造成 j1 的贡献改变 (未出现 $f_j^2$ 有关的式子),
或者可以把纯线性的 dp 式看作一个矩阵映射,
即输入是一个 n 个元素的向量(初值) , dp式是一个矩阵映射,最终得到的也是一个 m 个元素的结果向量,
那么我们要将多个初值向量的结果向量对应值相加,由矩阵乘法对加法的分配律,直接在初值向量处相加即可

现在唯一的问题是 f 和 h 互相需要怎么办,注意到 $h(i,j) > 0$ 要求 $j \le \lfloor \frac{i}{2} \rfloor $ , 
所以倍增的求 f 即可,先求出 $[1,mid]$ 的 f ,根据其求出 $[mid + 1,n]$ 的 h , 从而求出这部分的 f

## [[NOI Online #1 入门组] 跑步](https://www.luogu.com.cn/problem/P6189)
分拆数依旧画出 Ferrers图像 , 但直接对行进行 dp 由问题,因为数可能个数非常多,
考虑到数较大时其总个数就会很小,所以我们在数很小时对列进行 dp 考虑,数大时对行进行 dp,
$\le \sqrt n$ 时对列 dp , 否则对行 dp , 此时行最长为 $\sqrt n$ 个数,
最后合并一下答案

## [[GXOI/GZOI2019] 旅行者](https://www.luogu.com.cn/problem/P5304)
**经典的每对数最值的套路题**
**要处理一个集合内两两对的每一对最值,一个经典套路是枚举每位,将这位为 1/0 分到两组里**,
这样每对数都会至少一次被分到两个不同组中,
队医此题而言,分组后建立源点和汇点,源点向一个组的点连0边,另一个组向汇点连0边跑最短路即可,
由于是有向图,所以每次要源点汇点互换跑两次

## [Next or Nextnext](https://atcoder.jp/contests/agc008/tasks/agc008_e)
超级大分讨题,之后再补😒

## [[GXOI/GZOI2019] 旧词](https://www.luogu.com.cn/problem/P5305)
经典套路题,将深度的贡献到每一个点上,区别只是差分一下就可以了,
把询问离线下来扫描线即可

## [HolyK's Land](https://codeforces.com/gym/105423/problem/B)
对于询问用区间的链,套路的将询问离线,然后扫描线,从前往后加链,
问题转换为了将一个链及距离这个链 $\le 1$ 的点染色,
考虑树剖,设计一种适应这道题的染色方式,
具体而言,先给遍历到一个点时先给轻儿子编号,再给重儿子编号,向重儿子递归,
这样标号就能使得每个重链除了链顶的dfn,其他链的一部分及其儿子是一个区间,
因此调链时特判一下链顶,就只要修改 log n 个区间的颜色了,
对于区间染色可以使用珂朵莉树来做,时间复杂度为 $n log^2 n$
由于这里**珂朵莉树每次访问后区间后都会推平,所以不用均摊,时严格 log n 的**

## [Unordered Swaps](https://codeforces.com/problemset/problem/1682/E)

## [序列](https://xinyoudui.com/ac/contest/777001C8100052502C07C76/problem/19293)
考虑 50 pts 的暴力 , 先将 a / b 拍个序
显然最终 $\sum a_i$ 都是相同的,所以最终 $\sum b_{p_i} - a_i$ 只与 b 的和有关,
$f_{i,j,k}$ 表示配对了 i 个 a , 考虑了 b 的前 j 个数 , b 的和为 k 的方案数, $h_j$ 表示 a 中 $\le b_j$ 的个数 
- $b_j$ 配对了 , $f_{i,j - 1,k} * (h_j - i) \rightarrow f_{i,j,(k + b_j) \mod M} $
- $b_j$ 未配对 , $f_{i,j - 1,k} \rightarrow f_{i,j,k} $

考虑到 $\mod 2$ 的条件还没有用到,考虑如何运用 ? 我们可以考虑将一些 b 的和相同的方案配对就不用算这些方案的贡献
我们发现与 $a_i$ 配对的 b 的值一定 $< a_{i + 1}$ , 
否则我们将$a_i$ 和 $a_{i + 1}$ 配对的数交换一定合法,
如果对于有 $a_i$ 配对的数 $> a_{i + 1}$ 的方案,我们就将其和交换最后一个不满足该条件的 $a_i$ 和  $a_{i + 1}$ 的方案配对,
我们发现每个不满足该条件的方案经过一个上述变化能得到一个 b 的和相同的方案,再变换一次能得到原方案,
即每个不满足该条件的方案都有个与之对应的方案和他消掉贡献了,贡献为 0
我们对每个 $a_i$ 只要考虑和 $a_i \le b_j < a_{i + 1}$ 的配对即可,
那就是一个背包,bitset优化一下即可

## [失落的圣剑](https://xinyoudui.com/ac/contest/777001C8100052502C07C76/problem/19294)
求解$\prod_{i \le n} \prod_{j \le n} \phi(ij)$
对其暴力拆开
$phi_{ab} = ab\prod_{p | ab,p 是质数} (1 - \frac{1}{p}) $
那么我们将 ab 和后面那个分开求解 , ab非常好求,后面那个可以使用容斥,
我们枚举 p ,然后乘 p 是 a 的因数的数对,是 b 的因数的数对,除以同时是 ab 因数的数对
即 $\prod_{p} \prod_{i\le n}\prod_{j\le m} (1-\frac{1}{p})^{\lfloor \frac{n}{p}\rfloor m + \lfloor\frac{m}{p}\rfloor n - \lfloor\frac{n}{p}\rfloor \lfloor \frac{m}{p}\rfloor } $
用整除分块求一下即可,可以做到 $O(T V \sqrt{V} \log V)$
**快速求模意义下的次方,可以使用原根**,
具体而言,设 g 是原根,预处理出 $a = g^i$ , 则 $a^k = g^{ik}$,直接预处理 g 的幂次即可
但是 O(T V \sqrt{V}) 仍然不够 , 
注意到只有质数处有值,当值较小时整除分块每块比较小,不够优秀,所以我们值域分块,
$< B$ 的位置枚举质数,$> B$ 的位置整除分块
对于从 B 开始的整除分块,显然其剩余的商的个数 $< \frac{n}{B}$ , 所以复杂度上界为 \frac{n}{B}$,
前半部分就是 $\frac{B}{\ln B}$ , 平衡一下 , $B = \sqrt {n \ln n}$ ,
最终复杂度就是 $O(T \sqrt{\frac{n}{\ln n}} ) $

## [Perishable Roads](https://codeforces.com/problemset/problem/773/D)

## [Adjacent XOR](https://atcoder.jp/contests/arc145/tasks/arc145_e)
**关键是用线性基换基后每一位第一次为 1 的位置互不相同,且为这一位第一插入成功的位置**

## [[AH2017/HNOI2017] 礼物](https://www.luogu.com.cn/problem/P3723)
考虑我们已经选好了对应关系时如何确定增加量 x,要最小化
$ nx^2 + 2x(\sum_i a_i - b_i) + \sum_i (a_i + x - b_i)^2 = \sum_i a_i^2 + b_i^2 + 2a_ib_i $
显然,只要最大化 $\sum a_ib_i$ 即可,
**对于类似$\sum a_ib_i$ 的东西,有经典处理套路,将 a 翻转后变为$\sum_{n - i + 1}a_i b_i$,就变成了卷积形式**,
因此我们翻转 a 数组后倍增一次a数组,然后求 $a * b$,取后 n 项的最大值即为 $\sum a_ib_i$ 的最大值

## [[SDOI2015] 序列统计](https://www.luogu.com.cn/problem/P3321)
对于乘积形式不太好处理,转换为加法的经典方式是取个 log,这样就可以使用多项式等许多工具
**而模意义下的log可以使用原根为底即可**,
然后此题就变成了 ntt 模板

## [[ZJOI2016] 小星星](https://www.luogu.com.cn/problem/P3349)

## [ [国家集训队] 阿狸和桃子的游戏](https://www.luogu.com.cn/problem/P4643)
考虑没有边直接贪心选就行了,
然后考虑某个边的贡献,将这个边拆分到2个点上,
如果这两个点被同一个人选了,则贡献会相加是正确的,
如果被2个不同的人选了,则贡献相减刚好抵消,所以就转换为了只有点的情况

## [[COCI2017-2018#4] Ceste](https://www.luogu.com.cn/problem/P4524)
**对于有两个量的东西,一个套路的想法是将其放到直角坐标系上考虑**,
我们发现对于一个点来说,可能是答案的 $\sum x $ 和 $\sum y$ 一定是在第一象限构成了一个下凸包,
所以我们枚举每个点看他们的最小值即可,问题是如何控制当前选择了那个点,
可以给 y 乘上系数 k , 然后跑最短路,感性理解, k 小时得到的点会靠近 y 轴,k 大时会靠近 x 轴,
但我们显然不能枚举实数,考虑枚举哪些会改变至少一个点的路径的 k 的值,
如果又至少一个点的路径被改变了,由于起点不变,所以一定有一条边,其出发点的路径未变,到达点的路径改变了,
即 $$X_u + x_e + k'(Y_u + y_e) < X_v + k' Y_v $$ , 解出 k' 即可,
因为一条边改变了 $k'$ 后,这条边之后就不会改变 k' 了,
感性理解,因为 u 和 v 的大小关系都反向了, 且只会反向一次,不可能再返回来
所以最终只会 $m$ 次更新 k 

## [前缀](https://xinyoudui.com/ac/contest/777001C8E00052502C07D96/problem/19276)
交的是乱搞做法,能被卡掉,记录一下正解
考虑 $f_{i,j}$ 表示填完了 b 的前 i 位,其后缀和 a 的lcp 为 j 的答案,
$f_{i,j} + h_k \Rightarrow f_{i + 1,k}$ ,显然 k 是 board 树上 j 的祖先们的下一个点,
因此每次转移时是对子树中的取 max,显然可以前缀和优化,就能做到严格 $O(nm)$
**前缀和可能用 board 树,字典树等各种结构来辅助优化**

## [两条](https://xinyoudui.com/ac/contest/777001C8E00052502C07D96/problem/19277)
显然要倒着做来加边,
如果两个点在同一棵树内,那么就是做链覆盖,然后被覆盖到的点合成一个点,最后询问的在一个点内就行了,
显然用并查集想父亲合并可以做到 $O(n)$ ,
问题是如果两边不在同一棵树内怎么办 ? 直接启发式合并,重构小的树可以做到 $n \log n$,
另一个想法对于要后面加入的连接两棵树的边我们先用虚边连起来就行了,**相当于由于离线,我们可以提前构造好结构,**
这样就是严格 O(n) 了 远古密码

## [Turtle and Three Sequences](https://codeforces.com/problemset/problem/2003/F)
考虑没有 b 的限制是非常好做的,$f_{i,j}$ 表示前 i 个选了 j 个的最大值,对于 a 的限制用树状数组优化一下转移即可,
如果 b 的值域只有 k 也是好做的,把 j 改为一个 bitmask 记录选用了哪些 b 同样转移即可,
但 b 非常大,此时一个经典的套路是随机把大的值域随机映射到小值域上,这样可以获得一定的正确性,然后多做几次,
对于一个正解,其 k 个数被分到不同的数的概率为 $\frac{k!}{k^k}$ , 正确率约为 0.038,
做 200 次就可以达到 0.9996 的正确性,已经可以通过

随机化设计时我们想办法令不合法的仍旧不合法,合法的有可能合法就行,就算可能性极低,做几百次也能达到可观的水平

## [LCM Sum (hard version)](https://codeforces.com/problemset/problem/1712/E2)
显然不合法的方案比较少,且约束性很强,我们统计不合法的方案数,
不妨令 $\lcm (i,j,k) = x \Rightarrow i = \frac{x}{a} , j = \frac{x}{b} , k = \frac{x}{c} $,
则限制变为 $\gcd(a,b,c) = 1, a > b > c , \frac{1}{a} + \frac{1}{b} + \frac{1}{c} > 1 $
分类讨论一下
1. $c = 1$ , 则要求 i , j 是 k 的因子即可
2. $c \neq 1$ , 则 c 必须为 2 , 否则 $ \frac{1}{a} + \frac{1}{b} + \frac{1}{c} $ 一定达不到 1 ,
继续按照这个分析,我们就能得到 $b = 3,c = 2,a = 4 / 5 \Rightarrow i : j : k = 3 : 5 : 6 或 6 : 10 : 15 $
后面能够很好维护,设 $i = 3v / 6v$ , 然后分别计算一下 v 的范围就行了,

重点是 $c = 1$ 的情况,
枚举因子很难,考虑枚举倍数,对每个 i 枚举其倍数 k ,那么只要区间包含了 i,k 就会产生 $j\in (i,k) 且 j | k$ 的贡献,
统计 j 的个数,只要倒序枚举 i 即可,对于多测,只要离线扫描线即可
最终由于有 $n \log$ 个点,因此复杂度为 $n \log^2 n$

## [XOR Tree](https://atcoder.jp/contests/apc001/tasks/apc001_f)

## [[ZJOI2008] 泡泡堂](https://www.luogu.com.cn/problem/P2587)
**遇到这种题一定要写个暴力程序然后对拍 !!!**
这题是典中典田忌赛马,先考率实力高的马
- 如果最快的马比对方的马快 , 那直接赢了即可
- 否则考虑最慢的马和对方最慢的马
    - 如果最慢的马和对方最慢的马可能平局,那么看最快的马和最慢的马相同,
    相同就让 2 个人都平局就行了,否则让最慢的马换掉对方的快马,这样我最快的马最劣还能赢对面最慢的马,不会更劣
    - 不能平局直接让最慢的马兑掉对面最快的马就行了

## [划分数字](https://qoj.ac/contest/1831/problem/9585)
复习一下数位 dp 的写法,~~虽然好像之前也不会~~.
一个数做出贡献时说明其前半部分的数位和到了总数位和的一半,那么枚举前后两位取最小即可,
同时我们直到 18 位数的数位和最大也只有 162 , 
所以直接把总的数位和,当前填入的数位和计入状态即可,统计时枚举总数位和,

方便可以深搜统计答案
**套路写出参数 $calc_f(int x,int s,int t,bool lim,bool start)$**,
代表当前在填 f 的第 x 位,总的数位和为 s ,已经填好的数位和为 t , 之前填入是否紧贴上界,第 x 位是否是第一位(之前填的全是前导 0)
其中 **x,lim,start** , 都是套路的,而 **s,t** 则根据题目需要自行更改,
做出贡献后显然后面就是随便填,只要求数位和位 s - t - d 即可,
所以我们还需要一个 $calc_g(int x,int s,bool lim)$ 代表当前填第 x 位,后面数位和要求位 s , 是否紧贴上界,

数位 dp 深搜写法要非常注意边界条件 , 
如此题中如果只有两位不管有没有到一半都要立刻分开 , f 如果 x 只有 1 位是没有方案的 等

## [XOR Replace](https://atcoder.jp/contests/agc016/tasks/agc016_d)
考虑将 x 替换为全局异或和后新的全局异或和变为 x , 
因此这个题本质上就是我们手上有一个数 x , 不断的用手上的数和数组中的数交换,直到数组中的数变为目标数组,
因此判断无解只要看 a 和 a 的全局异或和构成的多重集是否和 b的 完全一样即可,
考虑构造最小解,**由于数组中有很多重复的数,一个套路的方式是对值域上的数来考虑**,
观察手上的数,每次交换是存在一个 i,手上的数本来是$b_i$ , 变为 $a_i$,
我们可以对值域上的 $b_i$ 想 $a_i$ 连边,那么只要找到一条从 a 的全局异或和出发的欧拉路径即可,
显然除了全局异或和,其他数出度和入度相同,所以肯定是可以找到的,
对于手上的数不在的连通块中,交换一次就可以把手上的数放进去
因此最终就是 不同的数对 + 连通块个数 - [a的全局异或和不为孤立点]

## [[蓝桥杯 2013 省 B] 连号区间数](https://www.luogu.com.cn/problem/P8600)
区间内每个数互不相同是排列的重要性质之一,因此排列的某个区间 max - min >= r - l,
而重排后连号的就是 $max - min = r - l \Rightarrow max - min + l = r $,
因此我们可以扫描线r,用线段树维护 $max - min + l$ 的最小值和最小值个数,
每加一个数 max 和 min 的变化情况可以用单调栈来维护

## [ [USACO22OPEN] Up Down Subsequence P](https://www.luogu.com.cn/problem/P8277)
直接贪心的找下一个最近的满足条件的显然是不行的,这在全是 U , 即 LIS 时都会出问题,
但我们发现在 UD 切换时这个贪心是可行的 , 
现在前面是 U , 后面是 x 个 D , 
我们先找到能满足前面 U 的最小位置 k ,然后再 $[k,n]$ 中找最近的长为 [x + 1] 的LDS 即可,
如果因为 k 过于近而导致 $a_k$ 不够大,没有长 x + 1 的LDS,
直接用我们找出来的 LDS 第一位换掉 k 即可,与其肯定更大,依然合法

## [[ZJOI2022] 众数](https://www.luogu.com.cn/problem/P8330)
考虑钦定众数为 x , 另一个颜色为 y ,那么最终答案为 x 的个数 + 将 x 为 -1 , y 为 +1 的最大字段和
对值域分块后,如果 $cnt_x > \sqrt n$ , 那么直接 $O(n)$ 暴力求最大的 y , 
同样,枚举另一个颜色 y , x为 1,y为 -1 求最大字段和就处理了钦定众数的 x 为较小的次数 , y次数较大的情况,
现在只要处理 x 和 y 的出现次数都 $< \sqrt n$ 的情况,
枚举颜色 x 时,最大子段和的区间一定左右端点一定在 x 旁边,所以我们之间枚举 x 的所有区间,
极限情况,由于 $\sum cnt_x = n$ , $cnt_x$一样大时取到最值,即 $\sqrt n * \sqrt n^2 = O(n \sqrt n)$,
问题在于要 O(n) 求一个区间的众数,但我们只要考虑出现次数 $< \sqrt n$ 的数,即众数出现次数 $< \sqrt n$
我们可以预处理 $f_{i,j}$ 表示从 i 开始众数出现了 j 次的最左端的坐标,这个用每个颜色暴力更新即可,
然后双指针即可求解

## [[ZJOI2007] 捉迷藏](https://www.luogu.com.cn/problem/P2056)
点分树 / 点集直径的合并

## [[WC2011] 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)
因为异或的性质,如果路径从点u 走回 点u , 其有贡献当且仅当中间走了一个环出来,
因此最终 $u \rightarrow v$ , 就是一条简单路径异或上任意位置的简单环(走过去再原路走回来),
启示我们把所有简单环的异或和放到一个线性基里,
查询时任意找到一条 $u \rightarrow v$ 的简单路径(有多条会形成环,再后面的查询环中能被替换),
然后放到线性基里查询能异或出的最大值即可
对于找环,可以用 dfs 树来找,只要找一个非树边形成的环即可,显然多个非树边形成的环可以被若干个一个非树边的环表示出来

## [强力胶](https://xinyoudui.com/ac/contest/777001C8D00052502C078F6/problem/19312)
考虑暴力的做法是一条链用并查集暴力向上合并,将儿子并到父亲上,
启示我们联通块可以把贡献放在lca最高的点上,
具体而言,把联通快内的除最浅的点外权值全是 0 , 最浅的点是联通快内点的权值和,
这样向上找到第一个有值得点就是其所在联通快,用树剖维护区间清零,求和,单点修改,加个可持久化即可

## [开拓者](https://xinyoudui.com/ac/contest/777001C8D00052502C078F6/problem/19311)

## [「2017 山东三轮集训 Day7」Easy](https://loj.ac/p/6145)

## [[Violet] 蒲公英](https://www.luogu.com.cn/problem/P4168)
经典的分块题目 , 求众数不太有 log 级别做法,考虑分块 ,
**一个经典的处理分块的套路是预处理 $ans_{i,j}$ 表示块 i - j 的答案**,这显然可以 $\frac{n^2}{B}$ 时间预处理,
考虑散块对答案的贡献,我们要知道中间的整块中散块里某个数的出现次数,
因此维护一个桶在块上的前缀和,$s_{i,j}$ 表示前 i 个块中数 j 的出现次数

## [Flags](https://atcoder.jp/contests/arc069/tasks/arc069_d)
复习一下 2-set , **由于 2 者必选其一 , 所以在 2 - set 问题中我们能够将选了某个不能选另一个变为必须选某一个,**
这道题二分一下后就变成了 2 - set
在这道题中,对于点 i ,我们要连边 $i \rightarrow $ 距离 i 距离不够的点的反点,
这可以线段树优化建图,给所有点排序后,线段树叶子连向该位置点的反点

## [波形](https://xinyoudui.com/ac/contest/777001C8A00052502C07916/problem/19318)
其操作很有多项式的形式,如果把其看作多项式为 
$a_1 + a_2^x + a_3x^2 + \dots$ , 每次操作 A,B 相当于乘以 $(Bx + A)$,
每次询问我们可以将操作的多项式乘上去,或者枚举操作得到的多项式的每一项,
为了平衡复杂度,可以每操作 B 次就把多项式乘上去重构,否则就枚举操作的多项式每一项,
本质是运用了多项式的结合律来平衡复杂度

## [[COCI2015-2016#7] Prokletnik](https://www.luogu.com.cn/problem/P8037)

## [BZOJ3517 翻硬币](https://www.luogu.com.cn/problem/P10635)

## [interactive](https://qoj.ac/problem/8363)

## [[湖北省选模拟 2024] 永恒 / eternity](https://www.luogu.com.cn/problem/P10201)

## [小伙伴(friends)](https://xinyoudui.com/ac/contest/774001CB800048302EE4496/problem/10219)
答案下界是所有同颜色点对的较短距离之和,
如果两个颜色的交换路径有相交,那么一次交换能够同时对两个颜色都做出贡献,
猜测答案就是距离之和 - 路径相交的颜色对

## [Isolation](https://codeforces.com/problemset/problem/1129/D)
要维护区间内某种颜色的和,还有对颜色区间加减,考虑分块,
hack 了一下柳巨的 nb 的分块写法,
可以把一个块封装成结构体,然后把区间加减封装进结构体内,
对于散块修改,直接重构该块,
由于每次只会整体加减一,相当于更改该块的限制,打个标记即可,
然后在重构块时将标记搞到颜色上

## [「NOI2020」命运](https://loj.ac/p/3340)
先考虑朴素的 dp , 
对于子树 u 内所有未满足的点对,只要其中上节点最深的点对被满足了,其他点对都会被满足,
所以记 $f_{u,i}$ 表示分配完 u 子树后未满足的点对中上节点最深的点深度为 i ,若都满足了 i = 0,
(注意设计状态时尽量选择转移过程中不变的量,如深度,而不要选择类似点 u 向上多少之类的)
初始时 $f_{u,h_u} = 1$ , $h_u$ 为以 u 为下节点的点对中最深的上节点点对,
每次并入一颗子树 v ,链接的边有选或不选两种情况,
$f_{u,i} = \sum_{j = 0}^{dep_u} f'_{u,i}f_{v,j} + \sum_{j = 0}^{i} f'_{u,i}f_{v,j} + \sum_{j = 0}^{i - 1} f'_{u,j}f_{v,i} $
第一个和式代表选边,后两个不选该边,分表代表 u/v 为更大值,显然前缀和优化
令 $g_{u,i} = \sum_{j = 0}^i f_{u,j} $,则
$f_{u,i} = f'_{u,i}(g_{v,dep_u} + g_{v,i}) + f_{v,i}g'_{u,i - 1} $
**如果式子能通过前缀和等各种方式写成 i 的转移只与 i 有关,就能用线段树合并来优化**,
对此题具体而言,对于 $g$ 的求解,我们可以在递归中先递归左儿子再递归右儿子的过程中动态维护,
如果点为0,说明这棵树的这段 f 都为0,只算另一个树的贡献

## [[SDOI2015] 约数个数和](https://www.luogu.com.cn/problem/P3327)

## [基础数论练习题](https://xinyoudui.com/ac/contest/777001C8800052502C08756/problem/19328)

## [Opening Portals](https://codeforces.com/problemset/problem/196/E)
显然的暴力是跑出全源最短路,然后对于两两传送门其边权为这两个传送门的距离,跑最小生成树即可,加上 1 到最近传送门距离即为答案.
考虑根据最小生成树的性质优化这点,
对于生成树上一条边 u - v 来说,其再原图上的路径上的点一定是前半部分离 u 最近,后半部分离 v 最近的,
考虑反证 : 
如果最小生成树上 u - v 的路径在原图上有一个点离 k 更近,
那 u - k - v 会更优(w(u,v) > w(u,k) && w(u,v) > w(k,v)),就不是最小生成树了
所以以所有传送门为源点跑个多源最短路,记录每个点离哪个传送门最近,
每个原图的边连新图上距离他最近的两个传送门,权值为 $w + d_u + d_v$ , 新图跑最小生成树即可

注意这个和斯坦纳是完全不同的问题,考虑一个奔驰车标形状的图即可

## [Collecting](https://atcoder.jp/contests/abc214/tasks/abc214_h)
显然先求一下强连通分量,变成 DAG 后,注意到 $K\le 10$ , 考虑网络流,
一个显然的拆点后点内连流量 1 ,费用 $-a_i$,以及流量为 k - 1,费用为 0 的边,
但是负权边没法跑 迪杰斯特拉, 跑spfa复杂度会爆炸,考虑更改建模方式使边权为正,
费用流要最大化一个东西很难,总价值一定,考虑最小化未选的点,
考虑 DAG 的性质,如果一个人从 u 走到 v , 其就无法选择拓扑序在 u 到 v 之间的点,
所以我们点内连 流量为 1 , 花费为 0 , 以及流量为 K - 1,花费为 $w_i$ 的边,代表第二个人走这个点的人会损失代价
两个点间连流量为 K , 花费为他们拓扑序之间的权值和的边,代表走了这条边就会损失这些代价
每个点向汇点容量为 K - 1,连费用为拓扑序在该点之后的点权和
这样用原始对偶跑费用流后用 K * 总权值 - 费用流 即可

## [Ehab and the Expected GCD Problem](https://www.luogu.com.cn/problem/CF1174E)
考虑 f 的上界是 $log_2 n$ , 第一个开头的每个质因子的次数和是 $log_2 n$,
因此第一个数要么是 $2^{log_2}$ 或 $2^{log_2 - 1}*3$(不一定满足),
用 $f_{i,p,q}$ 表示填完第 i 个数后 g 为 $2^p * 3^q$ , 
g不变 , 可填个数就 $n / (2^p * 3^q) $ - 前面用掉的该倍数的数个数(就是填的数的个数)
g的某个次数 - 1,可填个数是类似的, n 中该数倍数的个数 - n 中转移来的数的倍数的个数

## [[AGC032E] Modulo Pairing](https://www.luogu.com.cn/problem/AT_agc032_e)

## [Tree Weights](https://codeforces.com/problemset/problem/1844/G)
显然权值是确定的,考虑确定树上前缀和 , $d_i + d_{i - 1} - 2 * d_{lca(i - 1,i)} = dis_i$,
如果式子只有 2 项比较好酸,式子内有个乘二,考虑把该项去除,考虑确定 $d_i \mod 2^k$ 的值,每次 k 增加一位,
$d_i \mod 2^k = x \rightarrow d_i \mod 2^{k + 1} = 2x$ , 所以就可以递推了

## [[POI 2021/2022 R1] Druk](https://www.luogu.com.cn/problem/P9417)
长度必然是 n / m 的因数,
证明 : 
对矩阵进行 $(i + j) % L$ 染色,那么不论如何放置,一个 $1 \times L$ 的矩形都会覆盖 L 种不同的颜色,
因此要求矩形每种颜色个数相同,则 $L | n 或 L | m$,
check 时枚举行放置,如果即能放行又能放列就放行即可,
证明 : 考虑模板串并不完全相同的情况,找到横着的第一个和当前位置不同的位置,
如果我竖着填了,由于上方都被填满了,这个位置永远无法被满足,所以必然横着填

## [Koxia and Sequence](https://codeforces.com/problemset/problem/1770/F)
如果 n 是偶数,那么 $ans = 0$ , 考虑把合法的非回文串和其反串对应,回文串本生就是 0 ,
如果 n 是偶数,我们任选一个数算他的贡献,剩下的数的贡献同 n 为偶数,为 0,下文中不妨求解 $a_1$ 的异或和,
由于 y 比较小,考虑对 $a_1$ 拆位考虑,枚举 $a_1$ 的第 k 位为 1 时的方案数的奇偶性
或恰好为 y 的限制比较难做,考虑或出来为 y 的子集方案为 g(y) , f(y) 恰好为 y,
则$f(y) = \sum_{y'\in y} (-1)^{ |y| - |y'| } g(y') $,
$g(y') = \sum_{\sum a_i = x - 2^k} [a_1 \in y' - 2^k] [a_2 \in y'] [a_3 \in y']\dots $,
套用lucas定理$g(y') = \sum_{\sum a_i = x - 2^k} {y' - 2^k \choose a_1}{y' \choose a_2}{y' \choose a_3}\dots = {ny' - 2^k \choose x - 2^k} $(范德蒙特卷积)

## [A Perfect Problem](https://codeforces.com/problemset/problem/1603/E)

## [彩糖与蔷薇的幻色颂](https://contest.xinyoudui.com/contest/318/problem/1626)
一眼考虑 dp 套 dp , 
如果模拟朴素的求解 LIS 的方法,即记录每个长度的 LIS 最小结束值状压一下即可,为 $3^n$,
考虑从小到大加入每一个数,记录 $f_i$ 为数组前 i 个元素的 LIS , 那么 f 每一项只会加一或不变,因此可以状压 f,
而每次加入一个数对 f 的变化是好求解的,
对于 a 是子序列的限制可以再多一维记录上一次个的 a 中的数的位置即可


## [Turtle](https://codeforces.com/problemset/problem/1239/E)

## [「JOISC 2014 Day3」稻草人](https://loj.ac/p/2880)

## [ [CERC2017] Buffalo Barricades](https://www.luogu.com.cn/problem/P4737)

## [[PA2014] Druzyny](https://www.luogu.com.cn/problem/P5979)
转移比较复杂,且难以构成区间,考虑 cdq 分治
**注意if内的continue外层 if 还有没有东西**

## [[Ynoi2009] rprmq1](https://www.luogu.com.cn/problem/P6109)
猫树分治题目 , 
如果询问的 l1 都是 1 ,那么一次扫描线用历史最值线段树即可,
询问时历史最大值并不具备可差分性质,这意味这我们只能加点,不能去点,所以从分治的角度出发考虑,
这题无法线段树分治,因为询问也是一个区间,这意味着每次询问除了会有父亲的贡献还有儿子的贡献,
算儿子的贡献要线段树合并,此题由于是主席树,时间复杂度不太对 (如果能够记录哪些点被改变了,好像也可以做 ?)
因此这题使用猫树分治(把询问放到猫树上) , 这样的好处是一个询问只会和一层树结构有关,坏处是需要撤销操作(这题显然可以)
对于猫树的每一层,我们要在每个中点处遗忘历史最大值即可,
将每个区间的历史最大值设置为当前区间最大值,这可以通过 +inf 后询问时 -inf 来实现,(额外记录一个 tag 也可以),
历史最大值注意先减后加

总结 :
**对于操作难以撤销的使用线段树分治**
**对于操作可去除影响,但询问难以差分的使用猫树分治**

## [交友问题](https://www.luogu.com.cn/problem/P8250)
图上有 $\sum deg_u = 2m$ , 因此根据度数大小进行值域分治有正确性,
即 > B 的点最多只有 $\frac{2m}{B}$ 个,
对于此题对于 > B 的点直接预处理出和每个点的答案,否则现算

## [Cowmpany Cowmpensation](https://codeforces.com/problemset/problem/995/F)
先写出暴力的 dp , $f_{u,d}$ 为子树 u 内值域为 $[1,d]$ 的方案数 ,
$f_{u,i} = f_{u,i - 1} + \prod_{v} f_{v,i} $,
对于这种 d 超级大的,枚举 矩乘 / 拉格朗日插值 / 组合意义 ... 等
此题对于 u 来说, $f_{u,i}$ 是一个关于 i 的 $siz_u$ 次多项式,
考虑归纳法证明,$siz_u = 1$ 时显然成立,即 $f_{u,i} = i$ , 
$f_{u,i} - f_{u,i - 1} = \prod f_{v,i} $ , 
如果 $f_{v,i}$ 是一个关于 i 的 $siz_v$ 次多项式 , 那么将其乘起来后就是关于 $\sum siz_v$ 的多项式,
对一个多项后前缀和次数加 1 ,因此次数为 $1 + \sum siz_v = siz_u$

**格朗日插值关键在于推出多项次数,要灵活运用前缀和次数 + 1,差分次数 -1 , 相乘次数相加,设元代换等方式**

## [[集训队互测 2012] calc](https://www.luogu.com.cn/problem/P4463)
拉格朗日插值 , 
要求互不相同,考虑求一个递增的序列然后乘 $n!$
$f_{i,j}$ 表示值域为 j ,长为 i 的严格递增序列值和
$f_{i,j} = f_{i,j - 1} + f_{i - 1,j - 1} * j $,关键求出 次数,
假设 $f_{n - 1,j}$ 为关于 j 的 $x$ 次多项式,一次 乘 j ,一次前缀和,则 $f_{n,j} $ 为 x + 2 次多项式,
所以 $f_{n,j}$ 即为 2 * n + 1 次多项式

## [回答问题](https://xinyoudui.com/ac/contest/774001CD600048302F90986/problem/20576)
手模性质,其一旦连续向左跳两次就不会再向右跳了,因此其答案形如先往右,穿插几次往左,最后一直往左
先考虑其最后一次移动是向右,到达点i的方案数记为 $f_i$,
然后考虑记录通过 $f_i$ 算出最后一步向左到达 i + 1 的方案数,分讨一下即可

即通过性质找到答案序列的特点形式来计算方案数

## [打BOSS](https://xinyoudui.com/ac/contest/774001CD600048302F90986/problem/20568)
类似题目先考虑将题意转换为较简单的形式, 如构造序列 等各种形式,
此题就是给出有个递减的序列 a , 要求出一个递减的序列 b , 使得 b 中至少有 m 个元素 = a 中对应元素,最终 b 和最小
即相等的就是要杀死,递减则是为了找出哪个相等的 boss 位置,
考虑 a 从小到大排序, $f_{i,j}$ 表示b前 i 个数中有 j 个相等 , 
则 $f_{i,j} = min f_{k,j - 1} + (a[i] - a[k])(n - i + 1) , k < i $,
用李超树优化即可

## [完全二叉树](https://xinyoudui.com/ac/contest/774001CD600048302F90986/problem/20578)
一个值的贡献是 n - 与前面的最长的lcp , 
**对于一个串和另一个串的 lcp 是好求得,套路的可以使用主席树二分,**
但一个串和另一些串的 lcp 并不好求,注意直接记录线段树每个点的历史 hash 出现值是错误的,因为右子树内匹配的可能左子树内不匹配,
**数 x 与一些数的最长 lcp 取自和其值域相邻的两个数(从trie上考虑)**,
所以用 set + 主席树 维护一下一下大小关系,然后每次查相邻两个即可
主席树维护 0/1 串比较大小就是先求出 lcp , 然后比较下一位即可

## [[NOI2015] 荷马史诗](https://www.luogu.com.cn/problem/P2168)
k 叉哈夫曼树最后一次合并时不到 k 个点,可以先补全一些 0 点,满足 $(n - 1) \mod (k - 1) = 0$

## [楼房重建](https://www.luogu.com.cn/problem/P4198)
显然变成斜率,即单点修改,维护为前缀最大值的个数,
考虑线段树,合并区间时就是左区间的长度 + 右区间中序列截断小于左侧最大值部分的长度,
用 $get(x,v)$ 表示子树 x 从 v 开始的序列的长度,
如果区间最大值 <= v 直接是 0 , 
左边最大值 <= v 就向右子树递归,否则向左子树递归 + ans[x] - ans[ls] (即原来右侧子树的贡献)

题解中还提到了一种做法,
离线操作,对时间建吉司机线段树,逐位确定每个位置对每个时间的贡献,
即修改一个区间内的最大值,修改成功就会给区间有 1 的贡献,
如果两个子树一个最大值大于一个小于,要想大于的递归下去,因此是 $log^2$ 的,
没看懂题解的单 log , 到时候问柳巨 ?

## [チーム分け](https://atcoder.jp/contests/mujin-pc-2018/tasks/mujin_pc_2018_f)
一个组的限制只与其中最小的 $a_i$ 有关,考虑在 $a_i$ 最小的位置统计一个组,
将 a 从大到小排序,$f_{i,j}$ 表示前 i 个人还有 j 个没选,统计时枚举一下该组有多少个有 $n^3$,
继续优化考虑将枚举人改为枚举组的大小, 
$f_{i,j}$ 表示组完了大小 $\ge$ i 的组后剩了 j 个人没组,
枚举大小为 i - 1 的组 组了 k 个,由于调和级数就是 $n^2 \log n$

## [Kevin and Bipartite Graph](https://codeforces.com/contest/2048/problem/E)
很妙的一道构造题,一个颜色最多就是蛇形连下去,
**我们考虑一个经典的循环构造**,每次将最前的两个为一组放到最后面,循环一次之内是不会有重边的,因为没有两个相同的相邻编号对

## [ [AHOI2021初中组] 地铁](https://www.luogu.com.cn/problem/P7624)
前缀和之后变为差分约束,问题在于有些约束中有三个变量,不能同余最短路做,
对此可以通过二分固定一个变量,全部转换为双变量问题,就可以跑同于最短路了,
我们每次找到负环后要知道如何调整才能使得该负环消失,因此要将距离表示成一个关于 C 的一次多项式

## [国土规划](https://www.luogu.com.cn/problem/P10517)
关键在于如何动态维护虚树,
**虚树的大小可以看作是所有点到 1 的路径的并 - 公共 lca 到 1 的路径**
而所有点到 1 的并就是 $\sum_{i} d[i] - d[lca(i,i - 1)] $ , 用 set 维护一下,每次插入删除只会改 O(1) 个值

## [远古密码](https://xinyoudui.com/ac/contest/774001CF700059A0325E616/problem/10173)
如果两个串完全相同,那么 AB 任选,否则其一定会有第一个不同的位置,我们从这个位置开始考虑,
手模发现 |A| 是串的一个周期, |B| 也是串的一个周期 , 且长度足够,那么 $\gcd(|A|,|B|)$ 也是串的一个周期,且长度已经够短了,
接下来分讨一下即可 :
1.|A| |B| 长度对应成比例,直接输出 26 幂次的前缀和
2.0,1个数都相同,但两个串不相同,那就是 $\sum_i \sum_j 26^{gcd(i,j)}$ 莫反一下即可

## [string](https://xinyoudui.com/ac/contest/774001CF700059A0325E616/problem/10243)
求数列的最多划分是很难的,但如果我们构造了n个最优的互不为前缀的串,把他们放一起,他们一定不会划出更多段,否则把最后一段删掉一定不是最优,
构造互不为前缀的数考虑 tril 树上构造,就是构造一个恰有 n 个叶子的 tril 树,贪心的每次找到一个深度最小的叶子把他拓展成两个即可,
由于值域很小,所以在值域上做复杂度就正确了

## [[GDCPC2023] Canvas](https://www.luogu.com.cn/problem/P9697)
显然两个 1 放最前面 , 两个 2 放最后面,考虑如何钦定 1 , 2 的顺序,
钦定 (u,v) 为 (2,1) , 那么 (u,v) , (v,w) 的效果为将 u,v 都置为 2 , w 变为 1 ,
类似传递性的效果启示我们建图,连边 u -> v , 如果我们绕环在走出去,那么这个环上的所有点都变成了 2 , 
更进一步的,我们 tarjan 搞出所有强连通分量,所有有出度的强连通分量都能全部变为 2 , 
对于没有出度的强连通分量,我们尽可能让有 2 , 2 的点变为环的结尾,这样其虽然会变成 1 , 但之后会变为 2
要找一个经过所有点至少一次的不经过重复边的不一定简单环比较难,
考虑时光倒流,这样就变成了任意找出一颗生成树即可

## [[COI2012] KAMPANJA](https://www.luogu.com.cn/problem/P4610)

## [[ARC147C] Min Diff Sum](https://www.luogu.com.cn/problem/AT_arc147_c)
绝对值难处理,不妨假设 $a_i$ 已经排好序 ,
$\sum_{2 \le 2 \le n} \sum_{1\le j \le i - 1} a_i - a_j = \sum_{1 \le i \le n} (2i - n - 1) a_i $,
我们将 i 和 n - i + 1 配对,则答案为 $\sum_{n - 2i + 1 \ge 1} (n - 2i + 1)(a_{n - i + 1} - a_i)  $ , 
我们贪心的让最大的取到 l(下界) , 最小的取 r(上界) , 
所以把 l 和 r 拍个序即可,如果此时对应位置的 $l \le r$ 了,说明其可以取相同的数了,贡献即为 0

## [Examination](https://atcoder.jp/contests/arc147/tasks/arc147_e)
把需要重排的集合放到数轴上,把 a 看作 1 , 把 b 看作 -1 , 
相当于从右往左作和没有 < 0 的部分,
考虑从右往左扫描线,如果遇到一个 < 0 的部分就加入一个满足的数对,
贪心的取 a > 当前值 , b 最小的数对即可

## [Clues](https://codeforces.com/problemset/problem/156/D)
问题转换为有 n 个点,点有点权, i 向 j 连边的方案数为 $a_ia_j$ , 
由于不同边之间合并方案数是乘法原理,我们可以将方案数分配到点上,
即若 u 连了 k 条边,则其贡献为 $a_u^k$
考虑构造 prufer 序列,先分配一手度数
$$
\begin{aligned}
总方案数 & = \sum_{d_1 + d_2 + d_3 + \dots = 2n - 2} {n - 2\choose d_1 - 1,d_2 - 1,d_3 - 1,\dots} \prod_i a_i^{d_i}\\
& = (\sum_i a_i)^{n - 2} \prod a_i & ex二项式反演
\end{aligned}
$$

## [[HNOI2008] 明明的烦恼](https://www.luogu.com.cn/problem/P2624)
考虑 $sum = \sum_i deg_i - 1 $ , 表示已经确定的度数的点占了prufer序列中 sum 个位置,
cnt 表示确定度数的点的个数
则已经确定度数的点在 prufer 序列中的方案数为 ${n - 2\choose sum} {sum\choose deg_1 - 1,deg_2 - 1,\dots} $
prufer 序列中剩下的位置任意填,因此额外乘上 $(n - cnt)^{n - sum - 2}$

## [[NOI Online 2021 提高组] 岛屿探险](https://www.luogu.com.cn/problem/P7470)

## [掃除 (Sweeping)](https://atcoder.jp/contests/joisc2020/tasks/joisc2020_c)

## [One to One](https://atcoder.jp/contests/arc140/tasks/arc140_d)
先把除 -1 之外的边连上,由于 n 个点 n 条边的联通块一定是一个环,
因此原图变为了一些树 + 一些基环树,一个树有且只有一个 -1, 基环树无 -1,
联通快的数量等价于环的数量,我们统计环的数量,一个环的贡献即为其方案数,
假设我们已经知道了某个环的由 k 棵树构成,那么其方案数为 $(k - 1)!\prod siz_i$,
拆一下贡献,
记 $f_i$ 为搞出大小为 i 的环的只算了 $\prod siz_i$ 的贡献,这个可以背包一下求解
最后乘上 $(i - 1)!$ 即可

## [12_30_A 计数题](https://xinyoudui.com/ac/contest/777001CFA0005C803571326/problem/19366)
先把期望转为方案数,合法的比较难算,考虑用全部 - 不合法的方案数,
记 $f_{i,j}$ 表示抽到第 i 级卡且抽到星级都 < j 的合法方案数,
每层转移时合法 - 不合法 $f_{i,j} = f_{i - 1,j}^{b_i} - f_{i - 1,i - 1}^{b_i} $

考虑所有方案中算抽到第 k 的个数之和,由于每个更低等级的抽卡完全相同,
$g_{i,j} = g_{i - 1,j} * b_i * f_{i - 1,j}^{b_i - 1} - g_{i - 1,i - 1} * b_i * f_{i - 1,i - 1}^{b_i - 1} $,
初始化时 $g_{0,t} = a_k , t \ge k$ , 

由于转移全部是线性的,所以可以反算算出系数即可

## [12_30_B 构造题](https://xinyoudui.com/ac/contest/777001CFA0005C803571326/problem/19367)
考虑 subtask2 只要父亲找儿子即可,
二分可以找到编号最小的儿子,然后把该子树抛掉找下个儿子,从后往前做即可
subtask3 只要能够找到一种排列方式,若 i 是 j 的祖先,则 i 一定在 j 前面出现即可,
考虑插入排序,每次二分新加入的数在哪里即可

## [Button Lock](https://codeforces.com/problemset/problem/1510/B)
显然可以转换为最长链覆盖,因此考虑建立二分图,一个东西做出贡献当且仅当其没有匹配,其贡献为pop_count,跑费用流即可
还有一个想法是按照价值从大到小跑匈牙利也可以,要获得更优复杂度,可以考虑对于每种权值跑最大流,跑更小权值是把大的删掉即可

## [壊れた機器](https://atcoder.jp/contests/joisc2017/tasks/joisc2017_e)
朴素做法是两个为一组,坏的为 00 ,剩下三进制分解,
还有做法是随机两个一模一样的随机序列,a 把异或和为 x 且好的点标记为 1, 这可以用线性基轻松做到,
正确性考虑每次加入一个随机数时线性基空间扩大的概率

即随机数的异或线性基很大情况下都是满秩的

## [Sorting Game](https://www.luogu.com.cn/problem/AT_nomura2020_f)

## [边三连通分量](https://www.luogu.com.cn/problem/P6658)

## [「ROI 2017 Day 2」学习轨迹](https://www.luogu.com.cn/problem/P10656)
注意到一个性质 : 两个序列的带权重心至少有一个被包含,否则一定不如全选权值大的
我们钦定第二个序列必须选带权重心,对第一个序列扫描线,维护 l 至当前右端点的 a 的限制下第二个序列包含带权重心的区间长度.
发现加入右端点形如对值取 max / min , 所以可以用单调栈 + 区间加减线段树维护

## [[SHOI2016] 黑暗前的幻想乡](https://www.luogu.com.cn/problem/P4336)

## [【模板】莫队二次离线（第十四分块(前体)）](https://www.luogu.com.cn/problem/P4887)

## [摸爬滚打](https://xinyoudui.com/ac/contest/777001CF90005C8035AB606/problem/19374)

## [Histogram Rooks](https://atcoder.jp/contests/agc041/tasks/agc041_f)

## [Again ABC String](https://atcoder.jp/contests/arc147/tasks/arc147_f)
对指数二进制分解的技巧 ?

## [[JOISC2022] 鱼 2](https://www.luogu.com.cn/problem/P9530)

## [Chests and Keys](https://codeforces.com/problemset/problem/1519/F)

## [[EC Final 2020] Random Shuffle](https://www.luogu.com.cn/problem/P10818)
考虑记录每个位置有那些位置贡献,然后对于 $x \mod (2^ic) = r$ 来说,
其实等价于 r 的末 i 位与 x 的末 i 位相同,因为 $x = k (2^i c) + r = (kc)2^i + r$,
所以我们就得到了很多异或方程组,解方程然后对自由元暴力枚举即可.

实现细节 : 注意在存在自由元的高斯消元中当前行号 $\neq$ 当前列号

## [[北大集训 2021] 出题高手](https://www.luogu.com.cn/problem/P8991)
对于随机序列,其单调栈的期望长度是 $log$ 的,每次使长度变长要大于前面所有元素,则要期望生成倍长的序列才行
其前缀和的单调栈的期望长度是 $\sqrt n$ 的,
如果直接二维数对是 $n \sqrt n \log n$ 的,使用分块 O(1) 修改,$O(\sqrt n)$ 查询则为 $n\sqrt n$ , 都过不去
**对于区间类问题一定要尝试一下分治算法** 
我们注意到该单调栈的性质对于区间两边都有用,即对于横跨 mid 的区间 , 其可能成为答案的两个端点一定在两边的单调栈上的点上,
而每边只有 $\sqrt n$ 个点,暴力枚举对就 $O(n)$ , 因此可以用分治解决

实现细节 : 要用分治求 l , r 内所有子区间的最大值,并不需要写两边,一边正常枚举,另一边记录一个全局变量类似 cdq 更新即可

## [YY的GCD](https://www.luogu.com.cn/problem/P2257)
经典套路题,
$$
\begin{aligned} 
ans & =\sum_{g \in prime}\sum_{i}^{\lfloor \frac{n}{g} \rfloor}\sum_{j}^{\lfloor \frac{m}{g}\rfloor} [gcd(i,j) = 1]\\ &= \sum_{g\in prime} \sum_{d} \mu (d) \lfloor \frac{n}{gd}\rfloor \lfloor \frac{m}{gd} \rfloor\\
& = \sum_{T} \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor \sum_{g | T,g\in prime} \mu (\frac{T}{g})
\end{aligned}
$$
对于 $\sum_{g | T,g\in prime} \mu (\frac{T}{d})$ , 可以预处理,具体而言,枚举每个质数以及倍数即可

## [抓小偷](https://xinyoudui.com/ac/contest/777001D4000066C03C90386/problem/19465)
最优策略警察第一步肯定走 1 号节点,然后每次两个儿子选一个进入,
如果小偷在该子树,就继续在这个子树里抓,否则去另一颗子树,考虑决策先进去哪课子树,
$f_{u,i}$ 表示在第 i 个时刻进入子树 u 时最优能保证抓到几个位置的小偷,则
$f_{u,i} = max(f_{ls,i} + f_{rs,i + 1},f_{ls,i + 1} + f_{rs,i})$ ,
为了简化计算,我们将在 u 上抓到的小偷放到叶子上统计贡献,即短链剖分后叶子 $f_{u,i} = 链长 - i$ ,
点 u 上的小偷就算决策上去了另外一颗子树,他最多走一步,所以仍会被计入贡献
最后用类似长链剖分的技巧维护即可

## [传球](https://xinyoudui.com/ac/contest/777001D4100066C03C900A6/problem/19473)
本质上是一个长度为 n 的括号匹配,如果我们钦定任意一段为一个括号匹配,可以直接转化为挖掉那一段为括号匹配
我们根据给出的 k 个匹配包含关系建树 , $f_{i,j}$ 表示第 i 个配对的部分可以转换为 j 个空位的方案数,类似背包转移

## [水杯](https://www.xinyoudui.com/ac/contest/774001D7900059A0432AE76/problem/19478)
设 b 为当且水量
观察到水一定是先往右最后往左一步,且往左的一步量也是 $min (a_v,b_u)$,因为如果 v 中有剩水,则 u 中的水来自 v
考虑拆贡献,将贡献分为下一步剩下的水和结束时往左倒入的水,
对于第一类,考虑对值域从大到小