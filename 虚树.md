## 虚树
在许多题目中,答案的求得只与其中的一些关键点有关,
这时为了更高的效率,我们可以忽略掉一些与答案无关的点,
只保留关键点以及连接他们所必须的点,新建一棵树

问题来到了如何找到这些连接关键点所必须的点,
显然,将x 和 y放在一颗子树中,我们需要它们的lca才能连接两个点,
连接有传递性,直接把相邻的连接起来即可
考虑如何建树,
**我们需要维持树的祖先 - 儿子关系,因此想到dfn序**
**(其相邻2个点要么在一条链上,要么在最靠近的链中)**,
按照dfn排序后对相邻的点作lca,
但这样需要找点时配合,也按照dfn排序后再找点

其实该做法应该是在另一种做法上改进而来的,
所以有许多难以想到的做法.

```cpp
    d[++cnt] = 1;
    sort(d + 1,d + 1 + k,cmp);
    fq(i,2,k) d[++cnt] = lca(d[i],d[i - 1]);
    sort(d + 1,d + 1 + cnt,cmp);
    cnt = unique(d + 1,d + 1 + cnt) - d - 1;
    fq(i,2,cnt) {
        int f = lca(d[i],d[i - 1]);
        tr[f].push_back({d[i],gw(f,d[i])});
    }
```
[[SDOI2011] 消耗战](https://www.luogu.com.cn/problem/P2495)

**这类题常常以染色 , 或 $sum \leq ...$为标志**