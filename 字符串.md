## 回文串
### manacher
### 字符串hash
枚举每个点,然后二分求得以该点为中点的最长回文串

### 回文自动机
回文自动机是一种字典树,
从起点出发走到任意节点,可以得到回文串的一半,
注意:**回文自动机跑出的是从中间开始的一半**
但是回文串可以分为偶回文和奇回文,
可以建2个根

当插入一个字符时,
从上次的节点开始看,如果上次节点加该字符构成了回文串,就直接插入
否则就跳失配指针,不难发现,失配指针应当是回文后缀
失配指针用同种方式求得即可

用到了 回文串 = c + 回文串 + c
以及新加点时,小的回文串一定包含在大的回文串里面,
之前已经处理过了

```cpp
class Pam{
public:
    vector<char> s;
    class nd{public: int ch[26],len,fail;} tr[N << 1];
    int cnt,last;

    Pam() {
        last = 1,cnt = 1;
        tr[1].fail = tr[0].fail = 1;
        tr[0].len = 0; tr[1].len = -1;
        /*这里要把偶回文设为0,
        因为如果找不到更小的后缀,fail指向len = 0的点*/
    }
    void add(char c) {
        s.push_back(c); c -= 'a';
        int x = s.size() - 1 , p = last;
        while(s[x] != s[x - tr[p].len - 1]) {p = tr[p].fail;}
        if(!tr[p].ch[c]) {
            int np = ++cnt; tr[np].len = tr[p].len + 2;
            int q = tr[p].fail; //找np的真后缀
            while(s[x] != s[x - tr[q].len - 1]) {q = tr[q].fail;}
            tr[np].fail = tr[q].ch[c];
            tr[p].ch[c] = np; /*注意要在最后赋值p的孩子,因为p,q可能是同一个点 1*/
        } last = tr[p].ch[c];
    }
} pam;
```
[模板](https://www.luogu.com.cn/problem/P5496)

#### 正确性
1.该树中包含了所有的回文串 
证明:每次新加字符c,找到其构成的最长的回文串,
那么其形成的其他回文串一定在这个最长回文串中,已经加入过树了
2.时间复杂度是线性的
证明:类似于kmp,
跳fail会降低深度,而加入一个节点会增加深度,
所以最多跳n次fail
#### 应用
1.本质不同的回文串个数: 显然为cnt - 2
由此也能发现一个字符串最多有n个本质不同回文串
2.pam实际维护了回文串的归属关系,
即fail树维护了一个回文串是另一个回文串的后缀