## 回文串
### manacher
### 字符串hash
枚举每个点,然后二分求得以该点为中点的最长回文串

### 回文自动机
回文自动机是一种字典树,
从起点出发走到任意节点,可以得到回文串的一半,
注意:**回文自动机跑出的是从中间开始的一半**
但是回文串可以分为偶回文和奇回文,
可以建2个根

当插入一个字符时,
从上次的节点开始看,如果上次节点加该字符构成了回文串,就直接插入
否则就跳失配指针,不难发现,失配指针应当是回文后缀
失配指针用同种方式求得即可

用到了 回文串 = c + 回文串 + c
以及新加点时,小的回文串一定包含在大的回文串里面,
之前已经处理过了

```cpp
class Pam{
public:
    vector<char> s;
    class nd{public: int ch[26],len,fail;} tr[N << 1];
    int cnt,last;

    Pam() {
        last = 1,cnt = 1;
        tr[1].fail = tr[0].fail = 1;
        tr[0].len = 0; tr[1].len = -1;
        /*这里要把偶回文设为0,
        因为如果找不到更小的后缀,fail指向len = 0的点*/
    }
    void add(char c) {
        s.push_back(c); c -= 'a';
        int x = s.size() - 1 , p = last;
        while(s[x] != s[x - tr[p].len - 1]) {p = tr[p].fail;}
        if(!tr[p].ch[c]) {
            int np = ++cnt; tr[np].len = tr[p].len + 2;
            int q = tr[p].fail; //找np的真后缀
            while(s[x] != s[x - tr[q].len - 1]) {q = tr[q].fail;}
            tr[np].fail = tr[q].ch[c];
            tr[p].ch[c] = np; /*注意要在最后赋值p的孩子,因为p,q可能是同一个点 1*/
        } last = tr[p].ch[c];
    }
} pam;
```
[模板](https://www.luogu.com.cn/problem/P5496)
**在编写代码时谨记,**
**凡是自动机,加点时先修改自己的信息(len,link,fail,ch...),**
**再修改其他点的信息,$tr[p].ch$....,因为自己的信息依赖与其他点的信息**
**这点对于SAM也是适用的**

#### 正确性
1.该树中包含了所有的回文串 
证明:每次新加字符c,找到其构成的最长的回文串,
那么其形成的其他回文串一定在这个最长回文串中,已经加入过树了
2.时间复杂度是线性的
证明:类似于kmp,
跳fail会降低深度,而加入一个节点会增加深度,
所以最多跳n次fail
#### 应用
1.本质不同的回文串个数: 显然为cnt - 2
由此也能发现一个字符串最多有n个本质不同回文串
2.pam实际维护了回文串的归属关系,
即fail树维护了一个回文串是另一个回文串的后缀

## SA(后缀数组)
### 定义
$sa[i]$表示排名为 i 的后缀为那个
$rk[i]$表示后缀 i 在所有后缀中的排名
### 求法
倍增
### 应用
#### 任两点lcp
后缀数组将字符串按照字典序排序,因此在求解lcp中有优势
记i,j为排名为i和j的后缀字符串
因为按照字典序排序了,所以有,
$lcp(i,j) = min(lcp(i,k),lcp(k,j)) ,i < k < j$,
所以求出两两间的lcp即可
记 $height(i)$ 表示 $lcp(i,i - 1)$ ,如何快速求解 ?

$height[rk[i]] \ge height[rk[i - 1]] + 1 $,
因为$rk[i - 1] - 1$ 去掉开头代表的串肯定在 $rk[i]$ 前,
画个图发现确实是对的

运用这个性质暴力求解即可

#### 多个字符串的lcs
lcs可以转换为一些后缀的lcp,
所以先二分lcs的长度,然后每次找到最长的最小值大于lcs的区间,
看区间内是否包含所有字符串即可

## 周期定理
如果 p 是字符串 s 的周期 , q 也是 s 的周期 , 且 $p + q - \gcd(p,q) \ge |S|$ ,
则$gcd(p,q)$ 是 s 的一个周期

先考虑字符串无限长的情况,考虑 S 的最小周期 T , 则 $T | p,T | q$ , 因此能够推出该结论,

考虑字符串的长度要足够长,否则无法推出结论 :
p = 4,q = 6,|S| = 7 : ABACABA , 

$|S| = p + q - gcd(p,q)$ 时一定能推出结论,先考虑 $p \perp q$ 的情况,
建立点数为 p + q - 1 的图,点 i 向 i + p 和 i + q 连边,总共连出了 p + q - 2 条边,
每个点都有连边,因此其为一颗树,所以其周期即为 1,
对于 gcd 不为 1 的情况,我们可以考虑按照 $\mod gcd$ 分类

### lyc定理 1
长度 $> \frac{|S|}{2}$ 的所有 border 构成了等差数列

### lyc定理 2
如果 $|S| \ge \frac{|T|}{2}$ , 则|S| 再 |T| 中的所有出现位置构成等差数列